🔎 Co dokładnie masz zrobić
1. Stworzyć klasę Zombie

Każdy zombie ma imię (std::string name).

Każdy zombie umie się przedstawić – metodą announce(), np.:

Foo: BraiiiiiiinnnzzzZ...

Gdy zombie „umiera” (czyli wywoła się destruktor), musi wypisać komunikat debugowy, np.:

Zombie Foo destroyed

👉 Dzięki temu będziesz wiedzieć, kiedy zombie powstaje i kiedy zostaje zniszczony.

2. Stworzyć funkcję newZombie(std::string name)

Ta funkcja:
Tworzy nowego zombie na stercie (heap) za pomocą new.
Nadaje mu imię (name).
Zwraca wskaźnik (Zombie*) do tego zombie.
👉 Po co?
Bo zombie utworzony w ten sposób będzie żył dalej, nawet po zakończeniu funkcji, dopóki go nie usuniesz (delete).

3. Stworzyć funkcję randomChump(std::string name)

Ta funkcja:
Tworzy zombie na stosie (stack) – czyli zwykły obiekt lokalny:
Zombie z(name);
Wywołuje na nim announce().
Po zakończeniu funkcji zombie automatycznie się zniszczy (bo był na stosie).
👉 Po co?
Żeby pokazać drugi sposób życia obiektu: krótko, tylko w trakcie działania funkcji.

4. Testować w main.cpp
Masz wywołać oba sposoby i zobaczyć różnicę.
Przykład:

int main() {
    Zombie* z1 = newZombie("HeapZombie"); // tworzenie na heap
    z1->announce();                       // zombie mówi
    delete z1;                            // ręczne zabicie zombie

    randomChump("StackZombie");           // tworzenie na stack
    // zombie mówi i sam się niszczy
}

🎯 Po co to zadanie?
Żebyś nauczył się pisać klasy (atrybuty, metody, konstruktor, destruktor).
Żebyś zrozumiał różnicę między heap a stack w praktyce.
Żebyś nauczył się pilnować pamięci (delete dla obiektów z new).
✅ Plan – krok po kroku

Zombie.hpp – napisz klasę (atrybut name, konstruktor, destruktor, announce()).
Zombie.cpp – zaimplementuj metody (announce() i destruktor).
newZombie.cpp – funkcja Zombie* newZombie(std::string name).
randomChump.cpp – funkcja void randomChump(std::string name).
main.cpp – testy obu funkcji.

Uruchom program i obserwuj kolejność komunikatów

Jak działa new w C++?
new służy do dynamicznej alokacji pamięci na stercie (heap).
Kiedy tworzysz obiekt normalnie, np. Zombie z("Foo");, to taki obiekt istnieje tylko w aktualnym bloku (na stosie) i znika, gdy program wyjdzie z funkcji.
Kiedy używasz new, tworzysz obiekt, który pozostaje w pamięci aż do momentu, gdy ręcznie go usuniesz (delete).
🔹 Jak używa się new krok po kroku:
Piszesz new i nazwę klasy, np. Zombie.
Jeśli klasa ma konstruktor, możesz od razu podać argumenty, np. new Zombie("Foo").
To utworzy obiekt klasy Zombie na heap.
new zawsze zwraca wskaźnik do tego nowego obiektu.
Dlatego wynik przypisujesz do zmiennej wskaźnikowej, np. Zombie*.
Taki wskaźnik możesz potem używać do wywoływania metod (->).

🔹 Pamięć w programie C++ dzieli się m.in. na:

Stos (stack)
To pamięć automatyczna.
Każda funkcja dostaje swój kawałek stosu na zmienne lokalne.
Gdy funkcja się kończy → wszystko ze stosu znika.
Przykład:

void foo() {
    Zombie z("Foo");  // ten zombie istnieje tylko w tej funkcji
} // koniec funkcji → z zostaje automatycznie zniszczony

Sterta (heap)
To pamięć dynamiczna.
Program sam decyduje, kiedy coś stworzyć i kiedy to usunąć.
Obiekt tworzysz za pomocą new i musisz sam go usunąć za pomocą delete.

Przykład:

Zombie* z = new Zombie("Foo"); // zombie żyje, dopóki nie zrobisz delete
delete z;                      // teraz pamięć jest zwolniona

🔹 Różnica między malloc (z C) a new (z C++)
malloc (C):
Rezerwuje kawałek surowej pamięci (np. 32 bajty).
Nie wywołuje konstruktora obiektu.
Trzeba rzutować wskaźnik i samodzielnie zarządzać pamięcią.
Zwolnienie pamięci robisz przez free().
Przykład w C:

int* ptr = (int*)malloc(sizeof(int) * 10);
free(ptr);

new (C++):

Tworzy obiekt i od razu wywołuje konstruktor.
Zwraca wskaźnik właściwego typu (nie trzeba rzutować).
Zwolnienie pamięci robisz przez delete (dla tablicy: delete[]).
Przykład w C++:
Zombie* z = new Zombie("Foo"); // konstruktor zostaje wywołany
delete z; // wywoływany jest też destruktor

🔹 Dlaczego w C++ wolimy new zamiast malloc?
Bo new jest bardziej bezpieczne i „inteligentne”: wie, jak wywołać konstruktor i destruktor klasy.
malloc nie zna się na obiektach – działa tylko jak „zamów kawałek pamięci w bajtach”.

👉 Podsumowanie w jednym zdaniu:

Stack = pamięć automatyczna (obiekt znika sam, gdy kończy się funkcja).
Heap = pamięć dynamiczna (musisz sam użyć delete).
malloc = „surowe” rezerwowanie pamięci (C).
new = nowoczesny sposób w C++ do tworzenia obiektów na heap, wywołuje konstruktor i daje Ci gotowy obiekt.

newZombie
🔹 Co robi ta funkcja w praktyce

Przyjmuje imię zombie jako parametr.
Tworzy nowy obiekt Zombie na heap z tym imieniem.
Zwraca wskaźnik do tego zombie, żeby można było go używać poza funkcją.
Dlaczego używamy new?
Bo chcemy, żeby zombie nie znikał od razu po wyjściu z funkcji.
Jeżeli stworzymy zombie na stacku (lokalnie), np. Zombie z(name);, to zniknie po zakończeniu funkcji i nie możemy go użyć w main()

🔹 Konstruktor Zombie::Zombie(std::string name)
Zombie::Zombie(std::string name) : name(name) {}
Po co jest konstruktor?
Konstruktor to specjalna funkcja klasy, która wywoływana jest automatycznie, gdy tworzysz obiekt.

Tutaj:
przyjmuje parametr name – imię zombie, które chcesz nadać.
przypisuje je do atrybutu obiektu name.

Efekt:
Każdy zombie ma swoje własne imię od razu po utworzeniu.
Nie musisz robić dodatkowych funkcji do ustawiania imienia.

Po co jest destruktor?

Destruktor to funkcja, która wywołuje się automatycznie, gdy obiekt znika:
Stack → po wyjściu z funkcji, w której został utworzony.
Heap → gdy wywołasz delete na wskaźniku do obiektu.
Tutaj destruktor wypisuje komunikat, że zombie został zniszczony.
Efekt praktyczny:
Możesz łatwo debugować, kiedy pamięć jest zwalniana.
Widać różnicę między zombie na heap (musisz wywołać delete) a stack (niszczy się automatycznie).

1️⃣ Konstruktor
Zombie::Zombie(std::string name)
{
    this->name = name;
}

Funkcja wywoływana automatycznie, gdy tworzysz obiekt Zombie.
Przypisuje podane imię (name) do atrybutu obiektu this->name.
Dzięki temu każdy zombie ma swoje własne imię od razu po utworzeniu.
Przykład działania:
Zombie z("Foo");  // konstruktor nada imię "Foo"

~Zombie()
Znak tylda ~ przed nazwą funkcji w C++ oznacza destruktor.
Destruktor to specjalna funkcja klasy, która wywoływana jest automatycznie, gdy obiekt przestaje istnieć.
2️⃣ Destruktor
Zombie::~Zombie()
{
    std::cout << "Destructor zombie: " << this->name << std::endl;
}

Funkcja wywoływana automatycznie, gdy obiekt znika:
Stack: po wyjściu z funkcji/bloku, w którym został stworzony.
Heap: po wywołaniu delete na wskaźniku do obiektu.
Wypisuje komunikat debugowy, że obiekt został zniszczony i pokazuje jego imię.
Przykład działania:
Zombie* z = newZombie("Bar");
delete z;  // zobaczysz "Destructor zombie: Bar
