ğŸ” Co dokÅ‚adnie masz zrobiÄ‡
1. StworzyÄ‡ klasÄ™ Zombie

KaÅ¼dy zombie ma imiÄ™ (std::string name).

KaÅ¼dy zombie umie siÄ™ przedstawiÄ‡ â€“ metodÄ… announce(), np.:

Foo: BraiiiiiiinnnzzzZ...

Gdy zombie â€umieraâ€ (czyli wywoÅ‚a siÄ™ destruktor), musi wypisaÄ‡ komunikat debugowy, np.:

Zombie Foo destroyed

ğŸ‘‰ DziÄ™ki temu bÄ™dziesz wiedzieÄ‡, kiedy zombie powstaje i kiedy zostaje zniszczony.

2. StworzyÄ‡ funkcjÄ™ newZombie(std::string name)

Ta funkcja:
Tworzy nowego zombie na stercie (heap) za pomocÄ… new.
Nadaje mu imiÄ™ (name).
Zwraca wskaÅºnik (Zombie*) do tego zombie.
ğŸ‘‰ Po co?
Bo zombie utworzony w ten sposÃ³b bÄ™dzie Å¼yÅ‚ dalej, nawet po zakoÅ„czeniu funkcji, dopÃ³ki go nie usuniesz (delete).

3. StworzyÄ‡ funkcjÄ™ randomChump(std::string name)

Ta funkcja:
Tworzy zombie na stosie (stack) â€“ czyli zwykÅ‚y obiekt lokalny:
Zombie z(name);
WywoÅ‚uje na nim announce().
Po zakoÅ„czeniu funkcji zombie automatycznie siÄ™ zniszczy (bo byÅ‚ na stosie).
ğŸ‘‰ Po co?
Å»eby pokazaÄ‡ drugi sposÃ³b Å¼ycia obiektu: krÃ³tko, tylko w trakcie dziaÅ‚ania funkcji.

4. TestowaÄ‡ w main.cpp
Masz wywoÅ‚aÄ‡ oba sposoby i zobaczyÄ‡ rÃ³Å¼nicÄ™.
PrzykÅ‚ad:

int main() {
    Zombie* z1 = newZombie("HeapZombie"); // tworzenie na heap
    z1->announce();                       // zombie mÃ³wi
    delete z1;                            // rÄ™czne zabicie zombie

    randomChump("StackZombie");           // tworzenie na stack
    // zombie mÃ³wi i sam siÄ™ niszczy
}

ğŸ¯ Po co to zadanie?
Å»ebyÅ› nauczyÅ‚ siÄ™ pisaÄ‡ klasy (atrybuty, metody, konstruktor, destruktor).
Å»ebyÅ› zrozumiaÅ‚ rÃ³Å¼nicÄ™ miÄ™dzy heap a stack w praktyce.
Å»ebyÅ› nauczyÅ‚ siÄ™ pilnowaÄ‡ pamiÄ™ci (delete dla obiektÃ³w z new).
âœ… Plan â€“ krok po kroku

Zombie.hpp â€“ napisz klasÄ™ (atrybut name, konstruktor, destruktor, announce()).
Zombie.cpp â€“ zaimplementuj metody (announce() i destruktor).
newZombie.cpp â€“ funkcja Zombie* newZombie(std::string name).
randomChump.cpp â€“ funkcja void randomChump(std::string name).
main.cpp â€“ testy obu funkcji.

Uruchom program i obserwuj kolejnoÅ›Ä‡ komunikatÃ³w

Jak dziaÅ‚a new w C++?
new sÅ‚uÅ¼y do dynamicznej alokacji pamiÄ™ci na stercie (heap).
Kiedy tworzysz obiekt normalnie, np. Zombie z("Foo");, to taki obiekt istnieje tylko w aktualnym bloku (na stosie) i znika, gdy program wyjdzie z funkcji.
Kiedy uÅ¼ywasz new, tworzysz obiekt, ktÃ³ry pozostaje w pamiÄ™ci aÅ¼ do momentu, gdy rÄ™cznie go usuniesz (delete).
ğŸ”¹ Jak uÅ¼ywa siÄ™ new krok po kroku:
Piszesz new i nazwÄ™ klasy, np. Zombie.
JeÅ›li klasa ma konstruktor, moÅ¼esz od razu podaÄ‡ argumenty, np. new Zombie("Foo").
To utworzy obiekt klasy Zombie na heap.
new zawsze zwraca wskaÅºnik do tego nowego obiektu.
Dlatego wynik przypisujesz do zmiennej wskaÅºnikowej, np. Zombie*.
Taki wskaÅºnik moÅ¼esz potem uÅ¼ywaÄ‡ do wywoÅ‚ywania metod (->).

ğŸ”¹ PamiÄ™Ä‡ w programie C++ dzieli siÄ™ m.in. na:

Stos (stack)
To pamiÄ™Ä‡ automatyczna.
KaÅ¼da funkcja dostaje swÃ³j kawaÅ‚ek stosu na zmienne lokalne.
Gdy funkcja siÄ™ koÅ„czy â†’ wszystko ze stosu znika.
PrzykÅ‚ad:

void foo() {
    Zombie z("Foo");  // ten zombie istnieje tylko w tej funkcji
} // koniec funkcji â†’ z zostaje automatycznie zniszczony

Sterta (heap)
To pamiÄ™Ä‡ dynamiczna.
Program sam decyduje, kiedy coÅ› stworzyÄ‡ i kiedy to usunÄ…Ä‡.
Obiekt tworzysz za pomocÄ… new i musisz sam go usunÄ…Ä‡ za pomocÄ… delete.

PrzykÅ‚ad:

Zombie* z = new Zombie("Foo"); // zombie Å¼yje, dopÃ³ki nie zrobisz delete
delete z;                      // teraz pamiÄ™Ä‡ jest zwolniona

ğŸ”¹ RÃ³Å¼nica miÄ™dzy malloc (z C) a new (z C++)
malloc (C):
Rezerwuje kawaÅ‚ek surowej pamiÄ™ci (np. 32 bajty).
Nie wywoÅ‚uje konstruktora obiektu.
Trzeba rzutowaÄ‡ wskaÅºnik i samodzielnie zarzÄ…dzaÄ‡ pamiÄ™ciÄ….
Zwolnienie pamiÄ™ci robisz przez free().
PrzykÅ‚ad w C:

int* ptr = (int*)malloc(sizeof(int) * 10);
free(ptr);

new (C++):

Tworzy obiekt i od razu wywoÅ‚uje konstruktor.
Zwraca wskaÅºnik wÅ‚aÅ›ciwego typu (nie trzeba rzutowaÄ‡).
Zwolnienie pamiÄ™ci robisz przez delete (dla tablicy: delete[]).
PrzykÅ‚ad w C++:
Zombie* z = new Zombie("Foo"); // konstruktor zostaje wywoÅ‚any
delete z; // wywoÅ‚ywany jest teÅ¼ destruktor

ğŸ”¹ Dlaczego w C++ wolimy new zamiast malloc?
Bo new jest bardziej bezpieczne i â€inteligentneâ€: wie, jak wywoÅ‚aÄ‡ konstruktor i destruktor klasy.
malloc nie zna siÄ™ na obiektach â€“ dziaÅ‚a tylko jak â€zamÃ³w kawaÅ‚ek pamiÄ™ci w bajtachâ€.

ğŸ‘‰ Podsumowanie w jednym zdaniu:

Stack = pamiÄ™Ä‡ automatyczna (obiekt znika sam, gdy koÅ„czy siÄ™ funkcja).
Heap = pamiÄ™Ä‡ dynamiczna (musisz sam uÅ¼yÄ‡ delete).
malloc = â€suroweâ€ rezerwowanie pamiÄ™ci (C).
new = nowoczesny sposÃ³b w C++ do tworzenia obiektÃ³w na heap, wywoÅ‚uje konstruktor i daje Ci gotowy obiekt.

newZombie
ğŸ”¹ Co robi ta funkcja w praktyce

Przyjmuje imiÄ™ zombie jako parametr.
Tworzy nowy obiekt Zombie na heap z tym imieniem.
Zwraca wskaÅºnik do tego zombie, Å¼eby moÅ¼na byÅ‚o go uÅ¼ywaÄ‡ poza funkcjÄ….
Dlaczego uÅ¼ywamy new?
Bo chcemy, Å¼eby zombie nie znikaÅ‚ od razu po wyjÅ›ciu z funkcji.
JeÅ¼eli stworzymy zombie na stacku (lokalnie), np. Zombie z(name);, to zniknie po zakoÅ„czeniu funkcji i nie moÅ¼emy go uÅ¼yÄ‡ w main()

ğŸ”¹ Konstruktor Zombie::Zombie(std::string name)
Zombie::Zombie(std::string name) : name(name) {}
Po co jest konstruktor?
Konstruktor to specjalna funkcja klasy, ktÃ³ra wywoÅ‚ywana jest automatycznie, gdy tworzysz obiekt.

Tutaj:
przyjmuje parametr name â€“ imiÄ™ zombie, ktÃ³re chcesz nadaÄ‡.
przypisuje je do atrybutu obiektu name.

Efekt:
KaÅ¼dy zombie ma swoje wÅ‚asne imiÄ™ od razu po utworzeniu.
Nie musisz robiÄ‡ dodatkowych funkcji do ustawiania imienia.

Po co jest destruktor?

Destruktor to funkcja, ktÃ³ra wywoÅ‚uje siÄ™ automatycznie, gdy obiekt znika:
Stack â†’ po wyjÅ›ciu z funkcji, w ktÃ³rej zostaÅ‚ utworzony.
Heap â†’ gdy wywoÅ‚asz delete na wskaÅºniku do obiektu.
Tutaj destruktor wypisuje komunikat, Å¼e zombie zostaÅ‚ zniszczony.
Efekt praktyczny:
MoÅ¼esz Å‚atwo debugowaÄ‡, kiedy pamiÄ™Ä‡ jest zwalniana.
WidaÄ‡ rÃ³Å¼nicÄ™ miÄ™dzy zombie na heap (musisz wywoÅ‚aÄ‡ delete) a stack (niszczy siÄ™ automatycznie).

1ï¸âƒ£ Konstruktor
Zombie::Zombie(std::string name)
{
    this->name = name;
}

Funkcja wywoÅ‚ywana automatycznie, gdy tworzysz obiekt Zombie.
Przypisuje podane imiÄ™ (name) do atrybutu obiektu this->name.
DziÄ™ki temu kaÅ¼dy zombie ma swoje wÅ‚asne imiÄ™ od razu po utworzeniu.
PrzykÅ‚ad dziaÅ‚ania:
Zombie z("Foo");  // konstruktor nada imiÄ™ "Foo"

~Zombie()
Znak tylda ~ przed nazwÄ… funkcji w C++ oznacza destruktor.
Destruktor to specjalna funkcja klasy, ktÃ³ra wywoÅ‚ywana jest automatycznie, gdy obiekt przestaje istnieÄ‡.
2ï¸âƒ£ Destruktor
Zombie::~Zombie()
{
    std::cout << "Destructor zombie: " << this->name << std::endl;
}

Funkcja wywoÅ‚ywana automatycznie, gdy obiekt znika:
Stack: po wyjÅ›ciu z funkcji/bloku, w ktÃ³rym zostaÅ‚ stworzony.
Heap: po wywoÅ‚aniu delete na wskaÅºniku do obiektu.
Wypisuje komunikat debugowy, Å¼e obiekt zostaÅ‚ zniszczony i pokazuje jego imiÄ™.
PrzykÅ‚ad dziaÅ‚ania:
Zombie* z = newZombie("Bar");
delete z;  // zobaczysz "Destructor zombie: Bar
