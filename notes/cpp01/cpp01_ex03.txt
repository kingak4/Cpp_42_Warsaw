1ï¸âƒ£ O czym jest to zadanie
Zadanie â€Unnecessary violenceâ€ to Ä‡wiczenie w C++ dotyczÄ…ce kompozycji obiektÃ³w, referencji i wskaÅºnikÃ³w.
Tworzysz klasÄ™ Weapon, ktÃ³ra reprezentuje broÅ„ (jej typ).
Tworzysz dwie klasy HumanA i HumanB, ktÃ³re uÅ¼ywajÄ… Weapon i majÄ… imiÄ™.
Obie klasy majÄ… metodÄ™ attack(), ktÃ³ra wypisuje, czym atakujÄ….
RÃ³Å¼nica miÄ™dzy HumanA i HumanB:
HumanA: zawsze uzbrojony, broÅ„ przekazywana przez referencjÄ™ w konstruktorze.
HumanB: broÅ„ moÅ¼e nie istnieÄ‡ od razu, wiÄ™c moÅ¼e mieÄ‡ wskaÅºnik do broni, ktÃ³ry moÅ¼na ustawiÄ‡ pÃ³Åºniej.
Zadanie sprawdza TwojÄ… zdolnoÅ›Ä‡ do projektowania klas z powiÄ…zanymi obiektami, czyli jak obiekty â€trzymajÄ… siÄ™ nawzajemâ€.

2ï¸âƒ£ Czego ma CiÄ™ nauczyÄ‡
RÃ³Å¼nica miÄ™dzy wskaÅºnikami a referencjami w C++:
Kiedy uÅ¼ywaÄ‡ referencji â†’ zawsze istnieje obiekt, ktÃ³ry chcesz â€wiÄ…zaÄ‡â€ od razu (HumanA).
Kiedy uÅ¼ywaÄ‡ wskaÅºnika â†’ obiekt moÅ¼e byÄ‡ opcjonalny lub dynamiczny (HumanB).
Getter i setter w klasie (getType() i setType() w Weapon):
Ä†wiczenie pracy z kontrolowanym dostÄ™pem do prywatnych atrybutÃ³w.
Kompozycja obiektÃ³w:
HumanA i HumanB majÄ… Weapon â†’ jak klasy mogÄ… zawieraÄ‡ inne klasy.
Obserwacja zmian w obiekcie Weapon:
JeÅ›li zmienisz type w broni, wszystkie obiekty, ktÃ³re majÄ… do niej referencjÄ™/wskaÅºnik, od razu widzÄ… tÄ™ zmianÄ™.
BezpieczeÅ„stwo pamiÄ™ci:
ChociaÅ¼ tu nie ma new/delete koniecznie, musisz rozumieÄ‡, kiedy uÅ¼ycie wskaÅºnika wymaga zarzÄ…dzania pamiÄ™ciÄ…, a kiedy referencji nie.
Tworzenia getterÃ³w i setterÃ³w w klasach.
RÃ³Å¼nicy miÄ™dzy referencjÄ… a wskaÅºnikiem i kiedy co stosowaÄ‡.
Kompozycji klas â€“ jak jedna klasa moÅ¼e â€posiadaÄ‡â€ obiekt innej klasy.
Obserwacji efektÃ³w zmian w obiekcie wspÃ³Å‚dzielonym.
Planowania i organizacji pliku nagÅ‚Ã³wkowego i ÅºrÃ³dÅ‚owego w projekcie C++.

ğŸ”¹ Po co jest getter?

WyobraÅº sobie, Å¼e w klasie Weapon masz atrybut type.
On jest prywatny (private), czyli nikt spoza klasy nie moÅ¼e go zmieniaÄ‡ ani odczytywaÄ‡ bezpoÅ›rednio.
To jest zasada enkapsulacji â€“ dane sÄ… ukryte, dostÄ™p kontrolujesz tylko przez metody.
ğŸ‘‰ Getter pozwala odczytaÄ‡ wartoÅ›Ä‡ prywatnego pola w bezpieczny sposÃ³b.

Getter = metoda do czytania prywatnych danych.
Setter = metoda do zmiany prywatnych danych.

Weapon
Weapon::Weapon(std::string type) : type(type) {}
Weapon::Weapon â†’ konstruktor klasy Weapon.
(std::string type) â†’ przyjmuje stringa jako argument (np. "crude spiked club").
: type(type) â†’ to lista inicjalizacyjna.
Pierwsze type = prywatny atrybut klasy.
Drugie type = parametr funkcji.
Efekt: prywatne pole klasy dostaje wartoÅ›Ä‡ przekazanÄ… przy tworzeniu obiektu.
{} â†’ ciaÅ‚o pustego konstruktora (nie musisz juÅ¼ robiÄ‡ this->type = type;, bo zrobiÅ‚a to lista inicjalizacyjna).
ğŸ‘‰ DziÄ™ki temu moÅ¼esz napisaÄ‡ w main:
Weapon club("crude spiked club");
i pole type od razu ma wartoÅ›Ä‡ "crude spiked club".

Weapon::~Weapon() {}
Destruktor klasy Weapon.
WywoÅ‚ywany automatycznie, gdy obiekt przestaje istnieÄ‡ (np. wychodzi poza scope).
Jest pusty, bo klasa Weapon nie uÅ¼ywa dynamicznej pamiÄ™ci (np. new).

std::string const & Weapon::getType() const
{
    return (this->type);
}
std::string const & â†’ getter zwraca staÅ‚Ä… referencjÄ™ do stringa.
Referencja = brak kopiowania (wydajnoÅ›Ä‡).
const = uÅ¼ytkownik nie moÅ¼e zmieniÄ‡ wartoÅ›ci przez ten getter.
Weapon::getType() â†’ definicja funkcji czÅ‚onkowskiej klasy Weapon.
Ostatnie const â†’ oznacza, Å¼e funkcja nie zmienia obiektu (czyli nie rusza pÃ³l klasy).
return this->type; â†’ zwraca aktualny typ broni (np. "crude spiked club").
ğŸ‘‰ DziÄ™ki temu w main moÅ¼esz zrobiÄ‡:
std::cout << club.getType() << std::endl;
i dostaniesz wartoÅ›Ä‡ pola type.

void Weapon::setType(std::string type)
{
    this->type = type;
}
void â†’ setter nic nie zwraca.
setType(std::string type) â†’ przyjmuje stringa, ktÃ³ry ma byÄ‡ nowym typem broni.
this->type = type; â†’ przypisanie:
this->type = pole klasy,
type = parametr funkcji.
Efekt:zmienia zawartoÅ›Ä‡ pola type na nowÄ… wartoÅ›Ä‡.

ğŸ‘‰ DziÄ™ki temu moÅ¼esz napisaÄ‡ w main:
club.setType("some other type of club");
std::cout << club.getType() << std::endl;
i zobaczyÄ‡, Å¼e broÅ„ zmieniÅ‚a swÃ³j typ.

ğŸ“Œ Podsumowanie pliku Weapon.cpp
Konstruktor â†’ pozwala stworzyÄ‡ broÅ„ od razu z typem.
Destruktor â†’ nie robi nic specjalnego (brak dynamicznej pamiÄ™ci), ale jest gotowy na przyszÅ‚oÅ›Ä‡.
Getter getType() â†’ pozwala bezpiecznie odczytaÄ‡ prywatne pole type.
Setter setType() â†’ pozwala zmieniÄ‡ prywatne pole type.

ğŸ‘‰ CaÅ‚a klasa Weapon uczy CiÄ™ enkapsulacji:
Pole type jest ukryte (private),
Do interakcji z nim uÅ¼ywasz metod (getType, setType).

1ï¸âƒ£ Konstruktor
HumanA::HumanA(std::string name, Weapon& weapon): name(name), weapon(weapon) {}
Tworzymy obiekt HumanA.
Konstruktor przyjmuje imiÄ™ i referencjÄ™ do istniejÄ…cego obiektu Weapon.
DziÄ™ki referencji (Weapon& weapon) HumanA nie kopiuje broni, tylko "patrzy" na tÄ™ samÄ… broÅ„, ktÃ³ra juÅ¼ istnieje.
To oznacza, Å¼e jeÅ›li zmienisz typ broni w obiekcie Weapon, HumanA od razu zobaczy zmianÄ™.

2ï¸âƒ£ Funkcja attack()
WywoÅ‚uje siÄ™ w momencie ataku HumanA.
Wypisuje:
name â†’ imiÄ™ czÅ‚owieka.
" attacks with their " â†’ tekst w stringu.
tualny typ broni, na ktÃ³rÄ… wskazuje referencja.

âœ… Podsumowanie
Konstruktor przyjmuje referencjÄ™ do broni, wiÄ™c HumanA zawsze jest uzbrojony.
attack() korzysta z tej referencji, Å¼eby pobraÄ‡ typ broni i wypisaÄ‡ komunikat.
JeÅ›li zmienisz typ broni w obiekcie Weapon, HumanA automatycznie uÅ¼yje nowego typu â€“ bo trzyma referencjÄ™, a nie kopiÄ™.

ğŸ”¹ HumanB â€“ co robisz w tym pliku
Konstruktor
Tworzysz czÅ‚owieka z imieniem.
Ustawiasz wskaÅºnik weapon na nullptr, bo na poczÄ…tku nie ma broni.
DziÄ™ki temu w funkcji attack() moÅ¼esz bezpiecznie sprawdziÄ‡, czy broÅ„ jest przypisana.

Setter (setWeapon)
Tu przypisujesz adres istniejÄ…cego obiektu Weapon do wskaÅºnika.
Teraz weapon juÅ¼ nie jest nullptr, tylko wskazuje na konkretnÄ… broÅ„.

Funkcja attack()JeÅ›li weapon != nullptr â†’ wypisuje atak.
JeÅ›li weapon == nullptr â†’ wypisuje informacjÄ™, Å¼e broni nie ma.
DziÄ™ki temu HumanB moÅ¼e byÄ‡ zarÃ³wno uzbrojony, jak i nieuzbrojon



Podsumowanie:
Weapon
Klasa przechowuje typ broni (std::string type).
Posiada:
Konstruktor do ustawienia poczÄ…tkowego typu broni,
Getter (getType) â€” pozwala odczytaÄ‡ typ broni,
Setter (setType) â€” pozwala zmieniÄ‡ typ broni w trakcie dziaÅ‚ania programu.

HumanA
Konstruktor przyjmuje referencjÄ™ do broni (Weapon&).
DziÄ™ki referencji HumanA zawsze ma broÅ„, ktÃ³rÄ… moÅ¼na bezpoÅ›rednio uÅ¼ywaÄ‡ w funkcji attack().
attack() wypisuje: <name> attacks with their <weapon type>.

HumanB
Konstruktor nie przyjmuje broni â€” moÅ¼e jej nie mieÄ‡.
Przechowuje wskaÅºnik (Weapon*) na broÅ„.
PoczÄ…tkowo wskaÅºnik jest ustawiony na NULL (brak broni).
setWeapon(Weapon& w) przypisuje wskaÅºnik do istniejÄ…cej broni.
attack() sprawdza, czy wskaÅºnik nie jest NULL:
JeÅ›li broÅ„ jest, wypisuje typ broni.
JeÅ›li broni nie ma, wypisuje komunikat np. â€has no weaponâ€.

RÃ³Å¼nice miÄ™dzy HumanA i HumanB
HumanA: referencja â†’ zawsze uzbrojony, nie moÅ¼na â€zdjÄ…Ä‡â€ broni.
HumanB: wskaÅºnik â†’ moÅ¼e nie mieÄ‡ broni, moÅ¼na przypisaÄ‡ lub zmieniÄ‡ broÅ„ w trakcie dziaÅ‚ania.

Cel edukacyjny
Zrozumienie rÃ³Å¼nicy miÄ™dzy referencjÄ… a wskaÅºnikiem w C++.
UmiejÄ™tnoÅ›Ä‡ uÅ¼ycia getterÃ³w i setterÃ³w do bezpiecznego odczytu i modyfikacji prywatnych atrybutÃ³w.
Zastosowanie zasad OOP: enkapsulacja, konstruktor, destruktor, bezpieczeÅ„stwo danych.