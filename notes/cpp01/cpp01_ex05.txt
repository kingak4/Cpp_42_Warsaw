2ï¸âƒ£ O czym jest zadanie

Chodzi o stworzenie klasy, w ktÃ³rej:
KaÅ¼dy poziom (DEBUG, INFO, WARNING, ERROR) ma swojÄ… funkcjÄ™.
Publiczna funkcja complain wywoÅ‚uje wÅ‚aÅ›ciwÄ… funkcjÄ™ dynamicznie za pomocÄ… wskaÅºnikÃ³w do funkcji czÅ‚onkowskich, a nie wielokrotnych if/else.
Zadanie jest typowe do Ä‡wiczenia wskaÅºnikÃ³w do funkcji czÅ‚onkowskich w C++ i uÅ¼ycia switch lub mapowania string â†’ funkcja.

Czego CiÄ™ to nauczy

WskaÅºnikÃ³w do funkcji czÅ‚onkowskich â€“ zaawansowany sposÃ³b dynamicznego wywoÅ‚ywania metod.
Mapowania stringÃ³w na funkcje â€“ praktyczne w projektach, gdzie decyzje zaleÅ¼Ä… od tekstu.
Switch, pÄ™tle i tablice wskaÅºnikÃ³w w C++.
Prywatnych i publicznych metod w klasie â€“ dobre Ä‡wiczenie struktury klas w C++.

compalin :
Tworzymy tablicÄ™ stringÃ³w, ktÃ³re reprezentujÄ… wszystkie poziomy narzekania Harlâ€™a.
DziÄ™ki temu moÅ¼emy dopasowaÄ‡ parametr level, ktÃ³ry podaje uÅ¼ytkownik
Zmienna pomocnicza do iterowania po tablicy levels.
i bÄ™dzie naszym indeksem, aby przejÅ›Ä‡ przez wszystkie poziomy.
pos przechowa indeks dopasowanego poziomu w tablicy.
WartoÅ›Ä‡ -1 oznacza, Å¼e jeszcze nic nie znaleziono.
DziÄ™ki temu moÅ¼emy potem sprawdziÄ‡, czy poziom istnieje
Tworzymy tablicÄ™ wskaÅºnikÃ³w do prywatnych funkcji czÅ‚onkowskich klasy Harl.
KaÅ¼dy wskaÅºnik w tablicy odpowiada poziomowi w levels:
DziÄ™ki temu moÅ¼emy dynamicznie wywoÅ‚aÄ‡ funkcjÄ™, bez uÅ¼ywania if/else.
Iterujemy po tablicy levels.
Sprawdzamy, czy level (parametr funkcji) pasuje do levels[i].
JeÅ›li tak, zapisujemy indeks w pos.
i++ zwiÄ™ksza indeks, aby sprawdziÄ‡ kolejny poziom.
W efekcie po pÄ™tli pos bÄ™dzie wskazywaÄ‡ pozycjÄ™ dopasowanego poziomu, albo pozostanie -1, jeÅ›li nie znaleziono dopasowania.
function[pos] â†’ wskaÅºnik do funkcji odpowiadajÄ…cej poziomowi.
(this->*function[pos])() â†’ wywoÅ‚anie tej funkcji na bieÅ¼Ä…cym obiekcie Harl (this).
Nawiasy sÄ… niezbÄ™dne, bo operator ->* ma niÅ¼szy priorytet niÅ¼ ().

Co robi caÅ‚a funkcja w skrÃ³cie
Ma tablicÄ™ wszystkich poziomÃ³w.
Ma tablicÄ™ wskaÅºnikÃ³w do funkcji odpowiadajÄ…cych poziomom.
Szuka indeksu poziomu przekazanego jako argument.
WywoÅ‚uje odpowiedniÄ… funkcjÄ™ czÅ‚onkowskÄ… na obiekcie Harl.

UkÅ‚ad bitÃ³w (dla float, 32 bity)
1 bit: znak
8 bitÃ³w: wykÅ‚adnik
23 bity: mantysa
s eeeeeeee mmmmmmmmmmmmmmmmmmmmmmm
Mantysa ma zawsze domyÅ›lne 1. z przodu â†’ dlatego zapisujemy tylko uÅ‚amki po przecinku.
DziÄ™ki temu oszczÄ™dzamy miejsce.

PrzesuniÄ™ty wykÅ‚adnik (bias)
W floatach (32 bity) wykÅ‚adnik jest zapisany z przesuniÄ™ciem 127.
czyli jeÅ›li w bitach masz 127, to znaczy, Å¼e wykÅ‚adnik = 0.
jeÅ›li masz 128, to wykÅ‚adnik = 1.
jeÅ›li masz 126, to wykÅ‚adnik = -1

rzypadki specjalne
Zero â†’ wszystkie bity = 0.
NieskoÅ„czonoÅ›Ä‡ (+inf, -inf) â†’ wszystkie bity wykÅ‚adnika = 1, mantysa = 0.
NaN (â€not a numberâ€) â†’ wszystkie bity wykÅ‚adnika = 1, mantysa â‰  0.

Epsilon
Najmniejsza liczba x, dla ktÃ³rej 1.0 + x > 1.0.
Pokazuje granicÄ™ precyzji.
Dla float â‰ˆ 1.19e-7, dla double â‰ˆ 2.22e-16.

6. Problemy programistyczne
RÃ³wnoÅ›Ä‡ floatÃ³w
== porÃ³wnuje bity, a nie â€wartoÅ›Ä‡ w przybliÅ¼eniuâ€.
Dlatego 0.1 + 0.2 == 0.3 moÅ¼e byÄ‡ faÅ‚szem.
Stosuje siÄ™ â€porÃ³wnanie z tolerancjÄ…â€ (fabs(a-b) < EPSILON).

PrzepeÅ‚nienie
Floaty zamiast â€zawijaÄ‡ siÄ™â€ jak inty â†’ przechodzÄ… w +inf lub -inf.
To wygodne, bo Å‚atwiej sprawdziÄ‡ bÅ‚Ä™dy.
Utrata precyzji (loss of significance)
JeÅ›li odejmujesz liczby bardzo do siebie podobne â†’ tracisz prawie wszystkie cyfry znaczÄ…ce.
JeÅ›li dodajesz bardzo duÅ¼Ä… liczbÄ™ i bardzo maÅ‚Ä… â†’ maÅ‚a moÅ¼e zostaÄ‡ caÅ‚kiem â€poÅ‚kniÄ™taâ€.

7. Dobre praktyki
UwaÅ¼aj na odejmowanie podobnych liczb â†’ moÅ¼e zniszczyÄ‡ wynik.
Dodawaj maÅ‚e liczby do siebie, a dopiero potem do duÅ¼ych.
JeÅ›li moÅ¼esz, korzystaj z liczb caÅ‚kowitych (np. trzymajÄ…c licznik i mianownik zamiast uÅ‚amka).
W powaÅ¼nych projektach trzeba znaÄ‡ techniki stabilnoÅ›ci numerycznej, a nie â€ufaÄ‡ floatowi na Å›lepoâ€.

âœ… Podsumowanie 
Floaty (IEEE-754) to liczby zapisane jako znak + wykÅ‚adnik + mantysa.
Zawsze jest domyÅ›lne 1. w mantysie (oprÃ³cz zer i wyjÄ…tkÃ³w).
WykÅ‚adnik ma przesuniÄ™cie (dla float bias = 127).
SÄ… specjalne przypadki: 0, +/-inf, NaN.
NajwiÄ™kszy problem: brak dokÅ‚adnoÅ›ci â†’ trzeba uwaÅ¼aÄ‡ przy porÃ³wnaniach i obliczeniach.
RozwiÄ…zanie: uÅ¼ywaÄ‡ tolerancji (EPSILON) i przemyÅ›lanego ukÅ‚adu obliczeÅ„.
Czasm zamiast floatÃ³w lepiej trzymaÄ‡ dane w intach (np. fixed-point).

ğŸ‘‰ To wszystko sprowadza siÄ™ do jednej myÅ›li:
Floaty sÄ… szybkie i wygodne, ale nie zawsze dokÅ‚adne â€“ musisz je traktowaÄ‡ jak przybliÅ¼enia, a nie absolutnÄ… prawdÄ™.

ğŸ¯ Cel zadania
Masz stworzyÄ‡ klasÄ™ w C++, ktÃ³ra:
reprezentuje liczbÄ™ fixed-point (staÅ‚oprzecinkowÄ…, z 8 bitami czÄ™Å›ci uÅ‚amkowej),
jest napisana w Orthodox Canonical Form (OCF) â€“ czyli zawiera wszystkie podstawowe metody: konstruktor domyÅ›lny, konstruktor kopiujÄ…cy, operator przypisania, destruktor,
posiada gettery i settery do surowej wartoÅ›ci.
ğŸ‘‰ Celem tego Ä‡wiczenia jest nauka zasad tworzenia poprawnej klasy w C++ (RCF â€“ Orthodox Canonical Form), a nie jeszcze matematyka fixed-point.

OCF â€“ Orthodox Canonical Form
konstruktor domyÅ›lny,
konstruktor kopiujÄ…cy,
operator przypisania,
destruktor.
To jest tzw. rule of three â€“ bo te 3 (copy ctor, operator=, destructor) muszÄ… byÄ‡ spÃ³jne, Å¼eby uniknÄ…Ä‡ bÅ‚Ä™dÃ³w w zarzÄ…dzaniu pamiÄ™ciÄ…. Konstruktor domyÅ›lny jest tu formalnym dodatkiem.
To jest standardowy zestaw metod, ktÃ³re powinny byÄ‡ w klasie, Å¼eby byÅ‚a poprawna i kompletna.
Nazywa siÄ™ to teÅ¼ rule of three.
Cztery elementy:
Konstruktor domyÅ›lny
â†’ np. Fixed(), ustawia poczÄ…tkowe wartoÅ›ci.
Konstruktor kopiujÄ…cy
â†’ wywoÅ‚ywany przy tworzeniu obiektu na podstawie innego:
Fixed b(a);   // tutaj dziaÅ‚a copy constructor
Operator przypisania
â†’ uÅ¼ywany, gdy obiekt istnieje i dostaje nowÄ… wartoÅ›Ä‡:
c = b;        // tutaj dziaÅ‚a operator=
Destruktor
â†’ wywoÅ‚ywany automatycznie przy niszczeniu obiektu.
W Twoim zadaniu np. tylko wypisuje komunikat, ale w prawdziwych projektach zwalnia pamiÄ™Ä‡, zamyka pliki itp.
ğŸ“Œ Dlaczego to waÅ¼ne?

JeÅ›li masz klasÄ™, ktÃ³ra zarzÄ…dza zasobami (np. wskaÅºnikami, pamiÄ™ciÄ…, plikami), to musisz zadbaÄ‡, Å¼eby kopie i przypisania nie powodowaÅ‚y bÅ‚Ä™dÃ³w.
Dlatego OCF daje spÃ³jny zestaw:
tworzysz â†’ konstruktor,
kopiujesz â†’ copy constructor,
przypisujesz â†’ operator=,
niszczysz â†’ destruktor.