ğŸ“Œ 4. Kluczowe wyjaÅ›nienia
ğŸ”¹ Stos (stack)
Obiekty tworzone zwyczajnie, np. Zombie z("Foo");
IstniejÄ… tylko w obrÄ™bie bloku, w ktÃ³rym zostaÅ‚y utworzone.
Automatyczne niszczenie â€“ gdy blok siÄ™ koÅ„czy, destruktor woÅ‚a siÄ™ sam.
Proste i bezpieczne, ale ograniczone czasem Å¼ycia zmiennej.

ğŸ”¹ Sterta (heap)
Obiekty tworzone przez new, np. Zombie* z = new Zombie("Foo");
IstniejÄ… dopÃ³ki Ty je nie usuniesz (delete z;).
RÄ™czne zarzÄ…dzanie pamiÄ™ciÄ… â€“ jeÅ›li zapomnisz, powstaje memory leak.
Potrzebne, gdy chcesz Å¼eby obiekt Å¼yÅ‚ dÅ‚uÅ¼ej niÅ¼ zakres funkcji, w ktÃ³rej zostaÅ‚ utworzony.

Konstruktor w C++ â€” co to jest i po co go uÅ¼ywamy (prosto):
Konstruktor to specjalna funkcja klasy, ktÃ³ra jest automatycznie wywoÅ‚ywana w chwili tworzenia obiektu. SÅ‚uÅ¼y do inicjalizacji obiektu â€” czyli ustawienia jego pÃ³l (zmiennych) i wykonania wszystkich czynnoÅ›ci potrzebnych, Å¼eby obiekt byÅ‚ gotowy do uÅ¼ycia.
NajwaÅ¼niejsze fakty (krÃ³tko)
Ma takÄ… samÄ… nazwÄ™ jak klasa.
Nie ma typu zwracanego (nie piszesz void, int itp.).
WywoÅ‚uje siÄ™ automatycznie â€” nie woÅ‚asz go rÄ™cznie.
MoÅ¼esz mieÄ‡ kilka konstruktorÃ³w (przeciÄ…Å¼enie): np. bez parametrÃ³w (domyÅ›lny) i z parametrami.
UÅ¼ywaj go, Å¼eby: ustawiÄ‡ wartoÅ›ci poczÄ…tkowe, otworzyÄ‡ plik, zaalokowaÄ‡ zasoby itp.
Konstruktor sÅ‚uÅ¼y do automatycznej inicjalizacji pÃ³l obiektu w momencie jego tworzenia.
DziÄ™ki temu nie ma sytuacji, Å¼e pola (np. prywatne zmienne) zostajÄ… niezainicjalizowane i zawierajÄ… â€Å›miecioweâ€ wartoÅ›ci.
To chroni program przed bÅ‚Ä™dami w dziaÅ‚aniu (np. nieprzewidywalne wyniki, crashe).
Konstruktor dodatkowo moÅ¼e przygotowaÄ‡ obiekt nie tylko pod kÄ…tem liczb, ale teÅ¼ zasobÃ³w (np. otwarcie pliku, stworzenie poÅ‚Ä…czenia, zaalokowanie pamiÄ™ci).
Konstruktor to specjalna funkcja, ktÃ³ra jest automatycznie wywoÅ‚ywana w momencie tworzenia obiektu.
Nie tylko â€przypisujeâ€, ale teÅ¼ moÅ¼e wykonaÄ‡ dowolnÄ… logikÄ™ inicjalizacyjnÄ…, np. otwarcie pliku, sprawdzenie poprawnoÅ›ci wartoÅ›ci, przygotowanie zasobÃ³w.
âœ… Czyli: konstruktor = bezpieczny start obiektu.

1) W skrÃ³cie â€” co robi new
new w C++ alokuje pamiÄ™Ä‡ i wywoÅ‚uje konstruktor dla obiektu.
delete wywoÅ‚uje destruktor i zwalnia pamiÄ™Ä‡.
DomyÅ›lnie, jeÅ›li alokacja siÄ™ nie powiedzie, new rzuca wyjÄ…tek std::bad_alloc (moÅ¼na teÅ¼ uÅ¼yÄ‡ wersji std::nothrow, ktÃ³ra zwrÃ³ci nullptr).

2) A malloc?
malloc (C) tylko rezerwuje surowe bajty pamiÄ™ci.
Nie wywoÅ‚uje Å¼adnych konstruktorÃ³w.
Zwraca void* (w C++ trzeba rzutowaÄ‡).
JeÅ›li alokacja siÄ™ nie powiedzie, malloc zwraca NULL (nie rzuca wyjÄ…tku).

3) NajwaÅ¼niejsze rÃ³Å¼nice (prosto)
Konstruktor: new â†’ konstruktor jest wywoÅ‚any. malloc â†’ NIE.
Destruktor: delete â†’ destruktor jest wywoÅ‚any. free â†’ NIE.
Zwracana wartoÅ›Ä‡: new zwraca wskaÅºnik juÅ¼ odpowiedniego typu; malloc zwraca void*.
BÅ‚Ä™dy alokacji: new â†’ wyjÄ…tek (bad_alloc), malloc â†’ NULL.
Nie mieszaÄ‡: nigdy nie rÃ³wnaj malloc z delete ani new z free

âš ï¸ Co warto doprecyzowaÄ‡:

new wywoÅ‚uje konstruktor dla obiektu â€” to jest kluczowa rÃ³Å¼nica wzglÄ™dem malloc.
delete wywoÅ‚uje destruktor i zwalnia pamiÄ™Ä‡, a free tego nie robi.
malloc nie rzuca wyjÄ…tku przy bÅ‚Ä™dzie, zwraca NULL; new rzuca wyjÄ…tek std::bad_alloc.

ğŸ’¡ Podsumowanie :
Konstruktor = automatyczna inicjalizacja + moÅ¼liwoÅ›Ä‡ logiki w momencie tworzenia obiektu.
Prywatne = chroni dane; publiczne = bezpieczny interfejs i kontrola nad tym, co uÅ¼ytkownik moÅ¼e zrobiÄ‡.
new/delete = pamiÄ™Ä‡ + konstruktor/destruktor; malloc/free = tylko pamiÄ™Ä‡ (brak konstrukcji i destrukcji).

ğŸ” Co dokÅ‚adnie masz zrobiÄ‡
1. StworzyÄ‡ klasÄ™ Zombie

KaÅ¼dy zombie ma imiÄ™ (std::string name).

KaÅ¼dy zombie umie siÄ™ przedstawiÄ‡ â€“ metodÄ… announce(), np.:

Foo: BraiiiiiiinnnzzzZ...

Gdy zombie â€umieraâ€ (czyli wywoÅ‚a siÄ™ destruktor), musi wypisaÄ‡ komunikat debugowy, np.:

Zombie Foo destroyed

ğŸ‘‰ DziÄ™ki temu bÄ™dziesz wiedzieÄ‡, kiedy zombie powstaje i kiedy zostaje zniszczony.

2. StworzyÄ‡ funkcjÄ™ newZombie(std::string name)

Ta funkcja:
Tworzy nowego zombie na stercie (heap) za pomocÄ… new.
Nadaje mu imiÄ™ (name).
Zwraca wskaÅºnik (Zombie*) do tego zombie.
ğŸ‘‰ Po co?
Bo zombie utworzony w ten sposÃ³b bÄ™dzie Å¼yÅ‚ dalej, nawet po zakoÅ„czeniu funkcji, dopÃ³ki go nie usuniesz (delete).

3. StworzyÄ‡ funkcjÄ™ randomChump(std::string name)

Ta funkcja:
Tworzy zombie na stosie (stack) â€“ czyli zwykÅ‚y obiekt lokalny:
Zombie z(name);
WywoÅ‚uje na nim announce().
Po zakoÅ„czeniu funkcji zombie automatycznie siÄ™ zniszczy (bo byÅ‚ na stosie).
ğŸ‘‰ Po co?
Å»eby pokazaÄ‡ drugi sposÃ³b Å¼ycia obiektu: krÃ³tko, tylko w trakcie dziaÅ‚ania funkcji.

4. TestowaÄ‡ w main.cpp
Masz wywoÅ‚aÄ‡ oba sposoby i zobaczyÄ‡ rÃ³Å¼nicÄ™.
PrzykÅ‚ad:

int main() {
    Zombie* z1 = newZombie("HeapZombie"); // tworzenie na heap
    z1->announce();                       // zombie mÃ³wi
    delete z1;                            // rÄ™czne zabicie zombie

    randomChump("StackZombie");           // tworzenie na stack
    // zombie mÃ³wi i sam siÄ™ niszczy
}

ğŸ¯ Po co to zadanie?
Å»ebyÅ› nauczyÅ‚ siÄ™ pisaÄ‡ klasy (atrybuty, metody, konstruktor, destruktor).
Å»ebyÅ› zrozumiaÅ‚ rÃ³Å¼nicÄ™ miÄ™dzy heap a stack w praktyce.
Å»ebyÅ› nauczyÅ‚ siÄ™ pilnowaÄ‡ pamiÄ™ci (delete dla obiektÃ³w z new).
âœ… Plan â€“ krok po kroku

Zombie.hpp â€“ napisz klasÄ™ (atrybut name, konstruktor, destruktor, announce()).
Zombie.cpp â€“ zaimplementuj metody (announce() i destruktor).
newZombie.cpp â€“ funkcja Zombie* newZombie(std::string name).
randomChump.cpp â€“ funkcja void randomChump(std::string name).
main.cpp â€“ testy obu funkcji.

Uruchom program i obserwuj kolejnoÅ›Ä‡ komunikatÃ³w

Jak dziaÅ‚a new w C++?
new sÅ‚uÅ¼y do dynamicznej alokacji pamiÄ™ci na stercie (heap).
Kiedy tworzysz obiekt normalnie, np. Zombie z("Foo");, to taki obiekt istnieje tylko w aktualnym bloku (na stosie) i znika, gdy program wyjdzie z funkcji.
Kiedy uÅ¼ywasz new, tworzysz obiekt, ktÃ³ry pozostaje w pamiÄ™ci aÅ¼ do momentu, gdy rÄ™cznie go usuniesz (delete).
ğŸ”¹ Jak uÅ¼ywa siÄ™ new krok po kroku:
Piszesz new i nazwÄ™ klasy, np. Zombie.
JeÅ›li klasa ma konstruktor, moÅ¼esz od razu podaÄ‡ argumenty, np. new Zombie("Foo").
To utworzy obiekt klasy Zombie na heap.
new zawsze zwraca wskaÅºnik do tego nowego obiektu.
Dlatego wynik przypisujesz do zmiennej wskaÅºnikowej, np. Zombie*.
Taki wskaÅºnik moÅ¼esz potem uÅ¼ywaÄ‡ do wywoÅ‚ywania metod (->).

ğŸ”¹ PamiÄ™Ä‡ w programie C++ dzieli siÄ™ m.in. na:

Stos (stack)
To pamiÄ™Ä‡ automatyczna.
KaÅ¼da funkcja dostaje swÃ³j kawaÅ‚ek stosu na zmienne lokalne.
Gdy funkcja siÄ™ koÅ„czy â†’ wszystko ze stosu znika.
PrzykÅ‚ad:

void foo() {
    Zombie z("Foo");  // ten zombie istnieje tylko w tej funkcji
} // koniec funkcji â†’ z zostaje automatycznie zniszczony

Sterta (heap)
To pamiÄ™Ä‡ dynamiczna.
Program sam decyduje, kiedy coÅ› stworzyÄ‡ i kiedy to usunÄ…Ä‡.
Obiekt tworzysz za pomocÄ… new i musisz sam go usunÄ…Ä‡ za pomocÄ… delete.

PrzykÅ‚ad:

Zombie* z = new Zombie("Foo"); // zombie Å¼yje, dopÃ³ki nie zrobisz delete
delete z;                      // teraz pamiÄ™Ä‡ jest zwolniona

ğŸ”¹ RÃ³Å¼nica miÄ™dzy malloc (z C) a new (z C++)
malloc (C):
Rezerwuje kawaÅ‚ek surowej pamiÄ™ci (np. 32 bajty).
Nie wywoÅ‚uje konstruktora obiektu.
Trzeba rzutowaÄ‡ wskaÅºnik i samodzielnie zarzÄ…dzaÄ‡ pamiÄ™ciÄ….
Zwolnienie pamiÄ™ci robisz przez free().
PrzykÅ‚ad w C:

int* ptr = (int*)malloc(sizeof(int) * 10);
free(ptr);

new (C++):

Tworzy obiekt i od razu wywoÅ‚uje konstruktor.
Zwraca wskaÅºnik wÅ‚aÅ›ciwego typu (nie trzeba rzutowaÄ‡).
Zwolnienie pamiÄ™ci robisz przez delete (dla tablicy: delete[]).
PrzykÅ‚ad w C++:
Zombie* z = new Zombie("Foo"); // konstruktor zostaje wywoÅ‚any
delete z; // wywoÅ‚ywany jest teÅ¼ destruktor

ğŸ”¹ Dlaczego w C++ wolimy new zamiast malloc?
Bo new jest bardziej bezpieczne i â€inteligentneâ€: wie, jak wywoÅ‚aÄ‡ konstruktor i destruktor klasy.
malloc nie zna siÄ™ na obiektach â€“ dziaÅ‚a tylko jak â€zamÃ³w kawaÅ‚ek pamiÄ™ci w bajtachâ€.

ğŸ‘‰ Podsumowanie w jednym zdaniu:

Stack = pamiÄ™Ä‡ automatyczna (obiekt znika sam, gdy koÅ„czy siÄ™ funkcja).
Heap = pamiÄ™Ä‡ dynamiczna (musisz sam uÅ¼yÄ‡ delete).
malloc = â€suroweâ€ rezerwowanie pamiÄ™ci (C).
new = nowoczesny sposÃ³b w C++ do tworzenia obiektÃ³w na heap, wywoÅ‚uje konstruktor i daje Ci gotowy obiekt.

newZombie
ğŸ”¹ Co robi ta funkcja w praktyce

Przyjmuje imiÄ™ zombie jako parametr.
Tworzy nowy obiekt Zombie na heap z tym imieniem.
Zwraca wskaÅºnik do tego zombie, Å¼eby moÅ¼na byÅ‚o go uÅ¼ywaÄ‡ poza funkcjÄ….
Dlaczego uÅ¼ywamy new?
Bo chcemy, Å¼eby zombie nie znikaÅ‚ od razu po wyjÅ›ciu z funkcji.
JeÅ¼eli stworzymy zombie na stacku (lokalnie), np. Zombie z(name);, to zniknie po zakoÅ„czeniu funkcji i nie moÅ¼emy go uÅ¼yÄ‡ w main()

ğŸ”¹ Konstruktor Zombie::Zombie(std::string name)
Zombie::Zombie(std::string name) : name(name) {}
Po co jest konstruktor?
Konstruktor to specjalna funkcja klasy, ktÃ³ra wywoÅ‚ywana jest automatycznie, gdy tworzysz obiekt.

Tutaj:
przyjmuje parametr name â€“ imiÄ™ zombie, ktÃ³re chcesz nadaÄ‡.
przypisuje je do atrybutu obiektu name.

Efekt:
KaÅ¼dy zombie ma swoje wÅ‚asne imiÄ™ od razu po utworzeniu.
Nie musisz robiÄ‡ dodatkowych funkcji do ustawiania imienia.

Po co jest destruktor?

Destruktor to funkcja, ktÃ³ra wywoÅ‚uje siÄ™ automatycznie, gdy obiekt znika:
Stack â†’ po wyjÅ›ciu z funkcji, w ktÃ³rej zostaÅ‚ utworzony.
Heap â†’ gdy wywoÅ‚asz delete na wskaÅºniku do obiektu.
Tutaj destruktor wypisuje komunikat, Å¼e zombie zostaÅ‚ zniszczony.
Efekt praktyczny:
MoÅ¼esz Å‚atwo debugowaÄ‡, kiedy pamiÄ™Ä‡ jest zwalniana.
WidaÄ‡ rÃ³Å¼nicÄ™ miÄ™dzy zombie na heap (musisz wywoÅ‚aÄ‡ delete) a stack (niszczy siÄ™ automatycznie).

1ï¸âƒ£ Konstruktor
Zombie::Zombie(std::string name)
{
    this->name = name;
}

Funkcja wywoÅ‚ywana automatycznie, gdy tworzysz obiekt Zombie.
Przypisuje podane imiÄ™ (name) do atrybutu obiektu this->name.
DziÄ™ki temu kaÅ¼dy zombie ma swoje wÅ‚asne imiÄ™ od razu po utworzeniu.
PrzykÅ‚ad dziaÅ‚ania:
Zombie z("Foo");  // konstruktor nada imiÄ™ "Foo"

~Zombie()
Znak tylda ~ przed nazwÄ… funkcji w C++ oznacza destruktor.
Destruktor to specjalna funkcja klasy, ktÃ³ra wywoÅ‚ywana jest automatycznie, gdy obiekt przestaje istnieÄ‡.
2ï¸âƒ£ Destruktor
Zombie::~Zombie()
{
    std::cout << "Destructor zombie: " << this->name << std::endl;
}

Funkcja wywoÅ‚ywana automatycznie, gdy obiekt znika:
Stack: po wyjÅ›ciu z funkcji/bloku, w ktÃ³rym zostaÅ‚ stworzony.
Heap: po wywoÅ‚aniu delete na wskaÅºniku do obiektu.
Wypisuje komunikat debugowy, Å¼e obiekt zostaÅ‚ zniszczony i pokazuje jego imiÄ™.
PrzykÅ‚ad dziaÅ‚ania:
Zombie* z = newZombie("Bar");
delete z;  // zobaczysz "Destructor zombie: Bar

ğŸ”¹ PodobieÅ„stwa

ZarzÄ…dzanie pamiÄ™ciÄ…

malloc + free w C
konstruktor + destruktor w C++
Oba mechanizmy wiÄ…Å¼Ä… siÄ™ z tym, Å¼e tworzysz obiekt (alokacja) i sprzÄ…tasz po nim (dealokacja).

Para operacji
malloc zawsze musi mieÄ‡ w parze free.
Konstruktor zawsze wiÄ…Å¼e siÄ™ z destruktorem (choÄ‡ nie zawsze jawnie woÅ‚anym).
W obu przypadkach â€“ jeÅ¼eli zapomnisz o tej parze â€“ masz wyciek pamiÄ™ci.

ğŸ”¹ RÃ³Å¼nice

Poziom dziaÅ‚ania
malloc/free dziaÅ‚ajÄ… niskopoziomowo â€“ rezerwujÄ…/zwracajÄ… surowe bajty pamiÄ™ci.
Konstruktor/destruktor dziaÅ‚ajÄ… wysokopoziomowo â€“ oprÃ³cz samej pamiÄ™ci zajmujÄ… siÄ™ inicjalizacjÄ… i sprzÄ…taniem obiektu.
ğŸ‘‰ W C musisz sam zadbaÄ‡ o ustawienie pÃ³l struktury po malloc.
ğŸ‘‰ W C++ konstruktor zrobi to automatycznie.

ObsÅ‚uga logiki obiektu
malloc nie wywoÅ‚a Å¼adnej logiki inicjalizacyjnej â€“ dostajesz â€czysty kawaÅ‚ek RAMâ€.
Konstruktor ustawia zmienne w obiekcie, otwiera pliki, robi poÅ‚Ä…czenia sieciowe â€“ peÅ‚ne przygotowanie do uÅ¼ycia.

Podobnie destruktor:
free tylko oddaje pamiÄ™Ä‡.
Destruktor moÅ¼e zamknÄ…Ä‡ pliki, zwolniÄ‡ dodatkowe zasoby, wyrejestrowaÄ‡ coÅ› z systemu itd.

Integracja z jÄ™zykiem
W C â€“ malloc i free to funkcje biblioteczne.
W C++ â€“ konstruktor/destruktor to czÄ™Å›Ä‡ jÄ™zyka (automatycznie wywoÅ‚ywane przy tworzeniu i niszczeniu obiektu).

Dlatego w C++ moÅ¼esz uÅ¼ywaÄ‡ np. RAII (Resource Acquisition Is Initialization) â€“ obiekt sam zadba o zasoby, a Ty nie musisz pamiÄ™taÄ‡ o rÄ™cznym free.
Operator new/delete
new w C++ to tak naprawdÄ™ malloc + wywoÅ‚anie konstruktora.
delete to destruktor **+ free`.

MoÅ¼na wiÄ™c powiedzieÄ‡, Å¼e:
malloc <-> new (czÄ™Å›Ä‡ pamiÄ™ciowa)
free   <-> delete (czÄ™Å›Ä‡ pamiÄ™ciowa)
constructor <-> new (czÄ™Å›Ä‡ inicjalizacyjna)
destructor  <-> delete (czÄ™Å›Ä‡ sprzÄ…tajÄ…ca)

newZombie

Co tu siÄ™ dzieje krok po kroku
Zombie* tmp
Tworzysz wskaÅºnik do obiektu typu Zombie.
W C++ kiedy alokujesz obiekt na heapie (czyli dynamicznie), zawsze dostajesz wskaÅºnik do tej pamiÄ™ci.
Dlatego deklarujesz wskaÅºnik: Zombie* tmp;.
new Zombie(name)

new robi dwie rzeczy naraz:
Rezerwuje pamiÄ™Ä‡ na heapie dla obiektu Zombie.
WywoÅ‚uje konstruktor, ktÃ³ry ustawia name.
Wynikiem dziaÅ‚ania new jest adres nowego obiektu. Ten adres przypisujesz do wskaÅºnika tmp.
Przypisanie do tmp
WskaÅºnik tmp przechowuje adres obiektu, ktÃ³ry jest na heapie.
DziÄ™ki temu moÅ¼esz uÅ¼ywaÄ‡ tego obiektu poza funkcjÄ… (poza lokalnym zakresem zmiennych funkcji).
GdybyÅ› nie uÅ¼yÅ‚a wskaÅºnika i tylko zrobiÅ‚a np. Zombie z(name); â†’ obiekt powstaÅ‚by na stacku, i zniknÄ…Å‚by po wyjÅ›ciu z funkcji.
return tmp;
Zwracasz wskaÅºnik do wywoÅ‚ujÄ…cego kodu.
WywoÅ‚ujÄ…cy funkcjÄ™ musi pÃ³Åºniej wywoÅ‚aÄ‡ delete, Å¼eby zwolniÄ‡ pamiÄ™Ä‡ i wywoÅ‚aÄ‡ destruktor

Dlaczego dajemy to do tmp
To zwykÅ‚a zmienna wskaÅºnikowa, Å¼eby:
Å‚atwiej byÅ‚o operowaÄ‡ na obiekcie w obrÄ™bie funkcji,
a potem zwrÃ³ciÄ‡ wskaÅºnik.
MoÅ¼na teÅ¼ od razu zrobiÄ‡:
return new Zombie(name);
i nie uÅ¼ywaÄ‡ zmiennej tmp â€” efekt byÅ‚by taki sam.

âœ… Poprawna, robi dokÅ‚adnie to, czego oczekuje zadanie:
Tworzy zombie na heapie,
Ustawia jego imiÄ™ przez konstruktor,
Zwraca wskaÅºnik, Å¼eby moÅ¼na byÅ‚o go uÅ¼ywaÄ‡ poza funkcjÄ….

ğŸ”¹ randomChump
Tworzy zombie na stosie (stack).
Obiekt istnieje tylko w funkcji, w ktÃ³rej zostaÅ‚ stworzony.
Po wyjÅ›ciu z funkcji destruktor wywoÅ‚uje siÄ™ automatycznie.
Nie musisz nic robiÄ‡ rÄ™cznie.

ğŸ”¹ newZombie
Tworzy zombie na stercie (heap).
Obiekt Å¼yje poza funkcjÄ…, moÅ¼esz go uÅ¼ywaÄ‡ w wielu miejscach w programie.
Musisz rÄ™cznie zarzÄ…dzaÄ‡ pamiÄ™ciÄ…:
Konstruktor wywoÅ‚uje siÄ™ automatycznie przy new.
Destruktor nie wywoÅ‚a siÄ™ automatycznie â€“ musisz wywoÅ‚aÄ‡ delete, Å¼eby zwolniÄ‡ pamiÄ™Ä‡ i wywoÅ‚aÄ‡ destruktor.

ğŸ”‘ Wniosek

Stack â†’ wygodne, bezpieczne, ograniczone czasem Å¼ycia.
Heap â†’ elastyczne, pozwala na dÅ‚uÅ¼sze Å¼ycie obiektu, ale wymaga pamiÄ™tania o delete.
To Ä‡wiczenie ma CiÄ™ nauczyÄ‡ Å›wiadomego uÅ¼ywania obu sposobÃ³w i obserwowania destruktorÃ³w.