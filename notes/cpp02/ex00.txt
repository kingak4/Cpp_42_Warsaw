Chapter V â€“ Exercise 00: My First Class in Orthodox Canonical Form

Ä†wiczenie 00: Moja pierwsza klasa w kanonicznej formie ortodoksyjnej

Katalog do oddania: ex00/
Pliki do oddania: Makefile, main.cpp, Fixed.{h, hpp}, Fixed.cpp
Zabronione funkcje: brak
Do tej pory uÅ¼ywaÅ‚aÅ› gÅ‚Ã³wnie liczb caÅ‚kowitych i zmiennoprzecinkowych. Oba typy majÄ… przeciwstawne wÅ‚aÅ›ciwoÅ›ci. Teraz poznasz coÅ› nowego â€“ liczby staÅ‚oprzecinkowe (fixed-point numbers).
SÄ… one kompromisem miÄ™dzy wydajnoÅ›ciÄ…, dokÅ‚adnoÅ›ciÄ…, zakresem i precyzjÄ…. Dlatego sÄ… uÅ¼ywane np. w grafice komputerowej, obrÃ³bce dÅºwiÄ™ku czy naukach Å›cisÅ‚ych.
Twoim zadaniem jest stworzenie klasy w ortodoksyjnej formie kanonicznej (czyli z konstruktorem domyÅ›lnym, kopiujÄ…cym, operatorem przypisania i destruktorem).

Specyfikacja klasy:
Prywatne pola:
int przechowujÄ…cy wartoÅ›Ä‡ liczby staÅ‚oprzecinkowej
static const int przechowujÄ…cy liczbÄ™ bitÃ³w czÄ™Å›ci uÅ‚amkowej (zawsze 8)

Publiczne elementy:
konstruktor domyÅ›lny (ustawia wartoÅ›Ä‡ na 0)
konstruktor kopiujÄ…cy
operator przypisania
destruktor
int getRawBits(void) const; â†’ zwraca surowÄ… wartoÅ›Ä‡
void setRawBits(int const raw); â†’ ustawia surowÄ… wartoÅ›Ä‡
PrzykÅ‚adowy kod i output pokazujÄ…cy wywoÅ‚ania konstruktorÃ³w, operatorÃ³w i metod.

ğŸ¯ Czego siÄ™ nauczÄ™

Ortodox Canonical Form (OCF):
Konstruktor domyÅ›lny, kopiujÄ…cy, operator przypisania i destruktor â†’ fundamenty poprawnego zarzÄ…dzania obiektem w C++.
Liczby staÅ‚oprzecinkowe (Fixed-Point Numbers):
Czym sÄ… i jak rÃ³Å¼niÄ… siÄ™ od int i float.
Jak przechowywaÄ‡ liczby jako int i interpretowaÄ‡ je z przesuniÄ™ciem bitowym.

Konwersje typÃ³w:
Z int â†’ fixed
Z float â†’ fixed
Z fixed â†’ int i float
Operator overloading (przeciÄ…Å¼anie operatorÃ³w):
PorÃ³wnania, operatory arytmetyczne, inkrementacja/dekrementacja.
Operator << do wygodnego wypisywania.
Statyczne funkcje pomocnicze (min/max).

Podstawy
ZaimplementowaÄ‡ klasÄ™ Fixed w OCF: konstruktor, destruktor, copy, operator=
Metody getRawBits i setRawBits

ğŸ“š Lista zagadnieÅ„ do ogarniÄ™cia przed startem projektu Fixed
1. Ortodox Canonical Form (OCF)
Musisz wiedzieÄ‡:
czym sÄ… 4 podstawowe metody:
konstruktor domyÅ›lny,
konstruktor kopiujÄ…cy,
operator przypisania,
destruktor,
po co siÄ™ je implementuje,
jak wyglÄ…dajÄ… logi wywoÅ‚aÅ„ (czyli kiedy woÅ‚any jest copy constructor, a kiedy operator=).

2. Fixed-point numbers (liczby staÅ‚oprzecinkowe)
Musisz wiedzieÄ‡:
czym rÃ³Å¼ni siÄ™ fixed-point od float i int,
jak dziaÅ‚a przechowywanie wartoÅ›ci w postaci caÅ‚kowitej liczby + przesuniÄ™cia bitowego,
co oznacza liczba fractional bits = 8 â†’ najmniejszy krok to 1 / 2^8 = 1/256 = 0.00390625.

3. Konwersje miÄ™dzy typami
Musisz rozumieÄ‡:
jak zamieniÄ‡ int â†’ fixed (przesuniÄ™cie bitowe w lewo),
jak zamieniÄ‡ float â†’ fixed (mnoÅ¼enie przez 2^8 i zaokrÄ…glenie),
jak zamieniÄ‡ fixed â†’ int (dzielenie przez 2^8),
jak zamieniÄ‡ fixed â†’ float (dzielenie przez 2^8, ale wynik w float).

4. Operator overloading (przeciÄ…Å¼anie operatorÃ³w)
Musisz ogarnÄ…Ä‡:
jak wyglÄ…da skÅ‚adnia przeciÄ…Å¼ania operatorÃ³w w C++ (np. Fixed operator+(const Fixed& other) const;),
rÃ³Å¼nica miÄ™dzy operatorem preinkrementacji (++a) a postinkrementacji (a++),
przeciÄ…Å¼enie operatora << dla std::ostream&.

5. Static members i static functions
Musisz wiedzieÄ‡:
rÃ³Å¼nica miÄ™dzy zmiennÄ… statycznÄ… w klasie (static const int fractionalBits = 8;) a polem instancji,
jak dziaÅ‚ajÄ… funkcje statyczne (Fixed::min, Fixed::max) i czemu zwracajÄ… referencjÄ™.

6. Roundf i <cmath>
Musisz znaÄ‡:
funkcjÄ™ roundf(float) â†’ zaokrÄ…gla float do najbliÅ¼szej liczby caÅ‚kowitej,
kiedy jej uÅ¼yÄ‡ przy konwersji float â†’ fixed.

7. Podstawy debugowania i testÃ³w
Musisz pamiÄ™taÄ‡:
dodawanie std::cout w konstruktorach/destruktorach do Å›ledzenia wywoÅ‚aÅ„,
testowanie operatorÃ³w i konwersji na prostych przykÅ‚adach.

âœ… Lista pytaÅ„ kontrolnych (do â€samozgadankiâ€)
Co to jest kanoniczna forma ortodoksyjna klasy w C++ i jakie 4 funkcje wchodzÄ… w jej skÅ‚ad?
Dlaczego liczby staÅ‚oprzecinkowe sÄ… przydatne w grafice komputerowej i obrÃ³bce dÅºwiÄ™ku?
Ile wynosi najmniejsza jednostka rÃ³Å¼nicy (Ïµ) w klasie Fixed z 8 bitami uÅ‚amkowymi?
Jak zapiszesz w Fixed liczbÄ™ 5, gdy fractional bits = 8?
Jak wyglÄ…da konwersja float â†’ Fixed i odwrotnie?
Jak przeciÄ…Å¼yÄ‡ operator << dla klasy w C++?
Czym rÃ³Å¼ni siÄ™ ++a od a++ w kontekÅ›cie przeciÄ…Å¼ania operatorÃ³w?
Do czego sÅ‚uÅ¼y roundf i kiedy jÄ… uÅ¼ywasz w tym projekcie?
Czym rÃ³Å¼ni siÄ™ funkcja statyczna od zwykÅ‚ej metody w klasie?

Kiedy wywoÅ‚ywany jest:
konstruktor kopiujÄ…cy,
operator przypisania,
destruktor?

1. Liczby caÅ‚kowite (int)
SÄ… dokÅ‚adne â†’ jak masz 2, to jest to dokÅ‚adnie 2. Jak dodasz 1, to zawsze bÄ™dzie 3.
Brak precyzji â†’ nie potrafiÄ… przechowywaÄ‡ czÄ™Å›ci uÅ‚amkowej.
np. 5 / 2 = 2 (a nie 2.5).
MoÅ¼na je porÃ³wnaÄ‡ do cegieÅ‚ â€“ proste, twarde, dokÅ‚adne, ale nie da siÄ™ nimi oddaÄ‡ szczegÃ³Å‚owych ksztaÅ‚tÃ³w (np. kulki).

2. Liczby zmiennoprzecinkowe (float, double)
MajÄ… duÅ¼Ä… precyzjÄ™ â†’ pozwalajÄ… zapisaÄ‡ uÅ‚amki i liczby bardzo duÅ¼e/maÅ‚e.
Ale tracÄ… dokÅ‚adnoÅ›Ä‡ â†’ nie wszystko da siÄ™ zapisaÄ‡ dokÅ‚adnie.
np. 0.1 w systemie binarnym nie ma dokÅ‚adnej reprezentacji, komputer zapisze przybliÅ¼enie.
Dlatego dwa wyglÄ…dajÄ…ce â€tak samoâ€ floaty mogÄ… nie byÄ‡ rÃ³wne (== da false).
MoÅ¼na je porÃ³wnaÄ‡ do plasteliny â€“ moÅ¼na niÄ… uformowaÄ‡ krzywizny, szczegÃ³Å‚y, ale nigdy nie bÄ™dzie perfekcyjnie rÃ³wna (np. nie zrobisz idealnej kostki).

DokÅ‚adnoÅ›Ä‡ vs. precyzja
DokÅ‚adnoÅ›Ä‡ = jak blisko jesteÅ› do prawdziwej wartoÅ›ci.
Inty â†’ bardzo dokÅ‚adne (np. 2 to zawsze dokÅ‚adnie 2).
Floaty â†’ nie zawsze dokÅ‚adne (np. 0.1 moÅ¼e byÄ‡ zapisane jako 0.100000001).
Precyzja = ile szczegÃ³Å‚Ã³w moÅ¼esz przechowaÄ‡.
Inty â†’ maÅ‚o precyzyjne (brak uÅ‚amkÃ³w).
Floaty â†’ bardzo precyzyjne (uÅ‚amki, zakres), ale mogÄ… â€rozminÄ…Ä‡ siÄ™â€ z dokÅ‚adnym wynikiem

Problem z reprezentacjÄ… liczb
Nie kaÅ¼dy uÅ‚amek da siÄ™ zapisaÄ‡ dokÅ‚adnie w systemie binarnym.
PrzykÅ‚ad: 1/3 â†’ w dziesiÄ™tnym to 0.33333... (nieskoÅ„czone). W binarnym teÅ¼ nigdy siÄ™ nie koÅ„czy.
Komputer wiÄ™c zapisuje przybliÅ¼enie.
To przybliÅ¼enie prowadzi do bÅ‚Ä™dÃ³w np. w porÃ³wnaniach czy obliczeniach.

Podsumowanie
Inty (liczby caÅ‚kowite):
dokÅ‚adne, ale bez uÅ‚amkÃ³w â†’ cegÅ‚y.
Floaty (liczby zmiennoprzecinkowe):
mogÄ… zapisaÄ‡ uÅ‚amki i szeroki zakres liczb,
ale nie zawsze dokÅ‚adnie â†’ plastelina.

DokÅ‚adnoÅ›Ä‡ vs precyzja:
Int = dokÅ‚adne, maÅ‚o precyzyjne.
Float = precyzyjne, maÅ‚o dokÅ‚adne.

Przyczyna problemÃ³w z float:
komputer zapisuje liczby w systemie binarnym,
niektÃ³rych uÅ‚amkÃ³w nie da siÄ™ zapisaÄ‡ dokÅ‚adnie,
stÄ…d biorÄ… siÄ™ bÅ‚Ä™dy przy obliczeniach i porÃ³wnaniach.

sedno artykuÅ‚u:
Inty sÄ… dobre do dokÅ‚adnych operacji bez uÅ‚amkÃ³w.
Floaty sÄ… dobre do przybliÅ¼onych obliczeÅ„ z uÅ‚amkami.
Nie istnieje typ â€idealnyâ€ â†’ dlatego czasem uÅ¼ywa siÄ™ liczb staÅ‚oprzecinkowych (fixed-point), Å¼eby znaleÅºÄ‡ zÅ‚oty Å›rodek (i to wÅ‚aÅ›nie bÄ™dziesz robiÅ‚a w projekcie).

1. Standard IEEE-754
To zasada, jak komputery zapisujÄ… liczby zmiennoprzecinkowe (float, double).
NajczÄ™Å›ciej spotykany w praktyce.
Liczba zapisana jest w 3 czÄ™Å›ciach:
znak (s) â†’ czy liczba jest dodatnia/ujemna,
wykÅ‚adnik (e) â†’ â€rzÄ…d wielkoÅ›ciâ€, czyli jak bardzo przesuwamy przecinek,
mantysa (m) â†’ cyfry liczby.
ğŸ‘‰ OgÃ³lny wzÃ³r:
liczba = (znak ? -1 : 1) * 2^(wykÅ‚adnik) * 1.mantysa

1ï¸âƒ£ const Fixed &other â€“ co to jest?
Fixed â†’ typ obiektu, ktÃ³ry kopiujemy.
& â†’ referencja, czyli nie kopiujemy caÅ‚ego obiektu na wejÅ›ciu, tylko wskazujemy na istniejÄ…cy obiekt w pamiÄ™ci. To oszczÄ™dza czas i pamiÄ™Ä‡, bo nie tworzymy nowego tymczasowego obiektu.
const â†’ obiekt, z ktÃ³rego kopiujemy, nie moÅ¼e zostaÄ‡ zmieniony wewnÄ…trz konstruktora. Chcemy tylko odczytaÄ‡ jego dane, a nie zmieniaÄ‡ go.
Czyli const Fixed &other oznacza: â€weÅº istniejÄ…cy obiekt Fixed, nie kopiuj go, i nie zmieniaj goâ€.

2ï¸âƒ£ other â€“ co to jest?
other to nazwa parametru w funkcji (konstruktorze).
To jest ten obiekt, ktÃ³ry chcemy skopiowaÄ‡ do nowego obiektu, ktÃ³ry wÅ‚aÅ›nie tworzysz.
W przykÅ‚adzie:
Fixed a;       // obiekt a
Fixed b(a);    // b jest tworzony na podstawie a
other w tym wywoÅ‚aniu to a. Konstruktor widzi, Å¼e ma skopiowaÄ‡ dane z a do b.

3ï¸âƒ£ this->value = other.value; â€“ co siÄ™ dzieje?
this â†’ wskaÅºnik na nowo tworzony obiekt (b w naszym przykÅ‚adzie)
this->value â†’ pole value w nowym obiekcie
other.value â†’ pole value w obiekcie, z ktÃ³rego kopiujemy (a)
Efekt: kopiujemy liczbÄ™ przechowywanÄ… w value z obiektu other do nowego obiektu this.

4ï¸âƒ£ Podsumowanie w prostych sÅ‚owach
Fixed(const Fixed &other) â€“ konstruktor kopiujÄ…cy, uÅ¼ywany do tworzenia nowego obiektu na podstawie innego.
other â†’ obiekt, z ktÃ³rego kopiujemy.
const â†’ nie zmieniamy other.
& â†’ kopiujemy przez referencjÄ™, oszczÄ™dzamy pamiÄ™Ä‡.
this->value = other.value; â†’ kopiujemy faktycznÄ… wartoÅ›Ä‡ liczby.

other (stary obiekt)  ----->  this (nowy obiekt)
  _value                     _value = other._value


1ï¸âƒ£ Co to jest Fixed& i const Fixed &other?
Fixed& â€“ oznacza, Å¼e funkcja zwraca referencjÄ™ do obiektu, czyli coÅ› jak â€adres rzeczywistego obiektuâ€, nie kopiÄ™. DziÄ™ki temu moÅ¼emy pisaÄ‡ a = b = c; i wszystko dziaÅ‚a.
const Fixed &other â€“ to obiekt, ktÃ³ry chcemy skopiowaÄ‡ (czyli bierzemy wartoÅ›ci z niego). const oznacza: nie zmieniamy go, tylko odczytujemy.
other to po prostu nazwa tego obiektu. W Å¼yciu moÅ¼esz to sobie wyobraziÄ‡ tak:
Masz notes (this) i chcesz przepisaÄ‡ w nim zawartoÅ›Ä‡ innego notesu (other). Nie zmieniasz tego drugiego notesu, tylko przepisujesz jego zawartoÅ›Ä‡ do swojego.
2ï¸âƒ£ Dlaczego na poczÄ…tku robimy if (this == &other)?
To jest sprawdzenie, czy nie przypisujemy obiektu do samego siebie.
PrzykÅ‚ad z Å¼ycia:
Masz notes A.
Chcesz przepisaÄ‡ zawartoÅ›Ä‡ z notesu B do A â†’ ok.
Ale jeÅ›li prÃ³bujesz przepisaÄ‡ A do A? Nie musisz nic robiÄ‡, bo i tak wszystko juÅ¼ jest na miejscu.
this â€“ to TwÃ³j notes (this = ten obiekt, na ktÃ³rym wywoÅ‚ujesz operator).
&other â€“ adres notesu, ktÃ³ry kopiujesz.
PorÃ³wnujemy je, jeÅ›li sÄ… takie same â†’ zwracamy od razu (*this), nie robimy nic.

3ï¸âƒ£ Dlaczego robimy this->_value = other._value;?
To kopiowanie wartoÅ›ci z jednego obiektu do drugiego.
W Å¼yciu: przepisywanie zawartoÅ›ci notesu B do notesu A.

4ï¸âƒ£ Dlaczego zwracamy *this?
Funkcja operatora przypisania zawsze zwraca referencjÄ™ do obiektu, ktÃ³ry zostaÅ‚ zmieniony.
DziÄ™ki temu moÅ¼esz robiÄ‡ np.:
a = b = c;
Å»yciowo:
Notes A = B, B = C.
Po wykonaniu operacji moÅ¼esz dalej uÅ¼ywaÄ‡ A jako peÅ‚nego notesu, bo operator zwraca A.

ğŸ”¹ PodsumowujÄ…c w prostym przykÅ‚adzie Å¼ycia
other = notes B â†’ ÅºrÃ³dÅ‚o danych
this = notes A â†’ ten, ktÃ³ry chcemy zmieniÄ‡
JeÅ›li prÃ³bujesz przepisaÄ‡ A do A â†’ if (this == &other) â†’ nic nie robimy
W przeciwnym razie kopiujesz zawartoÅ›Ä‡: this->_value = other._value;
Zwracasz *this â†’ nasz notes (A) jest gotowy do dalszego uÅ¼ycia

Cel caÅ‚ej funkcji operator= w prostych sÅ‚owach:
Pozwala przypisaÄ‡ jeden obiekt do drugiego (skopiowaÄ‡ jego dane).
Sprawdza, czy nie przypisujesz obiektu do samego siebie (bo wtedy nic nie trzeba robiÄ‡).
Kopiuje wszystkie potrzebne wartoÅ›ci z obiektu ÅºrÃ³dÅ‚owego (other) do docelowego (this).
Zwraca referencjÄ™ do obiektu docelowego (*this), Å¼eby moÅ¼na byÅ‚o Å‚aÅ„cuchowaÄ‡ przypisania, np. a = b = c;.
W skrÃ³cie: umoÅ¼liwia bezpieczne i poprawne przypisywanie obiektÃ³w klasy Fixed.

1ï¸âƒ£ operator= â€“ kto kogo â€œwidziâ€
Kiedy piszesz a = b;, kompilator wywoÅ‚uje TwÃ³j operator przypisania:
this â†’ wskazuje na obiekt po lewej stronie (a).
other â†’ to obiekt po prawej stronie (b).
W skrÃ³cie: this = a, other = b.

2ï¸âƒ£ Sprawdzamy self-assignment
if (this == &other)
    return *this;
this == &other â†’ sprawdza, czy nie prÃ³bujesz przypisaÄ‡ obiektu do samego siebie, np. a = a;.
JeÅ›li tak â†’ nic nie robimy, bo kopiowanie siebie do siebie jest zbÄ™dne.
Bez tego w prostych klasach nic siÄ™ zÅ‚ego nie stanie, ale w bardziej skomplikowanych (dynamiczna pamiÄ™Ä‡) mogÅ‚oby to zniszczyÄ‡ dane.

3ï¸âƒ£ Kopiujemy wartoÅ›Ä‡
this->_value = other._value;
Teraz faktycznie kopiujemy dane z other do this.
Czyli a._value dostaje wartoÅ›Ä‡ z b._value.

4ï¸âƒ£ Zwracamy *this
return *this;
Zwracamy referencjÄ™ do obiektu po lewej stronie, czyli do a.
DziÄ™ki temu moÅ¼emy robiÄ‡ Å‚aÅ„cuchowanie przypisaÅ„, np.:
a = b = c;
Najpierw b = c zwraca b, potem a = (wynik b=c).

Podsumowanie na prostym przykÅ‚adzie â€œnotesowymâ€:
this â†’ obiekt po lewej stronie (= ten, ktÃ³ry dostaje wartoÅ›Ä‡).
other â†’ obiekt po prawej stronie (= ten, ktÃ³rego kopiujemy).
Sprawdzamy, czy nie przypisujemy do siebie.
Kopiujemy wartoÅ›Ä‡ _value.
Zwracamy *this, Å¼eby moÅ¼na byÅ‚o Å‚aÅ„cuchowaÄ‡ przypisania

1ï¸âƒ£ Co to jest getRawBits
To metoda klasy Fixed, ktÃ³ra pozwala odczytaÄ‡ wartoÅ›Ä‡ prywatnego pola _value.
value jest private, wiÄ™c nie moÅ¼emy jej odczytaÄ‡ z zewnÄ…trz bez takiej funkcji.
const na koÅ„cu oznacza, Å¼e metoda nie zmienia obiektu. Czyli moÅ¼na jÄ… wywoÅ‚aÄ‡ na kaÅ¼dym obiekcie Fixed i na pewno nie zmieni wartoÅ›ci.

2ï¸âƒ£ Po co to jest
Kiedy testujesz swÃ³j obiekt lub chcesz coÅ› zrobiÄ‡ z jego wartoÅ›ciÄ… (np. porÃ³wnaÄ‡ dwie liczby), potrzebujesz dostÄ™pu do _value.
Bez tej metody _value byÅ‚oby niedostÄ™pne poza klasÄ….

3ï¸âƒ£Jak to wyglÄ…da â€œÅ¼yciowoâ€
WyobraÅº sobie bankomat:
_value â†’ iloÅ›Ä‡ pieniÄ™dzy na koncie (private, nikt nie moÅ¼e jej od razu zmieniÄ‡).
getRawBits() â†’ wydrukuj stan konta, ale nie zmieniasz pieniÄ™dzy.
DziÄ™ki temu moÅ¼esz sprawdziÄ‡, ile jest pieniÄ™dzy, bez ryzyka, Å¼e ktoÅ› przypadkowo coÅ› zmieni.

Cel funkcji setRawBits:
Ma ustawiÄ‡ wartoÅ›Ä‡ prywatnego pola value na liczbÄ™ caÅ‚kowitÄ…, ktÃ³rÄ… jej przekaÅ¼esz (raw).
DziÄ™ki temu moÅ¼esz zmieniÄ‡ â€surowÄ…â€ wartoÅ›Ä‡ Twojego obiektu Fixed bezpoÅ›rednio z zewnÄ…trz, ale kontrolujÄ…c dostÄ™p przez metodÄ™ publicznÄ… (bo _value jest prywatne).