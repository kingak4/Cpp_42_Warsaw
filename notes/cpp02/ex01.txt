Ä†wiczenie 01: Bardziej uÅ¼yteczna klasa liczb staÅ‚oprzecinkowych

Katalog do oddania: ex01/
Pliki do oddania: Makefile, main.cpp, Fixed.{h, hpp}, Fixed.cpp
Dozwolone funkcje: roundf z <cmath>

Klasa z poprzedniego Ä‡wiczenia jest jeszcze bezuÅ¼yteczna (tylko wartoÅ›Ä‡ 0). Trzeba dodaÄ‡:
Nowe konstruktory i funkcje:
konstruktor z int (konwersja na liczbÄ™ staÅ‚oprzecinkowÄ…)
konstruktor z float (konwersja na liczbÄ™ staÅ‚oprzecinkowÄ…)
float toFloat(void) const; â†’ konwertuje na float
int toInt(void) const; â†’ konwertuje na int
przeciÄ…Å¼enie operatora << (wyÅ›wietlanie liczby jako float)
PrzykÅ‚ad pokazuje:
rÃ³Å¼ne wywoÅ‚ania konstruktorÃ³w
przypisania
konwersjÄ™ do float i int
operator <<

UÅ¼ytecznoÅ›Ä‡
DodaÄ‡ konstruktor z int i float
Metody toFloat() i toInt()
PrzeciÄ…Å¼enie <<

1ï¸âƒ£ Co to jest fixed-point?

W zwykÅ‚ym int 10 to po prostu dziesiÄ™Ä‡.
fixed-point mamy czÄ™Å›Ä‡ caÅ‚kowitÄ… i czÄ™Å›Ä‡ uÅ‚amkowÄ… w jednym int.
Bits = 8 oznacza, Å¼e 8 najmÅ‚odszych bitÃ³w jest czÄ™Å›ciÄ… uÅ‚amkowÄ….
Czyli: 10 w fixed-point to 10 << 8 = 2560.
Dlaczego przesuwamy bity?
Bo w int nie ma miejsca na przecinek, wiÄ™c "przesuwamy" liczbÄ™ caÅ‚kowitÄ… w lewo o liczbÄ™ bitÃ³w uÅ‚amkowych, Å¼eby pÃ³Åºniej moÅ¼na byÅ‚o dodawaÄ‡ czÄ™Å›Ä‡ uÅ‚amkowÄ….

2ï¸âƒ£ Co robi konstruktor z int?
Bierze liczbÄ™ caÅ‚kowitÄ… od uÅ¼ytkownika, np. 10.
Zapisuje jÄ… w _value w formacie fixed-point: 10 << _fractionalBits.
DziÄ™ki temu _value moÅ¼e pÃ³Åºniej wspÃ³Å‚pracowaÄ‡ z innymi konstruktorami i metodami (toFloat, toInt).

3ï¸âƒ£ Co robi konstruktor z float?
Bierze float np. 42.42.
Musi zamieniÄ‡ float na fixed-point, czyli _value = roundf(f * (1 << _fractionalBits)).
DziÄ™ki temu uÅ‚amkowa czÄ™Å›Ä‡ jest przechowywana w tych 8 bitach uÅ‚amkowych.

Co to jest fixed-point?
W normalnych liczbach caÅ‚kowitych (int) przechowujesz tylko liczby caÅ‚kowite: 1, 2, 3â€¦
W liczbach zmiennoprzecinkowych (float) masz czÄ™Å›Ä‡ caÅ‚kowitÄ… i uÅ‚amkowÄ…, np. 3.14.
Fixed-point to â€poÅ›redniâ€ format: zapisujesz liczbÄ™ caÅ‚kowitÄ…, ale czÄ™Å›Ä‡ uÅ‚amkowa jest zakodowana w bitach liczby caÅ‚kowitej.
Masz np. 8 bitÃ³w na czÄ™Å›Ä‡ uÅ‚amkowÄ…: liczba 1.5 w value bÄ™dzie zapisana jako 1.5 Ã— 2^8 = 384.

PrzykÅ‚ad:
ZaÅ‚Ã³Å¼my 8 bitÃ³w na czÄ™Å›Ä‡ uÅ‚amkowÄ…:
| Liczba | Fixed-point (\_value) = liczba Ã— 2^8 | Bity              |
| ------ | ------------------------------------ | ----------------- |
| 1      | 1 Ã— 256 = 256                        | 00000001 00000000 |
| 1.5    | 1.5 Ã— 256 = 384                      | 00000001 10000000 |
| 10     | 10 Ã— 256 = 2560                      | 00001010 00000000 |
DziÄ™ki temu moÅ¼esz wykonywaÄ‡ operacje caÅ‚kowite (+, -, *, >>, <<) i nadal obsÅ‚ugiwaÄ‡ liczby uÅ‚amkowe.
To jest szybciej niÅ¼ float i bardziej przewidywalnie niÅ¼ normalny float (mniej bÅ‚Ä™dÃ³w numerycznych).

Gdzie siÄ™ uÅ¼ywa?
Gry komputerowe i grafika: np. pozycje obiektÃ³w w pikselach.
Audio: prÃ³bki dÅºwiÄ™ku mogÄ… byÄ‡ w fixed-point.
Embedded / mikrokontrolery: sprzÄ™t moÅ¼e nie mieÄ‡ sprzÄ™towego float, wiÄ™c fixed-point jest szybszy i mniej pamiÄ™cioÅ¼erny.

fixed-point to taki sprytny sposÃ³b zapisywania liczb z uÅ‚amkiem, ale nie uÅ¼ywajÄ…c float, tylko caÅ‚kowitÄ… reprezentacjÄ™ plus ustalonÄ… liczbÄ™ bitÃ³w na czÄ™Å›Ä‡ po przecinku.
ğŸ‘‰ DziÄ™ki temu moÅ¼esz robiÄ‡ obliczenia na intach, a mimo to â€udawaÄ‡â€ liczby zmiennoprzecinkowe.
Czyli:
float â†’ zmienia siÄ™ dÅ‚ugoÅ›Ä‡ czÄ™Å›ci uÅ‚amkowej, zaleÅ¼nie od liczby.
fixed-point â†’ ustalasz â€twardoâ€ np. 8 bitÃ³w na uÅ‚amek i zawsze tak zapisujesz.

O co chodzi w konstruktorze z float?
Twoim celem jest wziÄ™cie liczby zmiennoprzecinkowej (np. 42.42f) i zapisanie jej w formacie fixed-point, czyli wewnÄ™trznie w postaci caÅ‚kowitej (int value).
Problem:
Float ma czÄ™Å›Ä‡ uÅ‚amkowÄ….
My chcemy jÄ… â€spakowaÄ‡â€ do naszego formatu fixed-point, czyli przesuniÄ™tego o 8 bitÃ³w (bo _fractionalBits = 8).
Jak siÄ™ to robi (logika, nie kod):
WeÅº liczbÄ™ n (np. 42.42).
PomnÃ³Å¼ jÄ… przez 2^8 = 256.
bo 8 bitÃ³w ma byÄ‡ przeznaczone na uÅ‚amki.
42.42 * 256 â‰ˆ 10859.
ZaokrÄ…glij wynik (bo float â†’ int moÅ¼e mieÄ‡ Å›mieci po przecinku).
Do tego uÅ¼yjesz funkcji roundf.
Zapisz ten wynik w polu value.
Teraz value = 10859.
A Ty wiesz, Å¼e to reprezentuje 42.42 w systemie fixed-point.

1ï¸âƒ£ toFloat()
Cel:
Konwertuje naszÄ… liczbÄ™ w formacie fixed-point na float, Å¼eby moÅ¼na byÅ‚o jÄ… uÅ¼ywaÄ‡ w zwykÅ‚ych obliczeniach zmiennoprzecinkowych lub wyÅ›wietlaÄ‡.
Dlaczego potrzebne:
TwÃ³j obiekt Fixed przechowuje wartoÅ›Ä‡ jako caÅ‚kowitÄ… (_value) przesuniÄ™tÄ… o 8 bitÃ³w (fixed-point).
JeÅ›li ktoÅ› chce wynik w formie â€prawdziwej liczby zmiennoprzecinkowejâ€, trzeba to przeliczyÄ‡.
DziÄ™ki temu moÅ¼na Å‚atwo np. robiÄ‡ obliczenia z floatami, uÅ¼ywaÄ‡ std::cout, itp.

3ï¸âƒ£ Operator << (insertion operator)
Cel:
UmoÅ¼liwia wypisywanie obiektÃ³w klasy Fixed w std::cout tak, jakby byÅ‚y floatami.
Dlaczego potrzebne:
Bez tego, std::cout << fixedObj; nie wie jak wyÅ›wietliÄ‡ TwÃ³j obiekt.
DziÄ™ki operatorowi moÅ¼esz od razu pisaÄ‡: std::cout << a;, a wynik bÄ™dzie Å‚adnie w formie zmiennoprzecinkowej.

Prototyp:
std::ostream &operator<<(std::ostream &stream, Fixed const &fixed)
Co oznacza kaÅ¼da czÄ™Å›Ä‡:
std::ostream &
To typ zwracany funkcji.
Zwracamy referencjÄ™ do strumienia wyjÅ›ciowego (np. std::cout), Å¼eby moÅ¼na byÅ‚o dalej â€Å‚aÅ„cuchowaÄ‡â€ wypisywanie:
std::cout << a << b << c;
operator<<
To przeciÄ…Å¼ony operator, ktÃ³ry pozwala uÅ¼ywaÄ‡ skÅ‚adni std::cout << obiekt;.
std::ostream &stream
Pierwszy argument funkcji, czyli strumieÅ„ wyjÅ›ciowy, do ktÃ³rego chcemy wstawiÄ‡ dane.
PrzykÅ‚ad: std::cout lub dowolny inny ostream.
Fixed const &fixed
Drugi argument, czyli obiekt klasy Fixed, ktÃ³ry chcemy wypisaÄ‡.
const â€“ nie zmieniamy obiektu w tej funkcji.
Referencja & â€“ przekazujemy go bez kopiowania, Å¼eby nie robiÄ‡ nowego obiektu i nie traciÄ‡ wydajnoÅ›ci.

fixed.toFloat() â€“ bierzesz wartoÅ›Ä‡ fixed-point i konwertujesz jÄ… na float.
stream << n â€“ wstawiasz jÄ… do strumienia wyjÅ›ciowego (np. std::cout).
return stream â€“ zwracasz strumieÅ„, dziÄ™ki czemu moÅ¼na Å‚aÅ„cuchowaÄ‡ wypisywanie, np. std::cout << a << b;.