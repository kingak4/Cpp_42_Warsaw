Chapter VII â€“ Exercise 02: Now weâ€™re talking

Ä†wiczenie 02: Teraz zaczyna siÄ™ zabawa
Katalog do oddania: ex02/
Pliki do oddania: Makefile, main.cpp, Fixed.{h, hpp}, Fixed.cpp
Dozwolone funkcje: roundf

Dodaj przeciÄ…Å¼enia operatorÃ³w:
6 operatorÃ³w porÃ³wnaÅ„: > < >= <= == !=
4 operatory arytmetyczne: + - * /
4 operatory inkrementacji/dekrementacji:
pre (++a, --a)
post (a++, a--)

Dodaj statyczne funkcje:
min (dla dwÃ³ch obiektÃ³w i dwÃ³ch const obiektÃ³w)
max (dla dwÃ³ch obiektÃ³w i dwÃ³ch const obiektÃ³w)
PrzykÅ‚ad pokazuje:
operatory ++, *, max
dziaÅ‚anie na liczbach staÅ‚oprzecinkowych
wynik np. 0.00390625 (bo 1/256 przy frac_bits = 8)

PrzeciÄ…Å¼enie operatorÃ³w: porÃ³wnania, arytmetyczne, inkrementacje/dekrementacje
Funkcje statyczne min i max

ğŸ”¹ Jak dziaÅ‚ajÄ… operatory porÃ³wnaÅ„ w C++?
Twoja klasa (np. Fixed)
Kompilator nie wie, jak porÃ³wnaÄ‡ dwa obiekty klasy Fixed, dopÃ³ki Ty mu tego nie powiesz.
Dlatego przeciÄ…Å¼asz operator:
np. operator<(const Fixed &other)
I w Å›rodku implementacji sama decydujesz, co porÃ³wnywaÄ‡ (np. wewnÄ™trznÄ… wartoÅ›Ä‡ _value).

ğŸ”¹ Jakie operatory implementujesz?
> â†’ zwraca true, gdy lewy obiekt jest wiÄ™kszy niÅ¼ prawy.
< â†’ zwraca true, gdy lewy obiekt jest mniejszy niÅ¼ prawy.
>= â†’ zwraca true, gdy lewy jest wiÄ™kszy lub rÃ³wny.
<= â†’ zwraca true, gdy lewy jest mniejszy lub rÃ³wny.
== â†’ zwraca true, gdy wartoÅ›ci sÄ… rÃ³wne.
!= â†’ zwraca true, gdy wartoÅ›ci sÄ… rÃ³Å¼ne.
ğŸ‘‰ Wszystkie dziaÅ‚ajÄ… na tej samej zasadzie â€“ porÃ³wnujÄ… jakieÅ› pole w obiekcie

this->value â†’ bierzesz wewnÄ™trznÄ… wartoÅ›Ä‡ bieÅ¼Ä…cego obiektu.
other.value â†’ bierzesz wartoÅ›Ä‡ obiektu, z ktÃ³rym porÃ³wnujesz.
> â†’ porÃ³wnujesz te dwie liczby.
Wynik to true albo false, ktÃ³re C++ i tak zamieni na 1 lub 0, bo masz zwracany typ int.

1. Czemu po sÅ‚owie operator musi byÄ‡ konkretny operator (<, >, == itd.)?
Bo w C++ tak siÄ™ nazywa funkcjÄ™ specjalnÄ….
Normalna funkcja nazywa siÄ™ np. compare().
Funkcja operatorowa musi mieÄ‡ nazwÄ™ wbudowanÄ…:
operator<
operator>
operator==
Kompilator wie wtedy: â€aha, jeÅ›li ktoÅ› napisze a < b, to mam wywoÅ‚aÄ‡ a.operator<(b)â€.
Czyli to nie jest â€fragment nazwyâ€, tylko wbudowany mechanizm jÄ™zyka C++.

2. Czemu potrzebujÄ™ tego w klasach, a nie wystarczy int?
GdybyÅ› pracowaÅ‚a tylko na int, kompilator ma juÅ¼ wbudowane operatory porÃ³wnaÅ„.
Ale w klasie Fixed masz prywatne pole (np. int value) i dla kompilatora to jest nowy typ â€“ on nie wie, jak porÃ³wnaÄ‡ dwa obiekty Fixed.
Ty sama musisz mu powiedzieÄ‡, jak to zrobiÄ‡ â†’ wÅ‚aÅ›nie przeciÄ…Å¼ajÄ…c operator.

Po co sÄ… te funkcje?
Twoja klasa Fixed udaje liczbÄ™ staÅ‚oprzecinkowÄ….
Chcesz, Å¼eby moÅ¼na byÅ‚o pisaÄ‡:

Fixed a(10.5f);
Fixed b(2.0f);
Fixed c = a + b;  // zamiast: a.add(b)
Fixed d = a - b;
Fixed e = a * b;
Fixed f = a / b;

ğŸ‘‰ GdybyÅ› nie napisaÅ‚a tych operatorÃ³w, to a + b byÅ‚oby bÅ‚Ä™dem kompilacji, bo kompilator nie wie, jak dodaÄ‡ dwa obiekty Fixed.

Ty musisz mu powiedzieÄ‡:
Co zrobiÄ‡, gdy ktoÅ› uÅ¼yje + na obiektach Twojej klasy.
I analogicznie dla -, *, /.

ğŸ”¹ Jak to dziaÅ‚a w Å›rodku?
Operator +
Tworzysz nowy obiekt Fixed, ktÃ³rego wartoÅ›Ä‡ = suma this i other.
Zwracasz ten obiekt.

Operator -
To samo, tylko rÃ³Å¼nica.

Operator *
Wynik = iloczyn obu wartoÅ›ci.

Operator /
Wynik = iloraz obu wartoÅ›ci.
âš ï¸ Musisz uwaÅ¼aÄ‡ na dzielenie przez zero â†’ dobrze jest dodaÄ‡ sprawdzanie i ewentualnie obsÅ‚uÅ¼yÄ‡ wyjÄ…tek.

Krok po kroku
toFloat()
Twoja klasa Fixed ma metodÄ™ toFloat(), ktÃ³ra zamienia wewnÄ™trznÄ…, â€przeskalowanÄ…â€ wartoÅ›Ä‡ (value) na zwykÅ‚ego float.
PrzykÅ‚ad: jeÅ›li value = 256 i masz 8 bitÃ³w uÅ‚amkowych, to toFloat() zwrÃ³ci 1.0f.
toFloat() + other.toFloat()

Teraz operujesz na normalnych floatach, ktÃ³re C++ umie dodaÄ‡ wbudowanymi operatorami.
Wynik to zwykÅ‚y float.
PrzykÅ‚ad: 1.5f + 2.25f = 3.75f.

Fixed(...)
Konstruktor Fixed(float) zostaje wywoÅ‚any z tym wynikiem.
Ten konstruktor konwertuje float z powrotem do formatu staÅ‚oprzecinkowego i zapisuje w polu value.
PrzykÅ‚ad: 3.75f â†’ zapisuje jako 960, jeÅ›li masz 8 bitÃ³w uÅ‚amkowych (3.75 * 256 = 960).
return
Funkcja zwraca nowo utworzony obiekt Fixed, ktÃ³ry reprezentuje wynik dodawania.

ğŸ”¹ Dlaczego to podejÅ›cie jest dobre?
PoprawnoÅ›Ä‡ matematyczna â€“ operacje na float dajÄ… wynik dokÅ‚adnie taki, jakiego oczekujesz.
UniwersalnoÅ›Ä‡ â€“ to samo rozwiÄ…zanie dziaÅ‚a dla +, -, *, /.
CzytelnoÅ›Ä‡ â€“ od razu widaÄ‡: â€aha, tu dodajemy liczby zmiennoprzecinkowe, a potem z tego robimy Fixedâ€.

ğŸ”¹ Po co one sÄ… ++ --?
W C++ mamy dwie wersje operatorÃ³w:
Pre-inkrementacja / pre-dekrementacja
++a albo --a
najpierw zmienia wartoÅ›Ä‡, a potem zwraca juÅ¼ zmienionÄ….
np.:
int a = 5;
int b = ++a; // a = 6, b = 6

Post-inkrementacja / post-dekrementacja
a++ albo a--
najpierw zwraca starÄ… wartoÅ›Ä‡, a dopiero potem jÄ… zmienia.
np.:

int a = 5;
int b = a++; // a = 6, b = 5
ğŸ”¹ Dlaczego mamy dwie wersje?
Bo w kodzie czasami chcesz:
pracowaÄ‡ na juÅ¼ zmienionej wartoÅ›ci (++a),
a czasami na starej, przed zmianÄ… (a++).
PrzykÅ‚ad: w pÄ™tli for(int i=0; i<10; i++) uÅ¼ywasz postinkrementacji, bo interesuje CiÄ™ najpierw aktualna i, a dopiero potem zmiana.

ğŸ”¹ Jak to dziaÅ‚a w naszej klasie Fixed?
Inkrementacja ++ â†’ zwiÄ™ksza naszÄ… liczbÄ™ o najmniejszÄ… moÅ¼liwÄ… jednostkÄ™ (epsilon).
W przypadku fixed-point, tym "epsilon" jest 1 jednostka w czÄ™Å›ci uÅ‚amkowej (czyli 1 << fractionalBits).
Dekrementacja -- â†’ analogicznie zmniejsza.

ğŸ”¹ 2. Co to jest *this?
this jest wskaÅºnikiem (Fixed*).
*this to obiekt, na ktÃ³ry wskazuje (czyli normalny Fixed).
Dlatego jak robisz return *this;, to tak naprawdÄ™ zwracasz sam obiekt (czyli aktualny Fixed).

ğŸ”¹ 3. Dlaczego zwracamy Fixed& w pre-inkrementacji?
Wersja pre (++a) powinna zwrÃ³ciÄ‡ ten sam obiekt, tylko juÅ¼ zmieniony.
A skoro zwracamy ten sam obiekt, to najlepiej zwrÃ³ciÄ‡ go jako referencjÄ™ (Fixed&), Å¼eby nie tworzyÄ‡ kopii.

ğŸ”¹ 5. Jak to dziaÅ‚a dla post-inkrementacji (a++)?
Tu logika jest inna:
najpierw trzeba zwrÃ³ciÄ‡ starÄ… wartoÅ›Ä‡ (kopiÄ™!),
potem dopiero zmieniÄ‡ obiekt.

ğŸ”¹ Dlaczego zwracamy *this?

this â†’ to wskaÅºnik do bieÅ¼Ä…cego obiektu (Fixed*).
Czyli wewnÄ…trz metody operator++ masz dostÄ™p do obiektu, na ktÃ³rym ktoÅ› wywoÅ‚aÅ‚ ++.

PrzykÅ‚ad:

Fixed a;
++a; // tutaj this pokazuje na a


*this â†’ to dereferencja wskaÅºnika, czyli â€sam obiekt, na ktÃ³ry wskazuje thisâ€.
Innymi sÅ‚owy â†’ to â€ja samâ€ (a w przykÅ‚adzie wyÅ¼ej).

Dlaczego zwracamy *this?
Bo pre-inkrementacja (++a) modyfikuje bieÅ¼Ä…cy obiekt i zwraca jego referencjÄ™.
DziÄ™ki temu moÅ¼esz np. pisaÄ‡ Å‚aÅ„cuchy wywoÅ‚aÅ„:
++(++a); // dziaÅ‚a, bo ++a zwraca referencjÄ™ do a
GdybyÅ› zwrÃ³ciÅ‚a kopiÄ™, to kolejne ++ dziaÅ‚aÅ‚oby na kopii, a nie na oryginalnym a.

ğŸ”¹ KrÃ³tkie porÃ³wnanie:
return *this; â†’ zwracasz sam obiekt po zmianie (dokÅ‚adnie to, czego wymaga ++a).
return temp; (w wersji post) â†’ zwracasz kopiÄ™ starego obiektu, bo a++ najpierw daje starÄ… wartoÅ›Ä‡, a dopiero potem zmienia oryginaÅ‚.

ğŸ‘‰ PodsumowujÄ…c:
Zwracasz *this, Å¼eby pozwoliÄ‡ dalej pracowaÄ‡ na tym samym obiekcie, a nie na jego kopii.

ğŸ”¹ Podsumowanie operatorÃ³w inkrementacji/dekrementacji
| Operator     | Typ zwracany | Co robi                                              | Kiedy uÅ¼ywaÄ‡                                         |
| ------------ | ------------ | ---------------------------------------------------- | ---------------------------------------------------- |
| `++a` (pre)  | `Fixed&`     | ZwiÄ™ksza obiekt, zwraca referencjÄ™                   | Kiedy od razu chcesz pracowaÄ‡ na zmienionym obiekcie |
| `--a` (pre)  | `Fixed&`     | Zmniejsza obiekt, zwraca referencjÄ™                  | Tak samo, ale zmniejsza                              |
| `a++` (post) | `Fixed`      | Zwraca kopiÄ™ starej wartoÅ›ci, potem zwiÄ™ksza obiekt  | Kiedy potrzebujesz starej wartoÅ›ci, np. w pÄ™tli      |
| `a--` (post) | `Fixed`      | Zwraca kopiÄ™ starej wartoÅ›ci, potem zmniejsza obiekt | Analogicznie do `a++`                                |


ğŸ”¹ Kluczowe zasady do zapamiÄ™tania
Pre (++a, --a) â†’ zwracamy referencjÄ™ do tego samego obiektu.
Post (a++, a--) â†’ zwracamy kopiÄ™ starego obiektu.
*this â†’ odniesienie do bieÅ¼Ä…cego obiektu.
WartoÅ›Ä‡ zmieniamy o najmniejszÄ… jednostkÄ™ (epsilon).

ğŸ”¹ Po co sÄ… te funkcje? min i max
min â†’ zwraca obiekt o mniejszej wartoÅ›ci spoÅ›rÃ³d dwÃ³ch podanych.
max â†’ zwraca obiekt o wiÄ™kszej wartoÅ›ci spoÅ›rÃ³d dwÃ³ch podanych.
ğŸ”¹ Dlaczego sÄ… static?
static oznacza, Å¼e nie potrzebujesz mieÄ‡ obiektu, Å¼eby wywoÅ‚aÄ‡ funkcjÄ™.
MoÅ¼esz napisaÄ‡:

Fixed a, b;
// wypeÅ‚niasz wartoÅ›ci a i b
Fixed c = Fixed::min(a, b);  // nie trzeba pisaÄ‡ a.min(b)
Funkcje min i max dziaÅ‚ajÄ… tylko na argumentach, nie zmieniajÄ… Å¼adnego obiektu, dlatego sÄ… statyczne.

ğŸ”¹ Dlaczego sÄ… wersje z const?
Fixed &min(Fixed &f1, Fixed &f2) â†’ dziaÅ‚a na zwykÅ‚ych obiektach, moÅ¼esz potem np. zmieniaÄ‡ zwrÃ³cony obiekt.
const Fixed &min(const Fixed &f1, const Fixed &f2) â†’ dziaÅ‚a na obiektach const (nie modyfikujesz ich), np. gdy porÃ³wnujesz staÅ‚e wartoÅ›ci.
DziÄ™ki temu funkcje sÄ… uniwersalne i moÅ¼na ich uÅ¼ywaÄ‡ w rÃ³Å¼nych sytuacjach.

ğŸ”¹ 2. Dlaczego nie uÅ¼ywamy static w definicji poza klasÄ…?
Gdy definiujesz funkcjÄ™ poza klasÄ…:
Fixed &Fixed::min(Fixed &f1, Fixed &f2)
Kompilator juÅ¼ wie, Å¼e funkcja byÅ‚a zadeklarowana jako statyczna w klasie.
JeÅ›li dodasz static ponownie, kompilator interpretuje to inaczej â€“ jako funkcjÄ™ lokalnÄ… w tym pliku (C++ nie pozwala jednoczeÅ›nie, Å¼eby byÅ‚a statyczna w sensie lokalnym i globalnym).