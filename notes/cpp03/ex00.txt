Ä†wiczenie 00 â€“ ClapTrap
Co zrobiÄ‡:

UtwÃ³rz klasÄ™ ClapTrap z prywatnymi atrybutami:
Name â€“ przekazywany do konstruktora
Hit points = 1
Energy points = 10
Attack damage = 0

Dodaj publiczne metody:
void attack(const std::string& target) â†’ zmniejsza hit points celu o attack damage i zuÅ¼ywa 1 energii
void takeDamage(unsigned int amount) â†’ zmniejsza hit points
void beRepaired(unsigned int amount) â†’ zwiÄ™ksza hit points i zuÅ¼ywa 1 energii
WyÅ›wietlanie wiadomoÅ›ci w kaÅ¼dej metodzie i konstruktorze/destruktorze.
Nie musisz obsÅ‚ugiwaÄ‡ interakcji miÄ™dzy obiektami â€“ target to zwykÅ‚y string.
Podsumowanie: Tworzysz podstawowÄ… klasÄ™ robot-a z metodami ataku, naprawy i obraÅ¼eÅ„, z komunikatami.

OgÃ³lne podsumowanie dla wszystkich Ä‡wiczeÅ„
| Ä†wiczenie     | Co robiÄ‡                  | Kluczowe punkty                                                                                |
| ------------- | ------------------------- | ---------------------------------------------------------------------------------------------- |
| ex00 ClapTrap | Tworzysz klasÄ™ podstawowÄ… | Konstruktor, destruktor, attack, takeDamage, beRepaired, komunikaty, zarzÄ…dzanie energiÄ… i hp  |
| ex01 ScavTrap | Klasa pochodna            | Dziedziczenie po ClapTrap, wÅ‚asne wartoÅ›ci atrybutÃ³w, metoda guardGate(), rÃ³Å¼ne komunikaty     |
| ex02 FragTrap | Klasa pochodna            | Dziedziczenie po ClapTrap, wÅ‚asne wartoÅ›ci atrybutÃ³w, metoda highFivesGuys(), rÃ³Å¼ne komunikaty |


Atrybuty prywatne

std::string name â€“ imiÄ™ robota.
Po co: identyfikuje robota w komunikatach, np. â€ClapTrap <name> attacks â€¦â€.

int hitPoints â€“ zdrowie robota.
Po co: okreÅ›la, ile obraÅ¼eÅ„ robot moÅ¼e przyjÄ…Ä‡ zanim przestanie dziaÅ‚aÄ‡.

int energyPoints â€“ energia robota.
Po co: kaÅ¼de dziaÅ‚anie (atak, naprawa) kosztuje energiÄ™. Robot nie moÅ¼e dziaÅ‚aÄ‡ przy zerowej energii.

int damage â€“ siÅ‚a ataku robota.
Po co: okreÅ›la, ile punktÃ³w Å¼ycia straci cel podczas ataku.
Konstruktory i destruktor

ClapTrap(std::string name) â€“ konstruktor z nazwÄ….
Po co: tworzy robota o podanej nazwie i ustawia wartoÅ›ci domyÅ›lne dla hitPoints, energyPoints i damage.
Dodatkowo: wyÅ›wietla komunikat, Å¼e konstruktor zostaÅ‚ wywoÅ‚any.

ClapTrap(ClapTrap &other) â€“ konstruktor kopiujÄ…cy.
Po co: pozwala utworzyÄ‡ nowego robota kopiujÄ…c wartoÅ›ci z innego obiektu.
Dodatkowo: wyÅ›wietla komunikat o kopiowaniu.

ClapTrap &operator=(ClapTrap &other) â€“ operator przypisania.
Po co: pozwala przypisaÄ‡ wartoÅ›ci jednego obiektu do innego, np. robot1 = robot2.
Dodatkowo: zwykle sprawdza samoprzydzielenie i kopiuje wszystkie atrybuty.

~ClapTrap() â€“ destruktor.
Po co: wywoÅ‚ywany przy niszczeniu obiektu.
Dodatkowo: wyÅ›wietla komunikat, Å¼e obiekt jest niszczony.

Metody publiczne
std::string getName(void)
Po co: zwraca nazwÄ™ robota.
Przydatne, np. przy wyÅ›wietlaniu komunikatÃ³w lub testach.

void attack(const std::string &target)
Po co: robot atakuje cel.
Co robi w praktyce:
Sprawdza, czy robot ma energiÄ™ i hitPoints > 0.
ZuÅ¼ywa 1 energii.
WyÅ›wietla komunikat: â€ClapTrap <name> attacks <target>, causing <damage> points of damage!â€.

void takeDamage(unsigned int amount)
Po co: robot otrzymuje obraÅ¼enia.
Co robi:
Zmniejsza hitPoints o amount.
WyÅ›wietla komunikat z informacjÄ… o stratach HP.

void beRepaired(unsigned int amount)
Po co: robot siÄ™ naprawia i odzyskuje HP.
Co robi:
Sprawdza, czy robot ma energiÄ™ i hitPoints > 0.
ZwiÄ™ksza hitPoints o amount.
ZuÅ¼ywa 1 energii.
WyÅ›wietla komunikat o naprawie.

Podsumowanie w Twoim stylu

ğŸ‘‰ Robimy:
Konstruktor â†’ inicjalizacja robota (nazwa, HP=10, EN=10, DMG=0).
Konstruktor kopiujÄ…cy â†’ Å¼eby moÅ¼na byÅ‚o skopiowaÄ‡ robota.
Operator przypisania â†’ Å¼eby dziaÅ‚aÅ‚o = miÄ™dzy obiektami.
Destruktor â†’ Å¼eby byÅ‚o widaÄ‡ kiedy robot jest niszczony.
Getter (opcjonalny, ale przydatny).
Funkcje attack, takeDamage, beRepaired â†’ bo tego dokÅ‚adnie wymaga subject.

Pro Tip â€“ jak siÄ™ uczyÄ‡ tego schematu?
ğŸ‘‰ MyÅ›l zawsze w ten sposÃ³b:
Konstruktor = tworzenie i nadawanie poczÄ…tkowych wartoÅ›ci.
Konstruktor kopiujÄ…cy = klonowanie innego obiektu.
Operator przypisania = nadpisywanie istniejÄ…cego obiektu wartoÅ›ciami innego.
Destruktor = sprzÄ…tanie i komunikat.
Getter = bezpieczny dostÄ™p do prywatnej zmiennej

ğŸ”¹ 1. attack(const std::string& target)
ğŸ‘‰ Cel: ClapTrap ma zaatakowaÄ‡ jakiÅ› cel.

Co siÄ™ dzieje w Å›rodku:
Sprawdzasz, czy ClapTrap ma jeszcze punkty Å¼ycia (hitPoints > 0) i energiÄ™ (energyPoints > 0).
JeÅ›li nie â†’ nic siÄ™ nie dzieje (wypisz komunikat w stylu "ClapTrap X nie moÅ¼e zaatakowaÄ‡").
JeÅ›li moÅ¼e:
Odejmujesz 1 punkt energii (energyPoints -= 1).
Wypisujesz komunikat, np. â€ClapTrap <name> attacks <target>, causing <damage> points of damage!â€.

ğŸ”¹ 2. takeDamage(unsigned int amount)
ğŸ‘‰ Cel: ClapTrap dostaje obraÅ¼enia.

Co siÄ™ dzieje:
Odejmujesz amount od hitPoints.
Ale uwaÅ¼aj:
JeÅ›li obraÅ¼enia sÄ… wiÄ™ksze niÅ¼ Å¼ycie â†’ hitPoints nie mogÄ… spaÅ›Ä‡ poniÅ¼ej 0.
Wypisujesz komunikat: â€ClapTrap <name> takes <amount> damage, remaining HP: <hitPoints>â€.

ğŸ”¹ 3. beRepaired(unsigned int amount)
ğŸ‘‰ Cel: ClapTrap leczy siÄ™ (odzyskuje HP).

Co siÄ™ dzieje:
Sprawdzasz, czy ClapTrap Å¼yje (hitPoints > 0) i czy ma energiÄ™ (energyPoints > 0).
JeÅ›li nie â†’ nic siÄ™ nie dzieje, wypisz komunikat.

JeÅ›li tak:
Odejmujesz 1 punkt energii (energyPoints -= 1).
Dodajesz amount do hitPoints.
Wypisujesz komunikat: â€ClapTrap <name> repairs itself, +<amount> HP, total: <hitPoints>â€.

âœ¨ Podsumowanie
attack â†’ sprawdza energiÄ™/Å¼ycie â†’ zuÅ¼ywa energiÄ™ â†’ wypisuje komunikat o ataku.
takeDamage â†’ zmniejsza Å¼ycie, nigdy poniÅ¼ej 0 â†’ wypisuje co siÄ™ staÅ‚o.
beRepaired â†’ sprawdza energiÄ™/Å¼ycie â†’ zuÅ¼ywa energiÄ™ â†’ dodaje Å¼ycie â†’ wypisuje komunikat.