Ćwiczenie 00 – ClapTrap
Co zrobić:

Utwórz klasę ClapTrap z prywatnymi atrybutami:
Name – przekazywany do konstruktora
Hit points = 1
Energy points = 10
Attack damage = 0

Dodaj publiczne metody:
void attack(const std::string& target) → zmniejsza hit points celu o attack damage i zużywa 1 energii
void takeDamage(unsigned int amount) → zmniejsza hit points
void beRepaired(unsigned int amount) → zwiększa hit points i zużywa 1 energii
Wyświetlanie wiadomości w każdej metodzie i konstruktorze/destruktorze.
Nie musisz obsługiwać interakcji między obiektami – target to zwykły string.
Podsumowanie: Tworzysz podstawową klasę robot-a z metodami ataku, naprawy i obrażeń, z komunikatami.

Ogólne podsumowanie dla wszystkich ćwiczeń
| Ćwiczenie     | Co robić                  | Kluczowe punkty                                                                                |
| ------------- | ------------------------- | ---------------------------------------------------------------------------------------------- |
| ex00 ClapTrap | Tworzysz klasę podstawową | Konstruktor, destruktor, attack, takeDamage, beRepaired, komunikaty, zarządzanie energią i hp  |
| ex01 ScavTrap | Klasa pochodna            | Dziedziczenie po ClapTrap, własne wartości atrybutów, metoda guardGate(), różne komunikaty     |
| ex02 FragTrap | Klasa pochodna            | Dziedziczenie po ClapTrap, własne wartości atrybutów, metoda highFivesGuys(), różne komunikaty |


Atrybuty prywatne

std::string name – imię robota.
Po co: identyfikuje robota w komunikatach, np. „ClapTrap <name> attacks …”.

int hitPoints – zdrowie robota.
Po co: określa, ile obrażeń robot może przyjąć zanim przestanie działać.

int energyPoints – energia robota.
Po co: każde działanie (atak, naprawa) kosztuje energię. Robot nie może działać przy zerowej energii.

int damage – siła ataku robota.
Po co: określa, ile punktów życia straci cel podczas ataku.
Konstruktory i destruktor

ClapTrap(std::string name) – konstruktor z nazwą.
Po co: tworzy robota o podanej nazwie i ustawia wartości domyślne dla hitPoints, energyPoints i damage.
Dodatkowo: wyświetla komunikat, że konstruktor został wywołany.

ClapTrap(ClapTrap &other) – konstruktor kopiujący.
Po co: pozwala utworzyć nowego robota kopiując wartości z innego obiektu.
Dodatkowo: wyświetla komunikat o kopiowaniu.

ClapTrap &operator=(ClapTrap &other) – operator przypisania.
Po co: pozwala przypisać wartości jednego obiektu do innego, np. robot1 = robot2.
Dodatkowo: zwykle sprawdza samoprzydzielenie i kopiuje wszystkie atrybuty.

~ClapTrap() – destruktor.
Po co: wywoływany przy niszczeniu obiektu.
Dodatkowo: wyświetla komunikat, że obiekt jest niszczony.

Metody publiczne
std::string getName(void)
Po co: zwraca nazwę robota.
Przydatne, np. przy wyświetlaniu komunikatów lub testach.

void attack(const std::string &target)
Po co: robot atakuje cel.
Co robi w praktyce:
Sprawdza, czy robot ma energię i hitPoints > 0.
Zużywa 1 energii.
Wyświetla komunikat: „ClapTrap <name> attacks <target>, causing <damage> points of damage!”.

void takeDamage(unsigned int amount)
Po co: robot otrzymuje obrażenia.
Co robi:
Zmniejsza hitPoints o amount.
Wyświetla komunikat z informacją o stratach HP.

void beRepaired(unsigned int amount)
Po co: robot się naprawia i odzyskuje HP.
Co robi:
Sprawdza, czy robot ma energię i hitPoints > 0.
Zwiększa hitPoints o amount.
Zużywa 1 energii.
Wyświetla komunikat o naprawie.

Podsumowanie w Twoim stylu

👉 Robimy:
Konstruktor → inicjalizacja robota (nazwa, HP=10, EN=10, DMG=0).
Konstruktor kopiujący → żeby można było skopiować robota.
Operator przypisania → żeby działało = między obiektami.
Destruktor → żeby było widać kiedy robot jest niszczony.
Getter (opcjonalny, ale przydatny).
Funkcje attack, takeDamage, beRepaired → bo tego dokładnie wymaga subject.

Pro Tip – jak się uczyć tego schematu?
👉 Myśl zawsze w ten sposób:
Konstruktor = tworzenie i nadawanie początkowych wartości.
Konstruktor kopiujący = klonowanie innego obiektu.
Operator przypisania = nadpisywanie istniejącego obiektu wartościami innego.
Destruktor = sprzątanie i komunikat.
Getter = bezpieczny dostęp do prywatnej zmiennej

🔹 1. attack(const std::string& target)
👉 Cel: ClapTrap ma zaatakować jakiś cel.

Co się dzieje w środku:
Sprawdzasz, czy ClapTrap ma jeszcze punkty życia (hitPoints > 0) i energię (energyPoints > 0).
Jeśli nie → nic się nie dzieje (wypisz komunikat w stylu "ClapTrap X nie może zaatakować").
Jeśli może:
Odejmujesz 1 punkt energii (energyPoints -= 1).
Wypisujesz komunikat, np. „ClapTrap <name> attacks <target>, causing <damage> points of damage!”.

🔹 2. takeDamage(unsigned int amount)
👉 Cel: ClapTrap dostaje obrażenia.

Co się dzieje:
Odejmujesz amount od hitPoints.
Ale uważaj:
Jeśli obrażenia są większe niż życie → hitPoints nie mogą spaść poniżej 0.
Wypisujesz komunikat: „ClapTrap <name> takes <amount> damage, remaining HP: <hitPoints>”.

🔹 3. beRepaired(unsigned int amount)
👉 Cel: ClapTrap leczy się (odzyskuje HP).

Co się dzieje:
Sprawdzasz, czy ClapTrap żyje (hitPoints > 0) i czy ma energię (energyPoints > 0).
Jeśli nie → nic się nie dzieje, wypisz komunikat.

Jeśli tak:
Odejmujesz 1 punkt energii (energyPoints -= 1).
Dodajesz amount do hitPoints.
Wypisujesz komunikat: „ClapTrap <name> repairs itself, +<amount> HP, total: <hitPoints>”.

✨ Podsumowanie
attack → sprawdza energię/życie → zużywa energię → wypisuje komunikat o ataku.
takeDamage → zmniejsza życie, nigdy poniżej 0 → wypisuje co się stało.
beRepaired → sprawdza energię/życie → zużywa energię → dodaje życie → wypisuje komunikat.