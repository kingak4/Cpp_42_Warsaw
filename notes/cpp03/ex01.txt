V: Ä†wiczenie 01 â€“ ScavTrap
Co zrobiÄ‡:
UtwÃ³rz klasÄ™ ScavTrap, ktÃ³ra dziedziczy po ClapTrap.
Konstruktory i destruktor: wypisujÄ… inne komunikaty niÅ¼ ClapTrap.

Atrybuty:
Hit points = 100
Energy points = 50
Attack damage = 20
Dodaj wÅ‚asnÄ… metodÄ™:
void guardGate() â†’ informuje, Å¼e ScavTrap jest w trybie Gate keeper.
PamiÄ™taj o Å‚aÅ„cuchu konstrukcji i destrukcji:

Najpierw ClapTrap, potem ScavTrap. Destrukcja w odwrotnej kolejnoÅ›ci.
Podsumowanie: Tworzysz klasÄ™ pochodnÄ…, ktÃ³ra dziedziczy funkcje i atrybuty, ale z wÅ‚asnymi wartoÅ›ciami i metodÄ… specjalnÄ….

Nowa klasa ScavTrap
To jest nowy robot, ktÃ³ry dziedziczy po klasie ClapTrap.
Dziedziczenie oznacza, Å¼e ScavTrap ma wszystkie funkcje i atrybuty ClapTrapa, ale moÅ¼e je nadpisywaÄ‡ (np. wÅ‚asne komunikaty w konstruktorze, destruktorze, ataku).

Konstruktor i destruktor
Kiedy tworzysz ScavTrap, najpierw wywoÅ‚uje siÄ™ konstruktor ClapTrap (bo ScavTrap dziedziczy po ClapTrap).
Kiedy ScavTrap znika, najpierw wywoÅ‚uje siÄ™ destruktor ScavTrap, potem destruktor ClapTrap (odwrÃ³cona kolejnoÅ›Ä‡).
To jest tzw. proper construction/destruction chaining.

Atrybuty
name â€“ przekazany z zewnÄ…trz (tak jak w ClapTrap).
hitPoints â€“ 100 (wiÄ™ksze niÅ¼ ClapTrap).
energyPoints â€“ 50 (wiÄ™ksze niÅ¼ ClapTrap).
attackDamage â€“ 20 (wiÄ™ksze niÅ¼ ClapTrap).

WÅ‚asne funkcje
attack() â€“ ScavTrap moÅ¼e atakowaÄ‡, ale komunikat wyÅ›wietlany jest inny, np. w stylu ScavTrapa.
guardGate() â€“ nowa specjalna funkcja, ktÃ³ra wypisuje, Å¼e ScavTrap jest w trybie â€Gate keeperâ€.

ğŸ”¹ Podsumowanie 
Tworzysz klasÄ™ ScavTrap, ktÃ³ra dziedziczy po ClapTrap.
Nadpisujesz (override) konstruktor, destruktor i attack(), Å¼eby byÅ‚y inne komunikaty.
Inicjalizujesz atrybuty z wÅ‚asnymi wartoÅ›ciami (HP=100, EP=50, AD=20).
Dodajesz nowÄ… funkcjÄ™ guardGate().
W main pokazujesz wszystkie funkcje i sprawdzasz kolejnoÅ›Ä‡ wywoÅ‚aÅ„ konstruktorÃ³w i destruktorÃ³w.

ğŸ’¡ NajwaÅ¼niejsze zasady:
Dziedziczenie pozwala na ponowne uÅ¼ycie kodu (ClapTrap).
Nadpisywanie funkcji â€“ ScavTrap ma wÅ‚asny styl komunikatÃ³w.
KolejnoÅ›Ä‡ konstruktorÃ³w i destruktorÃ³w pokazuje prawidÅ‚owe tworzenie i niszczenie obiektÃ³w dziedziczÄ…cych.

1ï¸âƒ£ Private
DostÄ™p: Tylko w samej klasie, ktÃ³ra deklaruje te pola/metody.
Nie moÅ¼na ich uÅ¼ywaÄ‡ w klasach pochodnych ani poza klasÄ….

2ï¸âƒ£ Protected
DostÄ™p: w klasie i w klasach pochodnych, ale nie z zewnÄ…trz (czyli nie moÅ¼na uÅ¼yÄ‡ obiektu tej klasy i napisaÄ‡ obj.x = 5;).

| Modyfikator | DostÄ™p w klasie | DostÄ™p w klasie pochodnej | DostÄ™p z zewnÄ…trz |
| ----------- | --------------- | ------------------------- | ----------------- |
| private     | âœ…               | âŒ                         | âŒ                 |
| protected   | âœ…               | âœ…                         | âŒ                 |
| public      | âœ…               | âœ…                         | âœ…                 |

ğŸ’¡ ReguÅ‚a praktyczna:
Dane, ktÃ³re majÄ… byÄ‡ dostÄ™pne tylko w klasie: private.
Dane, ktÃ³re majÄ… byÄ‡ dostÄ™pne w klasach dziedziczÄ…cych: protected.
Dane/metody, ktÃ³re majÄ… byÄ‡ dostÄ™pne wszÄ™dzie: public.
ClapTrap::operator=(other);
wywoÅ‚ujesz operator przypisania klasy bazowej (ClapTrap). Co siÄ™ wtedy dzieje:

Wszystkie pola zdefiniowane w ClapTrap (czyli name, hitPoints, energyPoints, damage) sÄ… kopiowane z other do *this.

Nie musisz ich rÄ™cznie przypisywaÄ‡ w ScavTrap â€” robi to za Ciebie kod w ClapTrap::operator=.
DziÄ™ki temu TwÃ³j kod jest krÃ³tszy, bezpieczniejszy i Å‚atwiejszy w utrzymaniu â€” jeÅ›li w ClapTrap dodasz nowe pole w przyszÅ‚oÅ›ci, nie trzeba zmieniaÄ‡ ScavTrap.
Czyli tak naprawdÄ™ to zastÄ™puje dokÅ‚adnie to, co miaÅ‚aÅ› w swoim rÄ™cznym przypisywaniu pÃ³l, ale w sposÃ³b bardziej elegancki i odporny na bÅ‚Ä™dy.