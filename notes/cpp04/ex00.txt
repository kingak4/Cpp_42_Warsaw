ğŸ”¹ Exercise 00 â€“ Polymorphism

Dla kaÅ¼dego Ä‡wiczenia musisz dostarczyÄ‡ najbardziej kompletne testy, jakie moÅ¼esz.
Konstruktory i destruktory kaÅ¼dej klasy muszÄ… wyÅ›wietlaÄ‡ konkretne komunikaty.
Nie uÅ¼ywaj tego samego komunikatu dla wszystkich klas.

Zacznij od zaimplementowania prostej klasy bazowej o nazwie Animal.
Ma ona jeden chroniony atrybut:

std::string type;

Zaimplementuj klasÄ™ Dog, ktÃ³ra dziedziczy po Animal.
Zaimplementuj klasÄ™ Cat, ktÃ³ra dziedziczy po Animal.

Te dwie klasy pochodne muszÄ… ustawiaÄ‡ swoje pole type odpowiednio do ich nazwy.
Wtedy Dog bÄ™dzie miaÅ‚ type zainicjalizowany na "Dog", a Cat na "Cat".
Pole type klasy Animal moÅ¼e byÄ‡ puste albo ustawione na dowolnÄ… wartoÅ›Ä‡ wedÅ‚ug twojego wyboru.

KaÅ¼de zwierzÄ™ musi byÄ‡ w stanie uÅ¼ywaÄ‡ funkcji czÅ‚onkowskiej:

makeSound()
BÄ™dzie ona wypisywaÄ‡ odpowiedni dÅºwiÄ™k (koty nie szczekajÄ…).

Aby upewniÄ‡ siÄ™, Å¼e rozumiesz, jak to dziaÅ‚a, zaimplementuj klasÄ™ WrongCat, ktÃ³ra dziedziczy po klasie WrongAnimal.
JeÅ›li w powyÅ¼szym kodzie zastÄ…pisz Animal i Cat ich bÅ‚Ä™dnymi odpowiednikami, WrongCat powinien wypisaÄ‡ dÅºwiÄ™k klasy WrongAnimal.

Zaimplementuj i oddaj wiÄ™cej testÃ³w niÅ¼ te podane powyÅ¼ej.


Co masz zrobiÄ‡:
UtworzyÄ‡ klasÄ™ bazowÄ… Animal z atrybutem std::string type.
UtworzyÄ‡ klasy Dog i Cat dziedziczÄ…ce po Animal.
KaÅ¼da klasa musi mieÄ‡ metodÄ™ makeSound(), ktÃ³ra robi coÅ› innego (pies szczeka, kot miauczy).
Konstruktor Dog ustawia type na "Dog", a Cat na "Cat".

W main() stwÃ³rz obiekty Animal, Dog i Cat i sprawdÅº, Å¼e dÅºwiÄ™ki sÄ… poprawne.
UtwÃ³rz rÃ³wnieÅ¼ WrongAnimal i WrongCat, ktÃ³re pokaÅ¼Ä… brak polimorfizmu (brak wirtualnych metod â†’ wywoÅ‚a siÄ™ metoda z klasy bazowej, a nie pochodnej).

Czego siÄ™ nauczysz:
protected vs private w klasach.
Dziedziczenie w C++.
virtual przy funkcjach, Å¼eby polimorfizm dziaÅ‚aÅ‚.
WskaÅºniki do klasy bazowej pokazujÄ…ce na klasy pochodne.


ğŸ”¹ Polimorfizm z virtual
Animal* a = new Dog();
a->makeSound();

ğŸ‘‰ JeÅ›li metoda nie jest virtual, wywoÅ‚a siÄ™ Animal::makeSound().
ğŸ‘‰ JeÅ›li metoda jest virtual, wywoÅ‚a siÄ™ Dog::makeSound().

Czyli wybierana jest wÅ‚aÅ›ciwa wersja metody w trakcie dziaÅ‚ania programu (runtime), a nie w trakcie kompilacji.
To siÄ™ nazywa dynamiczne wiÄ…zanie (late binding).
DziÄ™ki virtual program "patrzy", jaki obiekt naprawdÄ™ istnieje w pamiÄ™ci, a nie tylko jaki ma wskaÅºnik.

ğŸ”¹ Do czego to siÄ™ przydaje praktycznie?
Masz wspÃ³lny interfejs (makeSound() w Animal),
MoÅ¼esz tworzyÄ‡ rÃ³Å¼ne klasy (Dog, Cat, Bird),
A w kodzie operujesz na wskaÅºnikach do Animal, nie martwiÄ…c siÄ™, czym one sÄ….

ğŸ”¹ Podsumowanie w 2 zdaniach
Polimorfizm = ta sama funkcja (makeSound) dziaÅ‚a rÃ³Å¼nie w zaleÅ¼noÅ›ci od faktycznego obiektu.
virtual = sÅ‚owo-klucz, ktÃ³re sprawia, Å¼e w czasie dziaÅ‚ania programu wybierana jest metoda klasy pochodnej, a nie bazowej.

Dziedziczenie â€“ w nagÅ‚Ã³wku Cat.hpp klasa Cat nie dziedziczy po Animal. Masz:
class Cat

powinno byÄ‡:
class Cat : public Animal

Bez tego Cat nie jest Animal i nie zadziaÅ‚a polimorfizm.

Animal
 â”œâ”€ Cat
 â””â”€ Dog
Cat i Dog dziedziczÄ… po Animal.
W C++, kiedy tworzysz obiekt klasy pochodnej (np. Cat), najpierw wywoÅ‚uje siÄ™ konstruktor klasy bazowej (Animal), a potem konstruktor klasy pochodnej (Cat).
Dlatego dla kaÅ¼dego Cat lub Dog zobaczysz najpierw Animal constructor called, potem Cat constructor called lub Dog constructor called.

Animal* c = new Cat();
WywoÅ‚uje Animal() â†’ â€Animal constructor calledâ€
NastÄ™pnie wywoÅ‚uje Cat() â†’ â€Cat constructor calledâ€
Podobnie dla Dog.

3ï¸âƒ£ KolejnoÅ›Ä‡ dziaÅ‚ania Twojego programu
Tworzenie obiektÃ³w Animal, Cat, Dog:
Konstruktor klasy bazowej (Animal) wywoÅ‚any dla kaÅ¼dego obiektu dziedziczÄ…cego.
Konstruktor klasy pochodnej (Cat, Dog) wywoÅ‚any zaraz po tym.
WywoÅ‚anie getType():
Zwraca type zwierzÄ™cia (Cat lub Dog).
WywoÅ‚anie makeSound():
DziÄ™ki virtual w klasie bazowej, wywoÅ‚uje wÅ‚aÅ›ciwÄ… metodÄ™ klasy pochodnej.
Animal â†’ "Animal makes a generic sound"
Cat â†’ "Meow Meow"
Dog â†’ "Woof Woof"

Tworzenie obiektÃ³w WrongAnimal i WrongCat:
Brak virtual w makeSound() â†’ wywoÅ‚anie przez wskaÅºnik do WrongAnimal zawsze uÅ¼yje metody WrongAnimal.
Konstruktor bazowy (WrongAnimal) wywoÅ‚any najpierw, potem WrongCat.
WywoÅ‚anie getType() i makeSound() dla â€œzÅ‚ychâ€ zwierzÄ…t:
Typy zwierzÄ…t sÄ… poprawne (WrongCat), ale dÅºwiÄ™k nie zmienia siÄ™ przez brak virtual.
Usuwanie obiektÃ³w (delete):
Destruktory wywoÅ‚ujÄ… siÄ™ w odwrotnej kolejnoÅ›ci niÅ¼ konstruktory:
najpierw destruktor klasy pochodnej, potem klasy bazowej.
To jest standardowy mechanizm w C++ dla hierarchii klas.

4ï¸âƒ£ Podsumowanie reguÅ‚
Konstruktor bazowy wywoÅ‚uje siÄ™ zawsze przed konstruktorem pochodnym.
Destruktor pochodny wywoÅ‚uje siÄ™ najpierw, potem bazowy.
virtual umoÅ¼liwia polimorficzne wywoÅ‚anie funkcji (makeSound) przez wskaÅºnik klasy bazowej.
Brak virtual â†’ wywoÅ‚anie metody klasy bazowej niezaleÅ¼nie od rzeczywistego typu obiektu.

Virtual pozwala wywoÅ‚aÄ‡ metodÄ™ klasy pochodnej nawet, gdy wskaÅºnik ma typ klasy bazowej (Animal*).
Bez virtual wywoÅ‚ywana byÅ‚aby metoda klasy bazowej.

Konstruktor kopiujÄ…cy kopiuje wszystkie atrybuty obiektu, np. type.
Operator= przypisuje zawartoÅ›Ä‡ innego obiektu do aktualnego i zwraca *this, Å¼eby umoÅ¼liwiÄ‡ Å‚aÅ„cuchowe przypisania (a = b = c).