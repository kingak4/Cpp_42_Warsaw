ğŸ”¹ Exercise 01
Katalog do oddania: ex01/
Pliki do oddania: Wszystkie z poprzedniego Ä‡wiczenia + nowe pliki .cpp i .hpp.
Instrukcje krok po kroku:
Implementacja klasy Brain:
Klasa ma tablicÄ™ 100 stringÃ³w o nazwie ideas.

Dog i Cat:
KaÅ¼dy obiekt Dog i Cat ma prywatny wskaÅºnik Brain*.
W konstruktorze Dog i Cat: tworzymy nowy Brain przy pomocy new Brain().
W destruktorze Dog i Cat: usuwamy Brain przez delete, Å¼eby uniknÄ…Ä‡ wyciekÃ³w pamiÄ™ci.

W funkcji main:
Tworzymy i wypeÅ‚niamy tablicÄ™ obiektÃ³w Animal.
PoÅ‚owa elementÃ³w â†’ Dog, poÅ‚owa â†’ Cat.
Na koÅ„cu programu: usuwamy wszystkie obiekty przez delete, ale uÅ¼ywamy wskaÅºnikÃ³w typu Animal*.
WÅ‚aÅ›ciwe destruktory muszÄ… byÄ‡ wywoÅ‚ane w odpowiedniej kolejnoÅ›ci.
Sprawdzamy wycieki pamiÄ™ci.
Kopia obiektÃ³w:
Kopie Dog i Cat nie mogÄ… byÄ‡ pÅ‚ytkie (shallow copy).
Trzeba przetestowaÄ‡, czy kopiowanie Brain dziaÅ‚a jako deep copy

Co masz zrobiÄ‡:
UtworzyÄ‡ klasÄ™ Brain z tablicÄ… std::string ideas[100].
Dog i Cat majÄ… mieÄ‡ wskaÅºnik do Brain.
W konstruktorze Dog/Cat robisz new Brain(), a w destruktorze delete Brain.

W main() utwÃ³rz tablicÄ™ wskaÅºnikÃ³w Animal* â†’ pÃ³Å‚ psÃ³w, pÃ³Å‚ kotÃ³w.
Na koÅ„cu usuÅ„ wszystko i sprawdÅº, czy destruktory dziaÅ‚ajÄ… poprawnie.
Zaimplementuj gÅ‚Ä™bokÄ… kopiÄ™ (copy constructor i operator=) â€“ inaczej pies po skopiowaniu bÄ™dzie miaÅ‚ wskaÅºnik do tego samego Brain, co ÅºrÃ³dÅ‚o, i zrobi siÄ™ baÅ‚agan w pamiÄ™ci.

Czego siÄ™ nauczysz:
ZarzÄ…dzanie pamiÄ™ciÄ… dynamicznÄ… w C++ (new/delete).
Rule of Three (destruktor, konstruktor kopiujÄ…cy, operator=).
Testowanie deep copy vs shallow copy.


this->ideas = other.ideas;
âŒ nie zadziaÅ‚a tak, jak myÅ›lisz â€“ bo:
ideas to tablica o staÅ‚ym rozmiarze (100), a w C++ tablic nie moÅ¼na przypisywaÄ‡ wprost (= nie jest dozwolone dla caÅ‚ych tablic).
Kompilator wywali bÅ‚Ä…d typu: array type 'std::string[100]' is not assignable.

Co siÄ™ dzieje:
type = "Cat"; â€“ ustawiasz typ kota, Å¼eby metoda getType() zwracaÅ‚a poprawnÄ… nazwÄ™.
brain = new Brain(); â€“ tu jest kluczowe:
Tworzysz nowy obiekt klasy Brain na stercie (heap), a nie na stosie.
DziÄ™ki temu kaÅ¼da instancja Cat ma wÅ‚asny, niezaleÅ¼ny Brain.
new zwraca wskaÅºnik, ktÃ³ry przypisujesz do pola brain (private Brain* brain;).
std::cout â€“ komunikat pokazuje, Å¼e konstruktor zostaÅ‚ wywoÅ‚any.

Dlaczego uÅ¼ywamy new?
Bo Brain ma byÄ‡ dynamiczny, a jego rozmiar moÅ¼e byÄ‡ duÅ¼y (100 stringÃ³w).
Pozwala na tworzenie deep copy, czyli kaÅ¼dy kot ma wÅ‚asny Brain, nie dzieli go z innymi kotami.

Operator przypisania Cat& Cat::operator=(const Cat &other)
Animal::operator=(other); â€“ kopiujesz zawartoÅ›Ä‡ klasy bazowej.
if (this != &other) â€“ sprawdzasz, czy kopiujesz samÄ… siebie.
delete(brain); â€“ usuwasz poprzedni Brain kota (waÅ¼ne, Å¼eby nie byÅ‚o wyciekÃ³w pamiÄ™ci).
brain = new Brain(*other.brain); â€“ tworzysz nowÄ…, gÅ‚Ä™bokÄ… kopiÄ™ Brain z obiektu ÅºrÃ³dÅ‚owego.
return(*this); â€“ zwracasz obiekt, zgodnie z konwencjÄ… operatora przypisania.
Dlaczego deep copy jest waÅ¼ne?
KaÅ¼dy kot ma niezaleÅ¼ny zestaw ideas.
Gdyby nie byÅ‚o deep copy, zmiany w ideas jednego kota wpÅ‚ynÄ™Å‚yby na drugiego.

Destruktor Cat::~Cat()
Co siÄ™ dzieje:
delete(brain); â€“ usuwa obiekt Brain z pamiÄ™ci dynamicznej.
DziÄ™ki temu nie ma wyciekÃ³w pamiÄ™ci.
std::cout â€“ pokazuje, Å¼e destruktor zostaÅ‚ wywoÅ‚any.

ğŸ”¹ Podsumowanie Brain w Cat:
Brain jest dynamiczny (new Brain()), bo chcemy deep copy i duÅ¼Ä… tablicÄ™ stringÃ³w.
Konstruktor kopiujÄ…cy kota robi gÅ‚Ä™bokÄ… kopiÄ™ Brain, Å¼eby dwa koty nie dzieliÅ‚y tego samego obiektu.
Operator przypisania teÅ¼ musi robiÄ‡ deep copy i usuwaÄ‡ stary Brain.
Destruktor usuwa Brain, Å¼eby nie byÅ‚o wyciekÃ³w pamiÄ™ci.


Polimorfizm i dziedziczenie â€“ Kot i Pies dziedziczÄ… po klasie bazowej Animal i dziÄ™ki temu moÅ¼emy przechowywaÄ‡ je w tablicy wskaÅºnikÃ³w do Animal oraz wywoÅ‚ywaÄ‡ wirtualne funkcje (makeSound(), getType()) bez ryzyka pomyÅ‚ki.
Kompozycja obiektu â€“ KaÅ¼dy Kot i Pies posiada w sobie wÅ‚asny obiekt Brain, czyli â€œzagnieÅ¼dÅ¼onyâ€ obiekt, ktÃ³ry przechowuje tablicÄ™ ideas. Pokazuje to, Å¼e obiekty pochodne mogÄ… mieÄ‡ wÅ‚asne, prywatne zasoby.
Dynamiczna alokacja i zarzÄ…dzanie pamiÄ™ciÄ… â€“ Brain jest tworzony przez new w konstruktorze i musimy pamiÄ™taÄ‡ o delete w destruktorze. To uczy poprawnego zarzÄ…dzania pamiÄ™ciÄ… i zapobiega wyciekom.
Deep copy â€“ KopiujÄ…c psa lub kota, tworzymy nowy obiekt Brain, a nie kopiujemy wskaÅºnika. DziÄ™ki temu zmiany w jednej kopii nie wpÅ‚ywajÄ… na oryginaÅ‚.
Testy i bezpieczeÅ„stwo â€“ Program testuje konstruktor, destruktor, przypisanie i dziaÅ‚anie funkcji wirtualnych oraz pokazuje poprawne uÅ¼ycie tablicy obiektÃ³w w polimorficznym kontekÅ›cie.
MoÅ¼na powiedzieÄ‡, Å¼e zadanie uczy 3 kluczowych rzeczy w C++: dziedziczenie, kompozycjÄ™ obiektÃ³w i zarzÄ…dzanie pamiÄ™ciÄ… w klasach z dynamicznie alokowanymi zasobami.

            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚  Animal   â”‚
            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
            â”‚ - type    â”‚   <- protected
            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
            â”‚ +getType()â”‚
            â”‚ +makeSound()â”‚ (virtual)
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â–²
                 â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚                      â”‚
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚   Dog     â”‚          â”‚   Cat     â”‚
 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 â”‚ - brain*  â”‚          â”‚ - brain*  â”‚
 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 â”‚ +makeSound()â”‚        â”‚ +makeSound()â”‚
 â”‚ +getBrain() â”‚        â”‚ +getBrain() â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â–²
                 â”‚
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚  Brain  â”‚
           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
           â”‚ -ideas[100]â”‚
           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
           â”‚ +getIdeas()â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
