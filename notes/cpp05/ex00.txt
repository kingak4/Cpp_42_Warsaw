ğŸ’¼  WyjaÅ›nienie projektu i jego celu

Ten moduÅ‚ to symulacja biurokratycznego Å›wiata, w ktÃ³rym:
sÄ… urzÄ™dnicy (Bureaucrat),
sÄ… formularze (Form, AForm, itd.),
i reguÅ‚y oraz wyjÄ…tki, ktÃ³re sterujÄ… ich interakcjami.

Celem moduÅ‚u jest:
zrozumienie klas, dziedziczenia, polimorfizmu,
nauka rzucania i obsÅ‚ugi wyjÄ…tkÃ³w (try/catch),
oraz projektowania hierarchii klas w sposÃ³b czysty i logiczny.

ğŸ§© ex00 â€“ Bureaucrat

Cel: stworzyÄ‡ klasÄ™ Bureaucrat z:
staÅ‚Ä… nazwÄ… (const std::string name)
zmiennym stopniem (grade, od 1 do 150)

Zasady:
Gdy grade < 1 â†’ rzuÄ‡ GradeTooHighException
Gdy grade > 150 â†’ rzuÄ‡ GradeTooLowException

Funkcje:
getName(), getGrade()
incrementGrade() â†’ zmniejsza wartoÅ›Ä‡ (bo 1 to najwyÅ¼szy)
decrementGrade() â†’ zwiÄ™ksza wartoÅ›Ä‡

PrzeciÄ…Å¼ operator << do wypisywania:
<name>, bureaucrat grade <grade>.

Przetestuj wyjÄ…tki i dziaÅ‚anie inkrementacji/dekrementacji.

ğŸ” Uczysz siÄ™:
konstruktorÃ³w, destruktorÃ³w,
wyjÄ…tkÃ³w (throw, try/catch),
operatorÃ³w (<<).

âš™ï¸ Wymagania dotyczÄ…ce klasy Bureaucrat:
1. Atrybuty:
const std::string name â†’ imiÄ™ urzÄ™dnika (staÅ‚e â€“ nie moÅ¼na go zmieniÄ‡ po stworzeniu obiektu)
int grade â†’ poziom/stopieÅ„ urzÄ™dnika (1 = najwyÅ¼szy, 150 = najniÅ¼szy)

2. Zasady walidacji:
JeÅ›li sprÃ³bujesz stworzyÄ‡ urzÄ™dnika z grade < 1 â†’ rzuÄ‡ wyjÄ…tek Bureaucrat::GradeTooHighException
JeÅ›li grade > 150 â†’ rzuÄ‡ wyjÄ…tek Bureaucrat::GradeTooLowException
To samo dotyczy sytuacji, gdy modyfikujesz jego grade pÃ³Åºniej (np. w funkcji incrementGrade() lub decrementGrade()).

3. Funkcje czÅ‚onkowskie:
Nazwa funkcji	Opis
getName()	zwraca imiÄ™ urzÄ™dnika
getGrade()	zwraca aktualny stopieÅ„
incrementGrade()	zmniejsza wartoÅ›Ä‡ grade o 1 (bo im mniejsza liczba, tym wyÅ¼szy stopieÅ„). JeÅ›li wyjdzie poza 1 â†’ wyjÄ…tek
decrementGrade()	zwiÄ™ksza wartoÅ›Ä‡ grade o 1 (czyli obniÅ¼a rangÄ™). JeÅ›li przekroczy 150 â†’ wyjÄ…tek

4. WyjÄ…tki:

Musisz stworzyÄ‡ dwie klasy wyjÄ…tkÃ³w wewnÄ…trz klasy Bureaucrat:
class GradeTooHighException : public std::exception
class GradeTooLowException : public std::exception
KaÅ¼da z nich ma nadpisywaÄ‡ funkcjÄ™ what() i zwracaÄ‡ odpowiedni komunikat, np.:

const char* what() const throw() {
    return "Grade is too high!";
}

5. Operator wypisywania:
Masz przeciÄ…Å¼yÄ‡ operator <<:
std::ostream& operator<<(std::ostream& os, const Bureaucrat& b);
aby moÅ¼na byÅ‚o wypisywaÄ‡ urzÄ™dnika tak:
Bob, bureaucrat grade 42.

6. Testy:

W main.cpp zrÃ³b przykÅ‚ady:
poprawne tworzenie Bureaucrata
prÃ³by stworzenia z bÅ‚Ä™dnym grade â†’ Å‚apanie wyjÄ…tkÃ³w
testy incrementGrade() i decrementGrade()
std::cout << bureaucrat; (operator <<)


ğŸ§© 2. Operator <<

Zobacz, w zadaniu masz wymagany format:

<name>, bureaucrat grade <grade>.

To ma siÄ™ pojawiaÄ‡, kiedy uÅ¼yjesz:
std::cout << someBureaucrat;

ğŸ“˜ Co to znaczy technicznie?

W C++ moÅ¼esz przeciÄ…Å¼yÄ‡ operator <<, Å¼eby dziaÅ‚aÅ‚ dla wÅ‚asnych klas.
To nie jest metoda klasy, tylko osobna funkcja, ktÃ³ra:
przyjmuje jako pierwszy argument std::ostream & (czyli np. std::cout)
przyjmuje jako drugi argument Twojego Bureaucrata
zwraca std::ostream &, Å¼eby moÅ¼na byÅ‚o pisaÄ‡ std::cout << a << b;

ğŸ“˜ Deklaracja operatora w Twoim nagÅ‚Ã³wku:
W pliku Bureaucrat.hpp dodajesz to poza klasÄ…:

std::ostream& operator<<(std::ostream& out, const Bureaucrat& b);

ğŸ“˜ Co ma robiÄ‡ ten operator:
Ma po prostu wypisaÄ‡ dane urzÄ™dnika w podanym formacie:
<name>, bureaucrat grade <grade>.
np.
Bob, bureaucrat grade 42.

ğŸ§©  Klasy wyjÄ…tkÃ³w
ğŸ”¹ Po co to jest?
W Twoim programie â€urzÄ™dnikâ€ (Bureaucrat) ma mieÄ‡ stopieÅ„ (grade) miÄ™dzy 1 a 150.

JeÅ›li ktoÅ› sprÃ³buje stworzyÄ‡ urzÄ™dnika z grade = 0 albo 151,
albo uÅ¼yje incrementGrade() i przekroczy granice â€” musisz rzuciÄ‡ wyjÄ…tek.
Czyli przerwaÄ‡ normalne dziaÅ‚anie programu i poinformowaÄ‡ uÅ¼ytkownika o bÅ‚Ä™dzie.

ğŸ”¹ Dlaczego klasy wewnÄ…trz Bureaucrat?
Bo te wyjÄ…tki dotyczÄ… tylko klasy Bureaucrat.
Nie chcesz ich uÅ¼ywaÄ‡ nigdzie indziej.
Dlatego umieszcza siÄ™ je w Å›rodku klasy, jako coÅ› w stylu â€czÄ™Å›ci mechanizmuâ€.

ğŸ”¹ Jak to wyglÄ…da logicznie
PomyÅ›l o tym tak:

klasa Bureaucrat:
    ma dwie maÅ‚e klasy wewnÄ™trzne:
        - GradeTooHighException
        - GradeTooLowException

KaÅ¼da z nich mÃ³wi coÅ› w stylu:
â€Ej, prÃ³bujesz ustawiÄ‡ grade zbyt wysoki / zbyt niski.â€

ğŸ”¹ Po co metoda what()?
To standard w C++ â€” kaÅ¼da klasa wyjÄ…tku ma metodÄ™ what(),
ktÃ³ra zwraca wiadomoÅ›Ä‡ tekstowÄ…, gdy zÅ‚apiesz wyjÄ…tek w try / catch.

PrzykÅ‚ad w myÅ›leniu (nie kod):
sprÃ³buj:
    utwÃ³rz Bureaucrat z grade = 200
zÅ‚ap wyjÄ…tek:
    wyÅ›wietl bÅ‚Ä…d_what()

i wtedy pojawi siÄ™ np.:
Grade is too low

Operator << jako friend
ğŸ”¹ Po co to jest?
Operator << (czytany jako â€stream insertionâ€) sÅ‚uÅ¼y do drukowania obiektÃ³w Twojej klasy przez std::cout.

Chcesz napisaÄ‡:
std::cout << kinga;

i dostaÄ‡ np.:
Kinga, bureaucrat grade 5.

ğŸ”¹ Dlaczego friend?
name i grade sÄ… prywatne (private),
wiÄ™c kod spoza klasy nie moÅ¼e ich uÅ¼ywaÄ‡ bezpoÅ›rednio.

Ale operator << jest funkcjÄ… spoza klasy.
Å»eby mÃ³gÅ‚ zajrzeÄ‡ do tych pÃ³l (name, grade), musisz mu pozwoliÄ‡ â€” i to robisz wÅ‚aÅ›nie sÅ‚owem kluczowym friend.

ğŸ”¹ Jak to zapisaÄ‡ logicznie (pseudokod)
W Å›rodku Twojej klasy, w sekcji public, dopiszesz:

friend std::ostream& operator<<(std::ostream& out, const Bureaucrat& b);

To mÃ³wi kompilatorowi:
â€Ta funkcja operator<< jest moim przyjacielem,
wiÄ™c moÅ¼e mieÄ‡ dostÄ™p do moich prywatnych pÃ³l.â€


ğŸ§© 1ï¸âƒ£ Dlaczego klasy wyjÄ…tkÃ³w sÄ… â€wewnÄ…trzâ€ klasy Bureaucrat
Nie robimy dwÃ³ch osobnych plikÃ³w, bo:
te wyjÄ…tki sÄ… Å›ciÅ›le powiÄ…zane tylko z jednÄ… klasÄ…,
nie chcesz ich uÅ¼ywaÄ‡ w innych projektach,
dziÄ™ki temu zachowujesz porzÄ…dek â€” wyjÄ…tek jest czÄ™Å›ciÄ… Bureaucrat, a nie niezaleÅ¼nym bytem.

Inaczej mÃ³wiÄ…c:
â¡ï¸ one sÄ… â€czÄ™Å›ciÄ… mechanizmuâ€ Bureaucrat,
tak jak Å›ruby sÄ… czÄ™Å›ciÄ… silnika â€” nie majÄ… sensu bez niego.

ğŸ§© 2ï¸âƒ£ Co one robiÄ… w praktyce
WewnÄ…trz Twojego kodu, gdy grade bÄ™dzie za duÅ¼y lub za maÅ‚y, nie chcesz koÅ„czyÄ‡ programu, tylko rzuciÄ‡ wyjÄ…tek, ktÃ³ry potem moÅ¼esz zÅ‚apaÄ‡ (try/catch).
Dlatego kaÅ¼da taka wewnÄ™trzna klasa ma jedno zadanie
â€OpisaÄ‡ konkretny rodzaj bÅ‚Ä™du i daÄ‡ komunikat, ktÃ³ry program moÅ¼e pÃ³Åºniej odczytaÄ‡.â€
To jest wÅ‚aÅ›nie rola what() â€” ma zwrÃ³ciÄ‡ tekstowy opis bÅ‚Ä™du.

Co znaczy to â€publicâ€
To jest poziom dostÄ™pu.
JeÅ›li napiszesz public, to Twoja klasa zachowa publiczne metody rodzica.
Czyli np. metoda what() z std::exception bÄ™dzie dostÄ™pna,
i moÅ¼esz jÄ… nadpisaÄ‡ wÅ‚asnÄ… wersjÄ….

1ï¸âƒ£ Typ zwracany przez what()
Funkcja what() musi zwracaÄ‡ const char* (czyli wskaÅºnik na tekst).
Nie moÅ¼e byÄ‡ typu void.

Dlaczego?
â†’ Bo funkcja what() w klasie std::exception (z ktÃ³rej dziedziczysz) ma wÅ‚aÅ›nie taki typ.
JeÅ›li dasz inny, to nie bÄ™dzie nadpisywaÄ‡ poprawnie oryginalnej wersji, a to spowoduje ostrzeÅ¼enie lub bÅ‚Ä…d przy kompilacji.

2ï¸âƒ£ const przy what()
what() musi byÄ‡ const, bo nie moÅ¼e zmieniaÄ‡ obiektu wyjÄ…tku.
(W skrÃ³cie: metoda ma tylko informowaÄ‡, nie modyfikowaÄ‡).

1ï¸âƒ£ SkÄ…d w ogÃ³le what()?

std::exception to bazowa klasa dla wszystkich wyjÄ…tkÃ³w w C++.
JednÄ… z jej publicznych metod jest wÅ‚aÅ›nie:
virtual const char* what() const noexcept;
Jej zadanie: zwraca tekstowy opis wyjÄ…tku, ktÃ³ry moÅ¼na wyÅ›wietliÄ‡ w catch.
Dlatego gdy tworzysz wÅ‚asny wyjÄ…tek, np. GradeTooHighException, nadpisujesz what(), Å¼eby TwÃ³j wyjÄ…tek teÅ¼ miaÅ‚ swÃ³j opis.

2ï¸âƒ£ Dlaczego const char*, a nie std::string?

BezpieczeÅ„stwo w pamiÄ™ci: std::exception::what() musi dziaÅ‚aÄ‡ zawsze i nie moÅ¼e rzucaÄ‡ nowych wyjÄ…tkÃ³w.
const char* jest â€statycznymâ€ stringiem w pamiÄ™ci â€“ znasz "tekst" w c++? To wÅ‚aÅ›nie const char*.
Nie tworzymy nowego obiektu typu std::string w funkcji, wiÄ™c nic siÄ™ nie psuje w momencie rzucania wyjÄ…tku.
std::string moÅ¼e alokowaÄ‡ pamiÄ™Ä‡ dynamicznie, a jeÅ›li coÅ› pÃ³jdzie nie tak przy alokacji w what(), moglibyÅ›my wpaÅ›Ä‡ w kolejny wyjÄ…tek podczas obsÅ‚ugi wyjÄ…tku â€“ koszmar C++!

3ï¸âƒ£ Dlaczego const i noexcept?

const: metoda nie zmienia stanu obiektu wyjÄ…tku. WyjÄ…tek juÅ¼ istnieje, my tylko chcemy przeczytaÄ‡ tekst.
noexcept: gwarancja, Å¼e funkcja nigdy nie rzuci wyjÄ…tku.
To jest bardzo waÅ¼ne w catch, bo jeÅ›li what() rzuci wyjÄ…tek w trakcie obsÅ‚ugi innego wyjÄ…tku, program zazwyczaj koÅ„czy siÄ™ katastrofalnie.

4ï¸âƒ£ Jak to dziaÅ‚a w pamiÄ™ci

WyobaÅº sobie:
throw Bureaucrat::GradeTooHighException();
Tworzony jest obiekt wyjÄ…tku na stosie lub w pamiÄ™ci automatycznej.
Kiedy wyÅ‚apiesz go w catch:

catch (std::exception &e)
{
    std::cout << e.what() << std::endl;
}
WywoÅ‚ywana jest metoda what() tego obiektu.
what() zwraca adres statycznego tekstu "Grade too high" (albo innego, ktÃ³ry ustalisz).
DziÄ™ki temu moÅ¼na bezpiecznie wyÅ›wietliÄ‡ komunikat, nie ryzykujÄ…c kolejnego wyjÄ…tku ani bÅ‚Ä™du w pamiÄ™ci.

5ï¸âƒ£ Logika implementacji
W ciele klasy wyjÄ…tkÃ³w robimy coÅ› jak â€staÅ‚a tablica znakÃ³w w pamiÄ™ciâ€:
what() -> zwraca "opis bÅ‚Ä™du"

Nie tworzymy nowych stringÃ³w dynamicznie.
DziÄ™ki temu jest zgodne ze standardem C++ i moÅ¼esz uÅ¼ywaÄ‡ catch(std::exception &e) uniwersalnie.

6ï¸âƒ£ Jak o tym myÅ›leÄ‡ â€dla siebieâ€

const char* â†’ statyczny, niezmienny tekst w pamiÄ™ci.
what() â†’ informacja tylko do odczytu o tym, co poszÅ‚o Åºle.
Dziedziczenie po std::exception â†’ TwÃ³j wyjÄ…tek zachowuje siÄ™ jak wszystkie inne wyjÄ…tki w C++.
DziÄ™ki temu w main() moÅ¼esz pisaÄ‡:
try {
    // coÅ›, co moÅ¼e rzuciÄ‡ Bureaucrat::GradeTooHighException
} catch (std::exception &e) {
    std::cout << e.what() << std::endl;
}
I wszystko dziaÅ‚a bezpiecznie i elegancko.

ğŸ”¹ Proste notatki co do funkcji

Konstruktor gÅ‚Ã³wny
Tworzy obiekt z imieniem i grade.
Sprawdza poprawnoÅ›Ä‡ grade i rzuca wyjÄ…tki.

Konstruktor kopiujÄ…cy
Tworzy kopiÄ™ istniejÄ…cego obiektu.
Kopiuje wszystkie pola, w tym const name.

Operator przypisania
ZastÄ™puje wartoÅ›ci w istniejÄ…cym obiekcie wartoÅ›ciami z innego.
Nie moÅ¼emy zmieniaÄ‡ const name, wiÄ™c kopiujemy tylko grade.
Zwraca referencjÄ™ do siebie, Å¼eby umoÅ¼liwiÄ‡ Å‚aÅ„cuchowe przypisania.

Destruktor
SprzÄ…ta obiekt.
W tym projekcie nie trzeba zwalniaÄ‡ pamiÄ™ci dynamicznej (nie uÅ¼ywasz new), wiÄ™c moÅ¼e byÄ‡ pusty.

1ï¸âƒ£ Co to jest lista inicjalizacyjna?
W C++ lista inicjalizacyjna to specjalny zapis po nazwie konstruktora, w ktÃ³rym inicjalizujesz pola obiektu zanim wejdziesz do ciaÅ‚a konstruktora.
Jest konieczna dla pÃ³l const i referencji (&), bo nie da siÄ™ ich przypisaÄ‡ w ciele konstruktora.
Daje teÅ¼ czÄ™sto lepszÄ… wydajnoÅ›Ä‡, bo pola sÄ… tworzone od razu z odpowiedniÄ… wartoÅ›ciÄ…, zamiast tworzyÄ‡ puste i potem przypisywaÄ‡.

Lista inicjalizacyjna jest zawsze po nazwie konstruktora, przed {}.
SÅ‚uÅ¼y do ustawienia const, referencji i wszystkich pÃ³l, ktÃ³re muszÄ… byÄ‡ stworzone od razu.
Pozwala teÅ¼ ustawiÄ‡ wartoÅ›ci innych pÃ³l, zanim program wejdzie do Å›rodka konstruktora.
Daje bezpieczeÅ„stwo â€“ nie da siÄ™ zapomnieÄ‡ o przypisaniu const.