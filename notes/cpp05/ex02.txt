ğŸ§© ex02 â€“ AForm + konkretne formularze

Cel: stworzyÄ‡ bazowÄ… klasÄ™ abstrakcyjnÄ… AForm, po ktÃ³rej dziedziczÄ… konkretne formularze:

ShrubberyCreationForm
RobotomyRequestForm
PresidentialPardonForm
KaÅ¼da ma inny cel i wymagany poziom:

| Formularz              | Grade do podpisu | Grade do wykonania | Akcja                                                 |
| ---------------------- | ---------------- | ------------------ | ----------------------------------------------------- |
| ShrubberyCreationForm  | 145              | 137                | Tworzy plik `<target>_shrubbery` z ASCII drzewami ğŸŒ³  |
| RobotomyRequestForm    | 72               | 45                 | 50% szansy na sukces â€robotomizacjiâ€ ğŸ¤–               |
| PresidentialPardonForm | 25               | 5                  | Informuje o uÅ‚askawieniu przez Zaphoda Beeblebroxa ğŸ‘‘ |


KaÅ¼dy formularz ma funkcjÄ™ execute(Bureaucrat const &executor) const
Bureaucrat dostaje executeForm() â€“ prÃ³buje wykonaÄ‡ dany formularz.

ğŸ” Uczysz siÄ™:
dziedziczenia,
klas abstrakcyjnych (= 0),
polimorfizmu,
pracy z plikami (ofstream).

Dlaczego AForm ma byÄ‡ klasÄ… abstrakcyjnÄ… â€” konkretne powody i zastosowania
To znaczy, Å¼e AForm to szablon (plan), a nie gotowa rzecz.
WyobraÅº sobie, Å¼e masz urzÄ™dowy system, w ktÃ³rym rÃ³Å¼ni urzÄ™dnicy obsÅ‚ugujÄ… rÃ³Å¼ne formularze:

jeden sadzi drzewka (ShrubberyCreationForm),
drugi robotyzuje (RobotomyRequestForm),
trzeci uÅ‚askawia (PresidentialPardonForm).

Ale kaÅ¼dy formularz ma pewne wspÃ³lne zasady:
ma nazwÄ™,
ma poziomy uprawnieÅ„ do podpisu i wykonania,
moÅ¼e byÄ‡ podpisany lub nie,
moÅ¼na go prÃ³bowaÄ‡ wykonaÄ‡,
moÅ¼e rzucaÄ‡ wyjÄ…tki.

ğŸ’¡ AForm to klasa, ktÃ³ra definiuje te wspÃ³lne rzeczy.
Ale sama nie robi Å¼adnego konkretnego dziaÅ‚ania, bo nie wiadomo, co miaÅ‚aby zrobiÄ‡ â€” posadziÄ‡ drzewko, zrobotyzowaÄ‡ kogoÅ› czy uÅ‚askawiÄ‡?
Dlatego AForm jest abstrakcyjna â€” mÃ³wi:
â€KaÅ¼da konkretna forma musi mieÄ‡ wÅ‚asny sposÃ³b wykonania (action()). Ja tylko okreÅ›lam zasady.â€

ğŸ”¹ PrzykÅ‚ad z Å¼ycia (bardzo obrazowy)
WyobraÅº sobie formularz urzÄ™dowy:
â€Formularz do zaÅ‚atwienia sprawy.â€
Wiesz, Å¼e kaÅ¼dy formularz musi mieÄ‡:

pole z nazwiskiem,
pole z numerem sprawy,
podpis urzÄ™dnika.

Ale nie wiesz, do czego on sÅ‚uÅ¼y â€” moÅ¼e do podatkÃ³w, moÅ¼e do wniosku o paszport, moÅ¼e o pozwolenie na budowÄ™.
WiÄ™c taki formularz jest abstrakcyjny â€” sam w sobie bezuÅ¼yteczny.
Dopiero, gdy powstaje konkretny:

â€Wniosek o paszportâ€ â†’ (czyli PresidentialPardonForm)
â€ZgÅ‚oszenie budowyâ€ â†’ (czyli ShrubberyCreationForm)
â€Wniosek o robotyzacjÄ™â€ â†’ (czyli RobotomyRequestForm)
â€” wtedy wiadomo, co konkretnie robi ten formularz, czyli jaka jest jego akcja.

ğŸ”¹ Polimorfizm â€” najprostsze wyjaÅ›nienie
Polimorfizm = â€rÃ³Å¼ne zachowania przez ten sam interfejsâ€.
Czyli moÅ¼esz mieÄ‡ np. listÄ™ formularzy (AForm*),
a mimo to kaÅ¼dy z nich wykona coÅ› innego po wywoÅ‚aniu execute().

PrzykÅ‚ad w uproszczonym pseudokodzie:
AForm* forms[3] = {
    new ShrubberyCreationForm("home"),
    new RobotomyRequestForm("Bender"),
    new PresidentialPardonForm("Arthur")
};

for (int i = 0; i < 3; i++)
    forms[i]->execute(bureaucrat);

Tutaj:
dla 1. elementu â€“ posadzi drzewko,
dla 2. â€“ sprÃ³buje robotyzowaÄ‡,
dla 3. â€“ wypisze uÅ‚askawienie.

Ty nie musisz wiedzieÄ‡, ktÃ³ra to klasa.
Program sam wie, bo kaÅ¼da forma ma swojÄ… wersjÄ™ execute().
To wÅ‚aÅ›nie polimorfizm â€” ta sama funkcja (execute()), ale rÃ³Å¼ne zachowanie zaleÅ¼nie od rodzaju formularza.

ğŸ”¹ Co znaczy â€wspÃ³lny interfejsâ€?
To znaczy, Å¼e kaÅ¼da forma ma te same metody, np.:
beSigned()
execute()
getName()
getTarget()
DziÄ™ki temu moÅ¼esz napisaÄ‡ kod, ktÃ³ry dziaÅ‚a z dowolnym formularzem â€” nie musisz pisaÄ‡ osobno dla kaÅ¼dej klasy.

ğŸ”¹ Co znaczy â€separation of concernsâ€ â€” po ludzku

PodziaÅ‚ obowiÄ…zkÃ³w.
Czyli:
AForm zajmuje siÄ™ biurokratycznÄ… stronÄ… (czy podpisano, czy grade jest ok).
konkretna forma (Shrubbery, Robotomy, Presidential) zajmuje siÄ™ tym, co siÄ™ dzieje po wykonaniu.

Tak jak w urzÄ™dzie:
Sekretarka sprawdza, czy wniosek jest kompletny (czy podpisany, czy masz wymagany dokument).
Dopiero potem urzÄ™dnik wykonuje czynnoÅ›Ä‡ (np. wydaje paszport).

ğŸ”¹ Co daje to Tobie jako programiÅ›cie?
âœ… MoÅ¼esz Å‚atwo dodawaÄ‡ nowe formularze, np. MarriageApprovalForm, SpaceTravelForm, itp.
Nie musisz nic zmieniaÄ‡ w Bureaucrat ani w AForm. Po prostu dodajesz nowÄ… klasÄ™ dziedziczÄ…cÄ… i piszesz nowÄ… action().
âœ… MoÅ¼esz przechowywaÄ‡ rÃ³Å¼ne formularze w jednej tablicy lub wektorze (std::vector<AForm*>).
âœ… Kod jest czystszy, bardziej logiczny i Å‚atwiejszy do utrzymania.

ğŸ”¹ Bardzo krÃ³tka analogia 


Konkretna lista zadaÅ„ do wykonania (skrÃ³t â€” tick-lista)

 Zaprojektuj AForm.hpp z prywatnymi polami, getterami, beSigned(), execute() i czystÄ… wirtualnÄ… action().
 Zadeklaruj i zaimplementuj wyjÄ…tki (GradeTooHigh, GradeTooLow, NotSigned).
 Zaimplementuj AForm.cpp (konstruktor, beSigned, execute).
 Zaktualizuj/zaimplementuj Bureaucrat.hpp/cpp z signForm i executeForm.
 Dodaj nagÅ‚Ã³wki i implementacje ShrubberyCreationForm, RobotomyRequestForm, PresidentialPardonForm.
 Zaimplementuj action() w kaÅ¼dej klasie (zachowanie opisane wyÅ¼ej).
 Napisz main.cpp z wymienionymi testami.
 UzupeÅ‚nij Makefile i przetestuj make, make fclean, make re.
 Uruchom testy; popraw bÅ‚Ä™dy.
 (Opcjonalnie) Uruchom valgrind i popraw wycieki.

 ğŸ§  2. Co to znaczy, Å¼e klasa ma byÄ‡ abstrakcyjna?

Klasa abstrakcyjna to taka, ktÃ³rej nie moÅ¼na tworzyÄ‡ bezpoÅ›rednio (nie moÅ¼na zrobiÄ‡ AForm form;), tylko moÅ¼na dziedziczyÄ‡ z niej.
To osiÄ…gamy przez wprowadzenie co najmniej jednej czysto wirtualnej funkcji, czyli takiej, ktÃ³ra nie ma implementacji w tej klasie,
Samo = 0 na koÅ„cu mÃ³wi kompilatorowi:
â€Ta funkcja musi byÄ‡ zdefiniowana w klasie pochodnej, bo tutaj nie ma ciaÅ‚a.â€

ğŸ§© 5. Co siÄ™ stanie po dodaniu tej funkcji

Twoja klasa AForm stanie siÄ™ abstrakcyjna.
â†’ Nie bÄ™dziesz mogÅ‚a stworzyÄ‡ obiektu typu AForm bezpoÅ›rednio.
Klasy dziedziczÄ…ce (ShrubberyCreationForm, RobotomyRequestForm, PresidentialPardonForm)
bÄ™dÄ… musiaÅ‚y zaimplementowaÄ‡ tÄ™ funkcjÄ™, bo inaczej one teÅ¼ stanÄ… siÄ™ abstrakcyjne.

W praktyce: kaÅ¼da z tych klas zrobi coÅ› innego w execute():
jedna zapisze do pliku,
inna wypisze komunikat lub losowy wynik,
jeszcze inna wypisze informacjÄ™ o uÅ‚askawieniu.

WyobraÅº sobie sytuacjÄ™:
Masz bazowÄ… klasÄ™ AForm.
To taki szablon dla wszystkich formularzy â€” definiuje, czym jest formularz, ale nie mÃ³wi jeszcze co on konkretnie robi.

KaÅ¼dy konkretny formularz (np. ShrubberyCreationForm, RobotomyRequestForm, PresidentialPardonForm) ma robiÄ‡ swojÄ… unikalnÄ… rzecz.
Czyli â€” wszystkie sÄ… formularzami, ale kaÅ¼dy dziaÅ‚a inaczej.

| Klasa                    | Funkcja `execute()`        | Co robi                                   |
| ------------------------ | -------------------------- | ----------------------------------------- |
| `AForm`                  | `= 0` (czyli nie ma ciaÅ‚a) | tylko mÃ³wi â€kaÅ¼dy formularz musi to mieÄ‡â€ |
| `ShrubberyCreationForm`  | wÅ‚asna `execute()`         | tworzy plik z ASCII drzewkiem             |
| `RobotomyRequestForm`    | wÅ‚asna `execute()`         | robi 50% szans robotyzacji                |
| `PresidentialPardonForm` | wÅ‚asna `execute()`         | wypisuje, Å¼e ktoÅ› zostaÅ‚ uÅ‚askawiony      |


ğŸ“¦ Jak to wyglÄ…da w praktyce (na przykÅ‚adzie uÅ¼ycia)
Masz funkcjÄ™ w Bureaucrat:
bureaucrat.executeForm(form);

Tutaj form moÅ¼e byÄ‡ dowolnym typem dziedziczÄ…cym po AForm.
Kompilator wie, Å¼e execute() jest wirtualna, wiÄ™c w momencie uruchomienia programu (runtime) wykona odpowiedniÄ… wersjÄ™ tej funkcji, zaleÅ¼nie od tego, jaki konkretny formularz przekazano.
Czyli:
AForm *f1 = new ShrubberyCreationForm("home");
AForm *f2 = new RobotomyRequestForm("Bender");

bureaucrat.executeForm(*f1); // wywoÅ‚a ShrubberyCreationForm::execute()
bureaucrat.executeForm(*f2); // wywoÅ‚a RobotomyRequestForm::execute()

To jest tzw. polimorfizm â€“ jedno wywoÅ‚anie (execute()) zachowuje siÄ™ inaczej w zaleÅ¼noÅ›ci od konkretnego obiektu.

ğŸ’¡ Proste porÃ³wnanie z Å¼ycia

WyobraÅº sobie AForm jako instrukcjÄ™ dla urzÄ™dnika:
â€KaÅ¼dy formularz ma byÄ‡ wypeÅ‚niony, podpisany i wykonany, ale ja nie mÃ³wiÄ™ co dokÅ‚adnie robisz, tylko Å¼e coÅ› masz zrobiÄ‡.â€

A konkretne formularze (Shrubbery, Robotomy, Presidential) to juÅ¼ rÃ³Å¼ne wersje tej instrukcji:
jeden kaÅ¼e sadziÄ‡ krzaczki ğŸŒ³,
drugi robotyzowaÄ‡ ğŸ¤–,
trzeci uÅ‚askawiaÄ‡ ğŸ‘‘.
KaÅ¼dy wie, co robi, ale wszyscy stosujÄ… siÄ™ do wspÃ³lnego interfejsu AForm.

ğŸ§  Co to jest polimorfizm

SÅ‚owo pochodzi z greckiego:
â€poliâ€ = wiele,
â€morfizmâ€ = formy / ksztaÅ‚ty.
Czyli dosÅ‚ownie:
ğŸ‘‰ â€wiele formâ€ albo â€jedna rzecz, ktÃ³ra moÅ¼e przybieraÄ‡ rÃ³Å¼ne formyâ€.

ğŸ¯ W programowaniu
Polimorfizm oznacza, Å¼e ten sam typ (np. wskaÅºnik do klasy bazowej)
moÅ¼e zachowywaÄ‡ siÄ™ inaczej,
w zaleÅ¼noÅ›ci od tego, jaki obiekt rzeczywiÅ›cie wskazuje.

ğŸ§© Jak to sobie Å‚atwo zapamiÄ™taÄ‡
ZapamiÄ™taj to jednym zdaniem:

Polimorfizm = jedno polecenie, wiele moÅ¼liwych zachowaÅ„.
Albo bardziej obrazowo:
Jeden pilot â€“ rÃ³Å¼ne urzÄ…dzenia.

ğŸ§© Jak to dziaÅ‚a w C++

Wszystko opiera siÄ™ na funkcjach wirtualnych (virtual).
To one pozwalajÄ…, Å¼eby w czasie dziaÅ‚ania programu (runtime)
C++ sprawdziÅ‚, ktÃ³rej wersji funkcji uÅ¼yÄ‡.

Bez virtual â€” kompilator wybiera funkcjÄ™ po typie wskaÅºnika.
Z virtual â€” wybiera jÄ… po rzeczywistym typie obiektu.

ğŸ’¡ 1ï¸âƒ£ Jak dziaÅ‚a zapisywanie pliku w C++

W C++ do pracy z plikami uÅ¼ywasz strumieni plikowych z biblioteki <fstream>.

std::ofstream â†’ otwiera plik do zapisu (output file stream),
std::ifstream â†’ otwiera plik do odczytu (input file stream),
std::fstream â†’ pozwala na czytanie i pisanie.

ğŸ”¹ Jak to Å‚atwo zapamiÄ™taÄ‡

ğŸ‘‰ â€.c_str() = C version of string.â€
czyli â€daj mi wersjÄ™ tego stringa w stylu jÄ™zyka Câ€.
ğŸ”¹ W Twoim przypadku:

Masz:
std::ofstream shrubberyFile(fileName.c_str());

Czyli:

â€OtwÃ³rz plik o nazwie, ktÃ³ra jest zapisana w zmiennej fileName.â€
Bez .c_str() kompilator by siÄ™ wkurzyÅ‚, bo ofstream nie rozumie bezpoÅ›rednio â€nowoczesnegoâ€ napisu (std::string).
On potrzebuje â€staregoâ€ napisu (czyli wÅ‚aÅ›nie tego, co zwraca .c_str()).

ğŸ”¹ Co robi ta klasa?

ShrubberyCreationForm dziedziczy po AForm, wiÄ™c:
ma w sobie wszystko, co ma AForm (np. name, isSigned, signGrade, execGrade, execute() itd.),
ale dodaje coÅ› swojego â€” w tym przypadku target (czyli nazwÄ™ pliku, do ktÃ³rego zapisze drzewko ğŸŒ³).

Dwukropek : po nazwie konstruktora oznacza listÄ™ inicjalizacyjnÄ….
To sposÃ³b, w jaki w C++ ustawiasz wartoÅ›ci pÃ³l (zmiennych czÅ‚onkowskich) od razu przy tworzeniu obiektu.

| Konstruktor      | Kiedy siÄ™ wywoÅ‚uje                    | Co robi                                       |
| ---------------- | ------------------------------------- | --------------------------------------------- |
| **DomyÅ›lny**     | gdy tworzysz obiekt bez argumentÃ³w    | ustawia wartoÅ›ci startowe (â€z gÃ³ry ustaloneâ€) |
| **Z argumentem** | gdy tworzysz obiekt z jakÄ…Å› wartoÅ›ciÄ… | ustawia wartoÅ›ci przekazane przez uÅ¼ytkownika |


| Typ funkcji              | Nazwa                                                 | Co robi                                       |
| ------------------------ | ----------------------------------------------------- | --------------------------------------------- |
| Konstruktor domyÅ›lny     | `ShrubberyCreationForm()`                             | tworzy pusty obiekt z domyÅ›lnymi wartoÅ›ciami  |
| Konstruktor z argumentem | `ShrubberyCreationForm(std::string target)`           | tworzy obiekt z konkretnym celem              |
| Konstruktor kopiujÄ…cy    | `ShrubberyCreationForm(ShrubberyCreationForm &other)` | tworzy kopiÄ™ innego obiektu                   |
| Operator przypisania     | `operator=`                                           | przypisuje dane z jednego obiektu do drugiego |


1ï¸âƒ£ RobotomyRequestForm::RobotomyRequestForm()
â†’ To konstruktor domyÅ›lny tej klasy.
WywoÅ‚ywany, gdy utworzysz obiekt bez argumentÃ³w, np.:

RobotomyRequestForm form;


2ï¸âƒ£ : AForm("RobotomyRequestForm", 72, 45)
â†’ To lista inicjalizacyjna.
Tutaj wywoÅ‚ujesz konstruktor klasy bazowej AForm.
KaÅ¼dy formularz dziedziczy po AForm, wiÄ™c najpierw musi siÄ™ utworzyÄ‡ czÄ™Å›Ä‡ bazowa.

W praktyce:

nazwa formularza = "RobotomyRequestForm",
minimalny grade do podpisania = 72,
minimalny grade do wykonania = 45.

Czyli w AForm tworzysz obiekt z tymi parametrami.

3ï¸âƒ£ , target("default")
â†’ Ustawiasz wartoÅ›Ä‡ pola target (cel robotomizacji) na "default".
To zwykÅ‚y string â€” czyli jeÅ›li nie podasz celu, domyÅ›lnie jest â€defaultâ€.

4ï¸âƒ£ {}
â†’ CiaÅ‚o konstruktora jest puste, bo wszystko zrobiono w liÅ›cie inicjalizacyjnej.

3ï¸âƒ£ , target(target)
â†’ Inicjalizujesz swoje prywatne pole target wartoÅ›ciÄ… przekazanÄ… do konstruktora.
Czyli:

argument funkcji target (ten w nawiasach) jest kopiowany do
pola klasy target (tego prywatnego).
Tak naprawdÄ™ dzieje siÄ™ coÅ› w stylu:

this->target = target;

ale zrobione bezpoÅ›rednio przy tworzeniu obiektu (bardziej wydajnie).

1ï¸âƒ£ To konstruktor kopiujÄ…cy,
czyli uÅ¼ywany, gdy robisz np.:

RobotomyRequestForm a("Bender");
RobotomyRequestForm b(a);   // <-- tutaj!


2ï¸âƒ£ : AForm(other)
â†’ WoÅ‚asz konstruktor kopiujÄ…cy klasy bazowej AForm.
DziÄ™ki temu kopiujesz czÄ™Å›Ä‡ wspÃ³lnÄ… (czyli nazwÄ™, grade'y, status podpisania itp.).

3ï¸âƒ£ , target(other.getTarget())
â†’ Ustawiasz target nowego obiektu na taki sam, jak w obiekcie other.
other.getTarget() wywoÅ‚uje funkcjÄ™ zwracajÄ…cÄ… target z innego obiektu.

4ï¸âƒ£ {}
â†’ Puste ciaÅ‚o, bo wszystko zaÅ‚atwione w liÅ›cie inicjalizacyjnej.


RobotomyRequestForm &RobotomyRequestForm::operator=(RobotomyRequestForm &other)
{
    (void)other;
    return (*this);
}
ğŸ” Krok po kroku:
1ï¸âƒ£ To operator przypisania,
czyli uÅ¼ywany, gdy piszesz:

cpp
Skopiuj kod
RobotomyRequestForm a("Bender");
RobotomyRequestForm b;
b = a;   // <-- tutaj!
2ï¸âƒ£ (void)other;
â†’ To tylko po to, Å¼eby kompilator nie ostrzegaÅ‚, Å¼e â€otherâ€ jest nieuÅ¼ywane.
Na razie operator nic nie robi (bo nie kopiujesz Å¼adnych danych rÄ™cznie).

3ï¸âƒ£ return (*this);
â†’ Zwracasz referencjÄ™ do tego samego obiektu, ktÃ³ry wÅ‚aÅ›nie przypisujesz.
To standardowy zapis w operatorach przypisania.

ğŸ’¡ W praktyce â€“ tutaj operator przypisania nie kopiuje niczego,
bo AForm i target nie sÄ… przypisane.
Ale to jest minimalna poprawna wersja, ktÃ³ra kompiluje siÄ™ i dziaÅ‚a bez bÅ‚Ä™dÃ³w.

| Konstruktor / Operator | Kiedy uÅ¼ywany                         | Co robi                                |
| ---------------------- | ------------------------------------- | -------------------------------------- |
| **DomyÅ›lny**           | `RobotomyRequestForm form;`           | Tworzy obiekt z targetem `"default"`   |
| **Z argumentem**       | `RobotomyRequestForm form("Bender");` | Tworzy obiekt z podanym targetem       |
| **KopiujÄ…cy**          | `RobotomyRequestForm b(a);`           | Tworzy kopiÄ™ istniejÄ…cego formularza   |
| **Operator=**          | `b = a;`                              | Przypisuje jeden formularz do drugiego |
| **Destruktor**         | `~RobotomyRequestForm()`              | Usuwa obiekt z pamiÄ™ci (tu pusty)      |


rand() daje Ci duÅ¼e liczby, wiÄ™c Å¼eby mieÄ‡ maÅ‚y zakres (np. tylko 0 lub 1), uÅ¼ywamy operatora %.

PrzykÅ‚ad:

int result = rand() % 2;


Jak to dziaÅ‚a:

% to reszta z dzielenia.

rand() % 2 moÅ¼e daÄ‡ tylko:
0 (jeÅ›li liczba byÅ‚a parzysta),
1 (jeÅ›li byÅ‚a nieparzysta).

WiÄ™c masz 50% szans na 0 i 50% na 1 ğŸ¯


ğŸ” Co siÄ™ tu dzieje linijka po linijce
1ï¸âƒ£ try { ... }

To jak powiedzenie:

â€SprÃ³buj wykonaÄ‡ ten fragment kodu â€” ale miej siÄ™ na bacznoÅ›ci, bo coÅ› tu moÅ¼e siÄ™ nie udaÄ‡.â€

Czyli np.:
otwieranie pliku,
rzutowanie,

wywoÅ‚anie funkcji, ktÃ³ra moÅ¼e â€rzuciÄ‡ wyjÄ…tekâ€.

2ï¸âƒ£ catch (const std::exception &e)

To blok, ktÃ³ry â€Å‚apieâ€ wyjÄ…tek, jeÅ›li coÅ› poszÅ‚o nie tak.
W C++ bÅ‚Ä™dy sÄ… przekazywane w postaci obiektÃ³w typu std::exception (albo klas pochodnych).

e to po prostu nazwa tego bÅ‚Ä™du, ktÃ³ry zostaÅ‚ zÅ‚apany.
const â€“ bo nie chcemy go modyfikowaÄ‡, tylko odczytaÄ‡,

& â€“ Å¼eby nie kopiowaÄ‡ caÅ‚ego obiektu bÅ‚Ä™du, tylko uÅ¼yÄ‡ referencji,
std::exception â€“ to gÅ‚Ã³wna klasa wszystkich wyjÄ…tkÃ³w w C++.

3ï¸âƒ£ e.what()

KaÅ¼dy wyjÄ…tek ma funkcjÄ™ what(), ktÃ³ra zwraca opis bÅ‚Ä™du â€” jako tekst (const char*).

Czyli jakbyÅ› spytaÅ‚a bÅ‚Ä…d:

â€Hej, co siÄ™ staÅ‚o?â€
A on odpowiada:
â€Grade is too low!â€ albo â€File not found!â€

4ï¸âƒ£ std::cerr << e.what() << std::endl;

To wypisuje komunikat o bÅ‚Ä™dzie do tzw. standardowego strumienia bÅ‚Ä™dÃ³w (cerr).
To dziaÅ‚a prawie jak std::cout, ale:
cout â†’ normalne komunikaty programu,
cerr â†’ komunikaty bÅ‚Ä™dÃ³w (np. Å¼eby Å‚atwo je byÅ‚o rozrÃ³Å¼niÄ‡).

ğŸ” Co to daje w praktyce?

Bez try/catch:
â†’ jeÅ›li funkcja rzuci wyjÄ…tek, program siÄ™ natychmiast zatrzyma.

Z try/catch:
â†’ program siÄ™ nie wywali, tylko przejdzie do bloku catch i spokojnie wypisze, co poszÅ‚o nie tak.