ğŸ§© ex02 â€“ AForm + konkretne formularze

Cel: stworzyÄ‡ bazowÄ… klasÄ™ abstrakcyjnÄ… AForm, po ktÃ³rej dziedziczÄ… konkretne formularze:

ShrubberyCreationForm
RobotomyRequestForm
PresidentialPardonForm
KaÅ¼da ma inny cel i wymagany poziom:

| Formularz              | Grade do podpisu | Grade do wykonania | Akcja                                                 |
| ---------------------- | ---------------- | ------------------ | ----------------------------------------------------- |
| ShrubberyCreationForm  | 145              | 137                | Tworzy plik `<target>_shrubbery` z ASCII drzewami ğŸŒ³  |
| RobotomyRequestForm    | 72               | 45                 | 50% szansy na sukces â€robotomizacjiâ€ ğŸ¤–               |
| PresidentialPardonForm | 25               | 5                  | Informuje o uÅ‚askawieniu przez Zaphoda Beeblebroxa ğŸ‘‘ |


KaÅ¼dy formularz ma funkcjÄ™ execute(Bureaucrat const &executor) const
Bureaucrat dostaje executeForm() â€“ prÃ³buje wykonaÄ‡ dany formularz.

ğŸ” Uczysz siÄ™:
dziedziczenia,
klas abstrakcyjnych (= 0),
polimorfizmu,
pracy z plikami (ofstream).

Dlaczego AForm ma byÄ‡ klasÄ… abstrakcyjnÄ… â€” konkretne powody i zastosowania
To znaczy, Å¼e AForm to szablon (plan), a nie gotowa rzecz.
WyobraÅº sobie, Å¼e masz urzÄ™dowy system, w ktÃ³rym rÃ³Å¼ni urzÄ™dnicy obsÅ‚ugujÄ… rÃ³Å¼ne formularze:

jeden sadzi drzewka (ShrubberyCreationForm),
drugi robotyzuje (RobotomyRequestForm),
trzeci uÅ‚askawia (PresidentialPardonForm).

Ale kaÅ¼dy formularz ma pewne wspÃ³lne zasady:
ma nazwÄ™,
ma poziomy uprawnieÅ„ do podpisu i wykonania,
moÅ¼e byÄ‡ podpisany lub nie,
moÅ¼na go prÃ³bowaÄ‡ wykonaÄ‡,
moÅ¼e rzucaÄ‡ wyjÄ…tki.

ğŸ’¡ AForm to klasa, ktÃ³ra definiuje te wspÃ³lne rzeczy.
Ale sama nie robi Å¼adnego konkretnego dziaÅ‚ania, bo nie wiadomo, co miaÅ‚aby zrobiÄ‡ â€” posadziÄ‡ drzewko, zrobotyzowaÄ‡ kogoÅ› czy uÅ‚askawiÄ‡?
Dlatego AForm jest abstrakcyjna â€” mÃ³wi:
â€KaÅ¼da konkretna forma musi mieÄ‡ wÅ‚asny sposÃ³b wykonania (action()). Ja tylko okreÅ›lam zasady.â€

ğŸ”¹ PrzykÅ‚ad z Å¼ycia (bardzo obrazowy)
WyobraÅº sobie formularz urzÄ™dowy:
â€Formularz do zaÅ‚atwienia sprawy.â€
Wiesz, Å¼e kaÅ¼dy formularz musi mieÄ‡:

pole z nazwiskiem,
pole z numerem sprawy,
podpis urzÄ™dnika.

Ale nie wiesz, do czego on sÅ‚uÅ¼y â€” moÅ¼e do podatkÃ³w, moÅ¼e do wniosku o paszport, moÅ¼e o pozwolenie na budowÄ™.
WiÄ™c taki formularz jest abstrakcyjny â€” sam w sobie bezuÅ¼yteczny.
Dopiero, gdy powstaje konkretny:

â€Wniosek o paszportâ€ â†’ (czyli PresidentialPardonForm)
â€ZgÅ‚oszenie budowyâ€ â†’ (czyli ShrubberyCreationForm)
â€Wniosek o robotyzacjÄ™â€ â†’ (czyli RobotomyRequestForm)
â€” wtedy wiadomo, co konkretnie robi ten formularz, czyli jaka jest jego akcja.

ğŸ”¹ Polimorfizm â€” najprostsze wyjaÅ›nienie
Polimorfizm = â€rÃ³Å¼ne zachowania przez ten sam interfejsâ€.
Czyli moÅ¼esz mieÄ‡ np. listÄ™ formularzy (AForm*),
a mimo to kaÅ¼dy z nich wykona coÅ› innego po wywoÅ‚aniu execute().

PrzykÅ‚ad w uproszczonym pseudokodzie:
AForm* forms[3] = {
    new ShrubberyCreationForm("home"),
    new RobotomyRequestForm("Bender"),
    new PresidentialPardonForm("Arthur")
};

for (int i = 0; i < 3; i++)
    forms[i]->execute(bureaucrat);

Tutaj:
dla 1. elementu â€“ posadzi drzewko,
dla 2. â€“ sprÃ³buje robotyzowaÄ‡,
dla 3. â€“ wypisze uÅ‚askawienie.

Ty nie musisz wiedzieÄ‡, ktÃ³ra to klasa.
Program sam wie, bo kaÅ¼da forma ma swojÄ… wersjÄ™ execute().
To wÅ‚aÅ›nie polimorfizm â€” ta sama funkcja (execute()), ale rÃ³Å¼ne zachowanie zaleÅ¼nie od rodzaju formularza.

ğŸ”¹ Co znaczy â€wspÃ³lny interfejsâ€?
To znaczy, Å¼e kaÅ¼da forma ma te same metody, np.:
beSigned()
execute()
getName()
getTarget()
DziÄ™ki temu moÅ¼esz napisaÄ‡ kod, ktÃ³ry dziaÅ‚a z dowolnym formularzem â€” nie musisz pisaÄ‡ osobno dla kaÅ¼dej klasy.

ğŸ”¹ Co znaczy â€separation of concernsâ€ â€” po ludzku

PodziaÅ‚ obowiÄ…zkÃ³w.
Czyli:
AForm zajmuje siÄ™ biurokratycznÄ… stronÄ… (czy podpisano, czy grade jest ok).
konkretna forma (Shrubbery, Robotomy, Presidential) zajmuje siÄ™ tym, co siÄ™ dzieje po wykonaniu.

Tak jak w urzÄ™dzie:
Sekretarka sprawdza, czy wniosek jest kompletny (czy podpisany, czy masz wymagany dokument).
Dopiero potem urzÄ™dnik wykonuje czynnoÅ›Ä‡ (np. wydaje paszport).

ğŸ”¹ Co daje to Tobie jako programiÅ›cie?
âœ… MoÅ¼esz Å‚atwo dodawaÄ‡ nowe formularze, np. MarriageApprovalForm, SpaceTravelForm, itp.
Nie musisz nic zmieniaÄ‡ w Bureaucrat ani w AForm. Po prostu dodajesz nowÄ… klasÄ™ dziedziczÄ…cÄ… i piszesz nowÄ… action().
âœ… MoÅ¼esz przechowywaÄ‡ rÃ³Å¼ne formularze w jednej tablicy lub wektorze (std::vector<AForm*>).
âœ… Kod jest czystszy, bardziej logiczny i Å‚atwiejszy do utrzymania.

ğŸ”¹ Bardzo krÃ³tka analogia 


Konkretna lista zadaÅ„ do wykonania (skrÃ³t â€” tick-lista)

 Zaprojektuj AForm.hpp z prywatnymi polami, getterami, beSigned(), execute() i czystÄ… wirtualnÄ… action().
 Zadeklaruj i zaimplementuj wyjÄ…tki (GradeTooHigh, GradeTooLow, NotSigned).
 Zaimplementuj AForm.cpp (konstruktor, beSigned, execute).
 Zaktualizuj/zaimplementuj Bureaucrat.hpp/cpp z signForm i executeForm.
 Dodaj nagÅ‚Ã³wki i implementacje ShrubberyCreationForm, RobotomyRequestForm, PresidentialPardonForm.
 Zaimplementuj action() w kaÅ¼dej klasie (zachowanie opisane wyÅ¼ej).
 Napisz main.cpp z wymienionymi testami.
 UzupeÅ‚nij Makefile i przetestuj make, make fclean, make re.
 Uruchom testy; popraw bÅ‚Ä™dy.
 (Opcjonalnie) Uruchom valgrind i popraw wycieki.