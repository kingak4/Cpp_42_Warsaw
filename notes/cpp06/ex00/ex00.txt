2. Co musi robiÄ‡ TwÃ³j program?
Twoje ./convert <literal> powinno:
WykryÄ‡ typ przekazanego literaÅ‚u:

â€™aâ€™ â†’ char
42 â†’ int
4.2f â†’ float
4.2 â†’ double

nanf / +inff / -inff â†’ float specjalne
nan / +inf / -inf â†’ double specjalne

PrzekonwertowaÄ‡ go na pozostaÅ‚e typy, z obsÅ‚ugÄ…:

nadmiaru (overflow)
konwersji niemoÅ¼liwej
znakÃ³w niedrukowalnych

WyÅ›wietliÄ‡ wynik w dokÅ‚adnym formacie, np.:
char: '*'
int: 42
float: 42.0f
double: 42.0


ETAP 1 â€” Zrozumienie celu

Musisz napisaÄ‡:
parser typu literaÅ‚u
konwerter miÄ™dzy typami
formater wyjÅ›cia
Wszystko zamkniÄ™te w jednej metodzie convert.

ETAP 2 â€” Zablokowanie tworzenia obiektu ScalarConverter

Klasa ma zawieraÄ‡ tylko statycznÄ… funkcjÄ™.
Blokujesz konstruktory.

ETAP 3 â€” Wykrywanie typu wejÅ›ciowego

To jest najwaÅ¼niejsza czÄ™Å›Ä‡.

Musisz wykrywaÄ‡:

1) char

format 'c'
dÅ‚ugoÅ›Ä‡ == 3
pierwszy znak ' i ostatni '

2) int

tylko cyfry z opcjonalnym znakiem + lub -
Å¼adnych kropek
Å¼adnego â€fâ€ na koÅ„cu

3) float (zwykÅ‚y)

musi zawieraÄ‡ kropkÄ™
musi koÅ„czyÄ‡ siÄ™ na f

4) float (pseudoliteraly)

"nanf"
"+inff"
"-inff"

5) double (zwykÅ‚y)
musi zawieraÄ‡ kropkÄ™
nie koÅ„czy siÄ™ na f

6) double (pseudoliteraly)

"nan"
"+inf"
"-inf"

ETAP 4 â€” Konwersja

Gdy juÅ¼ wiesz, co to jest:
Konwertujesz string â†’ bazowy typ
Konwertujesz bazowy typ do pozostaÅ‚ych typÃ³w jawnie (C-style albo static_cast)

Dla char:
sprawdzasz czy da siÄ™ wyÅ›wietliÄ‡ (ASCII 32â€“126)

Dla int:
uwaÅ¼asz na overflow (long long â†’ int)

Dla float / double:
wypisujesz odpowiedni sufiks f dla float
specjalne wartoÅ›ci zawsze wypisujesz, nawet gdy inne typy sÄ… â€impossible

2) Doprecyzowanie formatÃ³w wejÅ›cia

char: postaÄ‡ 'c' â€” zawsze 3 znaki: ', znak, '. (ZaÅ‚Ã³Å¼, Å¼e nie podasz niedrukowalnych znakÃ³w.)
int: dziesiÄ™tna notacja, opcjonalny + lub -, bez kropek czy sufiksÃ³w (np. 0, -42, 42).
float: ma mieÄ‡ kropkÄ™ i koÅ„czyÄ‡ siÄ™ f (np. 4.2f, -0.0f), oraz pseudoliteraly: nanf, +inff, -inff.
double: ma kropkÄ™, nie koÅ„czy siÄ™ f (np. 4.2, 0.0), oraz pseudoliteraly: nan, +inf, -inf.
Uwaga: wejÅ›cia typu 42.0 â†’ double; 42.0f â†’ float. 42 â†’ int. 'a' â†’ char.

3) Co wyÅ›wietlasz w kaÅ¼dej konwersji

Dla kaÅ¼dego z czterech typÃ³w musisz wypisaÄ‡ jednÄ… z moÅ¼liwoÅ›ci:
poprawna wartoÅ›Ä‡ (np. int: 42, float: 42.0f, double: 42.0, char: 'A'),
impossible â€” gdy konwersja logicznie nie ma sensu (np. nan â†’ int),
Non displayable â€” gdy wartoÅ›Ä‡ istnieje, ale char nie jest drukowalny (np. wynik to ASCII 10),
odpowiedni format pseudoliterali (nanf, nan, +inff, +inf, itd.).


Typowy algorytm dziaÅ‚ania funkcji convert
Trim wejÅ›cia (usuÅ„ biaÅ‚e znaki) â€” najlepiej wymagaÄ‡ braku spacji, ale dobry parser moÅ¼e tolerowaÄ‡.
SprawdÅº pseudoliteraly najpierw (porÃ³wnanie stringÃ³w do nan, nanf, +inf, -inff itd.). JeÅ›li trafione â€” obsÅ‚uÅ¼ jako osobny przypadek.
SprawdÅº char: czy string ma format 'x'. JeÅ›li tak â€” baza = char.
SprawdÅº int: czy caÅ‚y string pasuje do wzoru ^[+-]?\d+$ â†’ baza = int.
SprawdÅº float: czy koÅ„czy siÄ™ f i przed f jest poprawna notacja liczby z kropkÄ… lub bez (np. 42f to ambiwalentne â€” zadanie jednak zakÅ‚ada kropkÄ™; trzymaj siÄ™ reguÅ‚y: float ma kropkÄ™). MoÅ¼esz rozrÃ³Å¼niaÄ‡: jeÅ¼eli koÅ„czy f â†’ sprÃ³buj std::stof.
SprawdÅº double: w przeciwnym wypadku, jeÅ›li string zawiera kropkÄ™ â†’ sprÃ³buj std::stod.
JeÅ›li nic nie pasuje â†’ wypisz komunikat o bÅ‚Ä™dzie (np. unknown literal albo impossible).


7) Formatowanie wyniku (zalecenia)

Dla float zawsze dodaj sufiks f (np. 0.0f, 42.0f).
Zachowaj jednÄ… cyfrÄ™ po przecinku, gdy to potrzeba (np. 42.0 zamiast 42) â€” zadanie w przykÅ‚adach pokazuje .0 gdy to liczba caÅ‚kowita w formacie float/double. MoÅ¼esz to osiÄ…gnÄ…Ä‡ uÅ¼ywajÄ…c std::fixed + ustawienie precyzji (np. std::setprecision(1)), ale pamiÄ™taj, Å¼eby dla wartoÅ›ci typu nan/inf nie uÅ¼ywaÄ‡ fixed/precyzji â€” wypisz tekstowe reprezentacje.
Dla char wypisz 'c' (z apostrofami) gdy jest drukowalny.

ğŸ”¥ CO ZNACZY â€KLSA NIE POWINNA BYÄ† INSTANCJOWALNAâ€?
To znaczy:
UÅ¼ytkownik NIE moÅ¼e zrobiÄ‡ czegoÅ› takiego:
ScalarConverter s;    // âŒ niedozwolone
lub:
ScalarConverter *ptr = new ScalarConverter();   // âŒ niedozwolone
Czyli nie moÅ¼na tworzyÄ‡ obiektÃ³w tej klasy.

ğŸ”¥ CO MASZ ZROBIÄ†, Å»EBY TAK BYÅO?
1) ZrobiÄ‡ wszystkie metody statyczne

NajwaÅ¼niejsza jest jedna metoda:
static void convert(std::string const & literal);
Statyczna = woÅ‚asz jÄ… tak:
ScalarConverter::convert("42.0f");
Bez tworzenia obiektu.

2) ZABLOKOWAÄ† KONSTRUKTOR

To kluczowy element:
musisz sprawiÄ‡, Å¼e konstruktora nie da siÄ™ uÅ¼yÄ‡.
Robi siÄ™ to tak:
deklarujesz konstruktor jako private
deklarujesz destruktor jako private
deklarujesz copy constructor i operator= jako private
nie piszesz implementacji
(Å¼eby kompilator nie pozwoliÅ‚ ich uÅ¼yÄ‡)

Efekt:
kaÅ¼dy, kto sprÃ³buje utworzyÄ‡ obiekt â†’ dostanie bÅ‚Ä…d kompilacji.

ğŸ”¥ Dlaczego konstruktor jest â€œpustyâ€?
JeÅ›li metoda jest tylko zadeklarowana:
ScalarConverter();
â€¦to oznacza:
kompilator wie, Å¼e konstruktor istnieje
ale nikt spoza klasy nie ma do niego dostÄ™pu (bo jest private)
a Ty nie implementujesz go, bo nigdy nie bÄ™dzie uÅ¼yty
To jest w peÅ‚ni poprawne.

ğŸ”¥ Dlaczego NIE piszemy implementacji w .cpp?

Bo:
Te metody i tak nigdy nie bÄ™dÄ… wywoÅ‚ane.
Ich jedyny sens to zakazaÄ‡ instancjowania.
JeÅ›li ktoÅ› SPRÃ“BUJE ich uÅ¼yÄ‡ (np. przez pomyÅ‚kÄ™), to i tak:
dostanie bÅ‚Ä…d kompilacji (bo sÄ… private)
a gdyby udaÅ‚o siÄ™ jakoÅ› obejÅ›Ä‡ (co jest prawie niemoÅ¼liwe), brak implementacji wywoÅ‚a bÅ‚Ä…d linkera â†’ i to dobrze, bo klasa ma byÄ‡ nieuÅ¼ywalna jako obiekt.

W tym zadaniu liczy siÄ™ tylko convert(), a nie cykl Å¼ycia obiektu.
Dlatego puste deklaracje wystarczÄ… i sÄ… normalnÄ… praktykÄ… w C++.

ğŸ”¥ Czy to jest â€œdziwneâ€?
Nie â€” to standardowy sposÃ³b w C++ na blokowanie tworzenia obiektÃ³w.

Tak robi siÄ™ w:
klasach narzÄ™dziowych (utility classes)
klasach singletonowych (stare podejÅ›cie)
klasach statycznych (np. konwertery, loggery)
bibliotekach STL (np. niektÃ³re klasy pomocnicze)
systemie plikÃ³w <filesystem>
To jest uznany, profesjonalny wzorzec.
Konstruktory sÄ… puste, bo majÄ… istnieÄ‡ tylko po to, Å¼eby zablokowaÄ‡ tworzenie obiektÃ³w â€” a skoro NIKT nigdy ich nie wywoÅ‚a, nie potrzebujÄ… Å¼adnej implementacji.


ğŸ”¥ NA CO PARSER MA POZWALAÄ†, A NA CO MA REAGOWAÄ† BÅÄ˜DEM?

PoniÅ¼ej masz kompletnÄ… listÄ™ przypadkÃ³w, ktÃ³re musisz obsÅ‚uÅ¼yÄ‡.
Po przeczytaniu tego wiesz dokÅ‚adnie co robiÄ‡.

1) CHAR
Format:
'a', 'b', '@', '#'

Warunki:
dÅ‚ugoÅ›Ä‡ = 3
pierwszy znak '
ostatni znak '
Å›rodkowy znak to 1 znak ASCII
Akceptujesz:
'a', 'Z', '+', ' '

Odrzucasz:
'ab'
a
"a"
' 'a'
'
2) INT

Format:
0, -42, +42, 123456

Warunki:
opcjonalnie + lub - na poczÄ…tku
reszta MUSI byÄ‡ cyframi
NIE moÅ¼e byÄ‡:

kropki
litery
sufiksu f
spacji
innych znakÃ³w

Akceptujesz:
0, -42, 42, +1234

Odrzucasz:
42.0 (to double)
42f (niepoprawne)
4a
123 4
--42

3) FLOAT (NORMALNE)
Format:
4.2f, 0.0f, -1.25f

Warunki:
musi zawieraÄ‡ kropkÄ™
musi koÅ„czyÄ‡ siÄ™ f
przed f musi byÄ‡ poprawna liczba
znak + lub - na poczÄ…tku dozwolony

Akceptujesz:
4.2f, 0.0f, -4.0f, +3.5f

Odrzucasz:
4f (brak kropki â†’ niezalecane)
4.f (rÃ³Å¼ne implementacje: Ty moÅ¼esz przyjÄ…Ä‡ Å¼e musi byÄ‡ cyfra przed i po)
4.2ff
4.2 (to double)
.5f (w module 06 niezalecane)

4) FLOAT (PSEUDOLITERALS)

Tylko te 3:
nanf
+inff
-inff

Akceptujesz 100% zawsze
Bo one oznaczajÄ… specjalne wartoÅ›ci IEEE.

Nie prÃ³bujesz ich parsowaÄ‡ jako liczby.
Od razu uznajesz: â€to float pseudoâ€.

5) DOUBLE (NORMALNE)

Format:
4.2, 0.0, -1.25

Warunki:
musi mieÄ‡ kropkÄ™
NIE moÅ¼e mieÄ‡ f na koÅ„cu
musi to byÄ‡ poprawna notacja liczby dziesiÄ™tnej

Akceptujesz:
4.2, 0.0, -1.25

Odrzucasz:
4.
.4
4.2f
4,2 (przecinek = bÅ‚Ä…d)
4.2.1

6) DOUBLE (PSEUDOLITERALS)

Tylko te 3:
nan
+inf
-inf
To sÄ… dokÅ‚adnie odpowiedniki double bez sufiksu f.

7) CO, JEÅšLI KTOÅš WPISZE STRING TYPU:
hello
a12
f
something
abc123
"tekst"

ğŸ‘‰ Masz zwrÃ³ciÄ‡: "impossible" dla wszystkich konwersji
Albo wypisaÄ‡ informacyjnie, Å¼e literaÅ‚ jest bÅ‚Ä™dny.
To nie jest poprawny literaÅ‚ C++, wiÄ™c parser ma go odrzuciÄ‡.
PrzykÅ‚ad:
./convert hello
char: impossible
int: impossible
float: impossible
double: impossible

ğŸ”¥ PODSUMOWANIE â€“ PARSER MA OBSÅUÅ»YÄ† TYLKO TE KATEGORIE:

'c' â†’ char
[+-]?\d+ â†’ int
[+-]?\d+\.\d+f â†’ float
[+-]?\d+\.\d+ â†’ double

nanf, +inff, -inff â†’ float pseudo
nan, +inf, -inf â†’ double pseudo
wszystko inne â†’ zÅ‚e dane

1. Liczby caÅ‚kowite (int)

PrzykÅ‚ady poprawnych:
"0"
"-42"
"123"
"+7"

Warunki:
Tylko cyfry + opcjonalny znak + lub - na poczÄ…tku.
MieÅ›ci siÄ™ w zakresie int (sprawdzasz pÃ³Åºniej).

2. Liczby zmiennoprzecinkowe typu float
PrzykÅ‚ady poprawnych:
"0.0f"
"-12.3f"
"4.2f"
"nanf"
"+inff"
Warunki:
Musi koÅ„czyÄ‡ siÄ™ na f.
MoÅ¼e mieÄ‡ czÄ™Å›Ä‡ dziesiÄ™tnÄ….
MoÅ¼e mieÄ‡ znak + lub -.
Specjalne literaÅ‚y: nanf, +inff, -inff.

3. Liczby zmiennoprzecinkowe typu double
PrzykÅ‚ady poprawnych:

"0.0"
"-12.3"
"4.2"
"nan"
"+inf"
"-inf"
Warunki:
Bez f na koÅ„cu.
MoÅ¼e zawieraÄ‡ kropkÄ™.
MoÅ¼e byÄ‡ znak + lub -.
Specjalne literaÅ‚y: nan, +inf, -inf.
4. Jeden znak (char)

PrzykÅ‚ady poprawnych:
"a"
"Z"
"*"
"3" (teÅ¼ uznajemy jako char)

Warunki:
DÅ‚ugoÅ›Ä‡ 1 i nie jest cyfrÄ… â€“ wtedy traktujesz jako char.

JeÅ›li dÅ‚ugoÅ›Ä‡ > 1 â†’ nie jest char.

âŒ NA CO PARSER NIE MOÅ»E POZWALAÄ†
Parser ma odrzucaÄ‡ wszystko inne, czyli:

âŒ 1. Mieszane typy
"12a"
"abc"
"1.2.3"
"--3"
"4f4"
"3ff"

âŒ 2. Float bez f
"12."
"42."
"5.f"
"5."

âŒ 3. Double z f
"12.3ff"
"4.2f " (spacja niedozwolona)

âŒ 4. Spacje wokÃ³Å‚
Parser nie akceptuje:
" 42"
"42 "
" 12.3 "
Masz dokÅ‚adnie jeden argument i ma byÄ‡ idealnie poprawny.

âŒ 5. Puste stringi
""
âŒ 6. Jakiekolwiek inne znaki

"\n"
"\t"
"%"

ğŸ§± Co robisz w etapie 1?

Twoim zadaniem jest:
âœ” 1. NapisaÄ‡ funkcjÄ™ parse(), ktÃ³ra:
bierze const std::string & literal
analizuje jÄ…

decyduje:
czy to char
czy to int
czy to float
czy to double
czy to specjalny literaÅ‚

âœ” 2. JeÅ›li nie pasuje do NICZEGO â†’ rzucasz wyjÄ…tek â€œInvalid literalâ€.

âœ… Co to sÄ… specjalne literaÅ‚y?
To sÄ… wartoÅ›ci, ktÃ³re nie sÄ… normalnymi liczbami, ale istniejÄ… w typach float i double.
I dlatego jÄ™zyk C++ pozwala je zapisaÄ‡ specjalnymi sÅ‚owami.

ğŸ§  1. nan â€“ Not A Number

Oznacza:
ğŸ‘‰ â€To nie jest liczbaâ€.

PrzykÅ‚ady, kiedy tak powstaje:
dzielenie 0.0 / 0.0
pierwiastek z liczby ujemnej
operacje matematyczne bez sensu

W projekcie traktujesz nan jak double, a nanf jak float.
ğŸ§  2. +inf, -inf â€“ nieskoÅ„czonoÅ›Ä‡

Oznacza:
ğŸ‘‰ wynik dziaÅ‚ania, ktÃ³ry jest tak duÅ¼y, Å¼e nie mieÅ›ci siÄ™ w liczbie.

PrzykÅ‚ad:
1.0 / 0.0 â†’ +inf
-1.0 / 0.0 â†’ -inf

To teÅ¼ sÄ… waÅ¼ne przypadki, bo musisz je poprawnie sparsowaÄ‡ i wypisaÄ‡.

W wersji float masz:
+inff
-inff

| Zapis  | Znaczenie                                  |
| ------ | ------------------------------------------ |
| `nan`  | Nie da siÄ™ obliczyÄ‡ / wynik jest bez sensu |
| `+inf` | NieskoÅ„czenie duÅ¼a liczba                  |
| `-inf` | NieskoÅ„czenie maÅ‚a liczba                  |

ğŸ“Œ Dlaczego to waÅ¼ne?

Bo te stringi nie sÄ… bÅ‚Ä™dne.
SÄ… poprawnymi wartoÅ›ciami double/float, ktÃ³re moÅ¼esz zrzutowaÄ‡ na inne typy.
TwÃ³j parser MUSI je wykrywaÄ‡ jako:
nan, +inf, -inf â†’ double
nanf, +inff, -inff â†’ float


1) UsuÅ„ spacje z poczÄ…tku i koÅ„ca

Ludzie mogÄ… wpisaÄ‡:

"   42"
"42    "
"   4.2f   "
â†’ Najpierw trims.

2) SprawdÅº czy to pseudo-literal (special value)

ObsÅ‚ugiwane:
"nan"
"nanf"
"+inf", "-inf"
"+inff", "-inff"
JeÅ›li taki string â†’ od razu znasz typ:
wersje bez f â†’ double
wersje z f â†’ float
Nic wiÄ™cej tu nie sprawdzasz.

3) SprawdÅº, czy to CHAR literal
Ale UWAGA â€“ nie 'a', tylko a.

W Module 06 char nie ma apostrofÃ³w.
JeÅ›li masz pojedynczy znak, ktÃ³ry:
nie jest cyfrÄ…
jest ASCII i da siÄ™ wyÅ›wietliÄ‡
â†’ to jest char.
PrzykÅ‚ad:
"a" â†’ char
"Z" â†’ char
"!" â†’ char
"1" â†’ to NIE char (traktujemy jako liczbÄ™)

4) SprawdÅº, czy to INT

Warunki:

moÅ¼e zaczynaÄ‡ siÄ™ od + lub -

musi byÄ‡ tylko z cyfr

nie moÅ¼e mieÄ‡ kropki

nie moÅ¼e mieÄ‡ litery f

PrzykÅ‚ady poprawne:

"0"

"-42"

"+123"

To daje typ: int

Dodatkowo:
Po wykryciu â†’ sprÃ³buj rzutowaÄ‡ std::stoll,
sprawdÅº czy mieÅ›ci siÄ™ w INT_MIN / INT_MAX.

JeÅ›li nie â†’ int = impossible
ale typ wejÅ›cia to dalej INT.

5) SprawdÅº, czy to FLOAT

Warunki:

musi mieÄ‡ kropkÄ™ (.)

musi mieÄ‡ f na koÅ„cu

cyfry po bokach kropki (chociaÅ¼ jedna strona moÅ¼e byÄ‡ pusta jak .5f)

moÅ¼e mieÄ‡ + / - na poczÄ…tku

PrzykÅ‚ady:

"4.2f"

"-3.0f"

"+0.0f"

"12.f" â†’ poprawne

".5f" â†’ poprawne

"nanf" â†’ juÅ¼ wykryte wczeÅ›niej

Typ: float

6) SprawdÅº, czy to DOUBLE

Warunki:

musi mieÄ‡ kropkÄ™

NIE moÅ¼e mieÄ‡ f na koÅ„cu

moÅ¼e mieÄ‡ +/-

PrzykÅ‚ady:

"4.2"

"0.0"

"12."

".5"

"nan" â†’ wczeÅ›niej wykryte

Typ: double

âŒ CO TWÃ“J PARSER MA ODRZUCAÄ† (NIEPRAWIDÅOWE)**
JeÅ¼eli string:
zawiera wiÄ™cej niÅ¼ jednÄ… kropkÄ™
ma litery inne niÅ¼ f
ma spacje w Å›rodku "4 2"
zaczyna siÄ™ lub koÅ„czy na Å›mieci "42g"
mieszane formaty "4.f2"
puste: ""
â†’ to nie jest Å¼aden typ i musisz wypisaÄ‡ komunikaty â€impossibleâ€.

ğŸ“Œ PODSUMOWANIE â€“ NA CO POZWALAÄ†, NA CO NIE
âœ” POZWALAÄ† NA:
char: jeden znak niebÄ™dÄ…cy cyfrÄ…
int: same cyfry + opcjonalny znak
float: liczba z kropkÄ… i f na koÅ„cu
double: liczba z kropkÄ… bez f
special values (nan, +inf, â€¦)

âŒ NIE POZWALAÄ† NA:
stringi typu â€helloâ€, â€abcâ€, â€42abcâ€
dwie kropki â€4.2.1â€
kropka ale bez contextu â€.â€
puste wartoÅ›ci
niedozwolone znaki
mieszanie float i double â€4.2ffâ€ albo â€4.2f3â€

âœ… 2) ALGORYTM KONWERTUJÄ„CY (CASTOWANIE)

Jak parser powie: â€to jest doubleâ€, to dopiero teraz:
zamieniasz string â†’ double
double â†’ float
double â†’ int
double â†’ char

i zapisujesz wyniki (albo â€impossibleâ€).

To samo dla kaÅ¼dego typu.
Tu wÅ‚aÅ›nie uÅ¼ywasz:
std::stoi
std::stol
std::stof
std::stod
rzutowania (char), (int) itd.
Czyli:
â€JeÅ›li znam oryginalny typ â†’ zamieniam go na pozostaÅ‚eâ€.

âœ… CO TO JEST CASTOWANIE?
Castowanie (â€rzutowanieâ€) to zamiana jednej wartoÅ›ci na innÄ… wartoÅ›Ä‡ w innym typie danych.
MÃ³wiÄ…c po ludzku:
ğŸ‘‰ Masz wartoÅ›Ä‡ typu A
ğŸ‘‰ i chcesz zrobiÄ‡ z niej wartoÅ›Ä‡ typu B

np.
double â†’ int
int â†’ char
char â†’ float
float â†’ double
To wÅ‚aÅ›nie castowanie.

Castowanie w Å¼yciu codziennym programisty sÅ‚uÅ¼y do:
Kontroli precyzji w obliczeniach
Manipulacji znakami i ASCII
Optymalizacji pamiÄ™ci
Dopasowania typÃ³w do funkcji/bibliotek
Sprawdzania zakresÃ³w i bezpieczeÅ„stwa
Programowania gier, grafiki i hardware

napisz trim
napisz isPseudoLiteral
napisz isCharLiteral, isIntLiteral, isFloatLiteral, isDoubleLiteral
napisz detectType i testuj wykrywanie typÃ³w (bez konwersji)
napisz safeParseInt, safeParseFloat, safeParseDouble, parseChar
zdefiniuj Result
napisz convertFromInt, convertFromChar, convertFromFloat, convertFromDouble
napisz printResult
zÅ‚oÅ¼ convert() z powyÅ¼szych i testuj kompletne przypadki

Funkcja strtol
Jak dziaÅ‚a krok po kroku

strtol przetwarza string znak po znaku, ignorujÄ…c poczÄ…tkowe spacje.
JeÅ›li pierwszy znak to + lub - â†’ zapisuje znak liczby.
NastÄ™pnie czyta kolejne cyfry, aÅ¼ napotka znak nie bÄ™dÄ…cy cyfrÄ….
JeÅ›li nie ma Å¼adnej cyfry â†’ wynik = 0 i endptr = nptr.
JeÅ›li liczba jest wiÄ™ksza niÅ¼ LONG_MAX lub mniejsza niÅ¼ LONG_MIN â†’ ustawia errno = ERANGE i zwraca LONG_MAX lub LONG_MIN.
endptr pozwala Ci sprawdziÄ‡, czy caÅ‚y string zostaÅ‚ poprawnie odczytany.

Dlaczego to dziaÅ‚a lepiej niÅ¼ atoi
atoi po prostu zwraca int â†’ przepeÅ‚nienie nie jest wykrywane â†’ wynik moÅ¼e byÄ‡ zupeÅ‚nie niepoprawny.
strtol zwraca long â†’ daje wiÄ™kszy zakres i informuje, jeÅ›li liczba nie mieÅ›ci siÄ™ w typie.
Dodatkowo daje endptr, wiÄ™c moÅ¼na sprawdziÄ‡, czy w stringu nie byÅ‚o dodatkowych znakÃ³w (np. spacji w Å›rodku).


char *endptr;
errno = 0;
double val = strtod(str.c_str(), &endptr);
strtod konwertuje string na double.
endptr wskaÅ¼e, gdzie konwersja siÄ™ zatrzymaÅ‚a.
errno = 0 â†’ resetujemy zmiennÄ… bÅ‚Ä™du, Å¼eby pÃ³Åºniej sprawdziÄ‡ overflow/underflow.

if (*endptr != '\0' || errno == ERANGE)
{
	std::cout << "Conversion error" << std::endl;
	return (0);
}
Sprawdzamy, czy caÅ‚a reszta stringa zostaÅ‚a poprawnie przetworzona:
JeÅ›li *endptr != '\0' â†’ po liczbie sÄ… jeszcze jakieÅ› znaki â†’ bÅ‚Ä…d.

errno == ERANGE â†’ wartoÅ›Ä‡ poza zakresem typu double â†’ bÅ‚Ä…d.
	char c = static_cast<char>(val);
	int i = static_cast<int>(val);
	float f = static_cast<float>(val);
Tworzymy rzutowania do rÃ³Å¼nych typÃ³w:
char â†’ do ASCII (drukowalny znak).
int â†’ do liczby caÅ‚kowitej.
float â†’ do floata (z koÅ„cÃ³wkÄ… .0f pÃ³Åºniej przy drukowaniu).

1ï¸âƒ£ Co robi static_cast
static_cast to operator rzutowania w C++.
Pozwala nam zamieniÄ‡ wartoÅ›Ä‡ z jednego typu na inny typ, w sposÃ³b kontrolowany przez kompilator.

PrzykÅ‚ad:
double val = 3.14;
float f = static_cast<float>(val); // rzutujemy double na float


Co siÄ™ dzieje?
val jest typu double (8 bajtÃ³w, wiÄ™ksza precyzja).
static_cast<float>(val) mÃ³wi kompilatorowi: chcÄ™ tÄ™ liczbÄ™ przechowaÄ‡ jako float (4 bajty).
Kompilator wykonuje konwersjÄ™, zmniejszajÄ…c precyzjÄ™ do typu float.

2ï¸âƒ£ Dlaczego < >?

Nawiasy < > w static_cast<typ> okreÅ›lajÄ… typ, na ktÃ³ry chcemy rzutowaÄ‡.
Po tym typie w nawiasach stoi wyraÅ¼enie do konwersji
Schemat:
static_cast<docelowy_typ>(wyrazenie)

PrzykÅ‚ad:
int x = 10;
double d = static_cast<double>(x); // int â†’ double
Bez < > nie da siÄ™ powiedzieÄ‡ kompilatorowi, na jaki typ ma konwertowaÄ‡.

3ï¸âƒ£ Dlaczego uÅ¼ywamy static_cast, a nie starego (float)val?
Jest bezpieczniejsze i bardziej czytelne niÅ¼ stare rzutowanie C: (float)val.
static_cast:

Jest kontrolowane przez kompilator.
Lepiej widaÄ‡, co jest rzutowane i na jaki typ.
Nie pozwala np. przypadkowo rzutowaÄ‡ wskaÅºnikÃ³w na niekompatybilne typy.

4ï¸âƒ£ PrzykÅ‚ad z Twojego kodu
double val = 66.0;
char c = static_cast<char>(val);   // 66 â†’ 'B'
int i = static_cast<int>(val);     // 66 â†’ 66
float f = static_cast<float>(val); // 66.0 â†’ 66.0f

char c â†’ sprawdzamy, czy wartoÅ›Ä‡ mieÅ›ci siÄ™ w ASCII.
int i â†’ zamieniamy na int.
float f â†’ zamieniamy na float, Å¼eby potem wypisaÄ‡ z .0f.

ğŸ’¡ Podsumowanie:
static_cast to bezpieczny sposÃ³b konwersji typÃ³w.
<float> mÃ³wi, Å¼e chcemy float.
(val) to wartoÅ›Ä‡, ktÃ³rÄ… chcemy rzutowaÄ‡.
W Twojej funkcji pozwala Å‚atwo zrobiÄ‡ float, int i char z jednej liczby typu double.