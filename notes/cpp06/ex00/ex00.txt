2. Co musi robiÄ‡ TwÃ³j program?
Twoje ./convert <literal> powinno:
WykryÄ‡ typ przekazanego literaÅ‚u:

â€™aâ€™ â†’ char
42 â†’ int
4.2f â†’ float
4.2 â†’ double

nanf / +inff / -inff â†’ float specjalne
nan / +inf / -inf â†’ double specjalne

PrzekonwertowaÄ‡ go na pozostaÅ‚e typy, z obsÅ‚ugÄ…:

nadmiaru (overflow)
konwersji niemoÅ¼liwej
znakÃ³w niedrukowalnych

WyÅ›wietliÄ‡ wynik w dokÅ‚adnym formacie, np.:
char: '*'
int: 42
float: 42.0f
double: 42.0


ETAP 1 â€” Zrozumienie celu

Musisz napisaÄ‡:
parser typu literaÅ‚u
konwerter miÄ™dzy typami
formater wyjÅ›cia
Wszystko zamkniÄ™te w jednej metodzie convert.

ETAP 2 â€” Zablokowanie tworzenia obiektu ScalarConverter

Klasa ma zawieraÄ‡ tylko statycznÄ… funkcjÄ™.
Blokujesz konstruktory.

ETAP 3 â€” Wykrywanie typu wejÅ›ciowego

To jest najwaÅ¼niejsza czÄ™Å›Ä‡.

Musisz wykrywaÄ‡:

1) char

format 'c'
dÅ‚ugoÅ›Ä‡ == 3
pierwszy znak ' i ostatni '

2) int

tylko cyfry z opcjonalnym znakiem + lub -
Å¼adnych kropek
Å¼adnego â€fâ€ na koÅ„cu

3) float (zwykÅ‚y)

musi zawieraÄ‡ kropkÄ™
musi koÅ„czyÄ‡ siÄ™ na f

4) float (pseudoliteraly)

"nanf"
"+inff"
"-inff"

5) double (zwykÅ‚y)
musi zawieraÄ‡ kropkÄ™
nie koÅ„czy siÄ™ na f

6) double (pseudoliteraly)

"nan"
"+inf"
"-inf"

ETAP 4 â€” Konwersja

Gdy juÅ¼ wiesz, co to jest:
Konwertujesz string â†’ bazowy typ
Konwertujesz bazowy typ do pozostaÅ‚ych typÃ³w jawnie (C-style albo static_cast)

Dla char:
sprawdzasz czy da siÄ™ wyÅ›wietliÄ‡ (ASCII 32â€“126)

Dla int:
uwaÅ¼asz na overflow (long long â†’ int)

Dla float / double:
wypisujesz odpowiedni sufiks f dla float
specjalne wartoÅ›ci zawsze wypisujesz, nawet gdy inne typy sÄ… â€impossible

2) Doprecyzowanie formatÃ³w wejÅ›cia

char: postaÄ‡ 'c' â€” zawsze 3 znaki: ', znak, '. (ZaÅ‚Ã³Å¼, Å¼e nie podasz niedrukowalnych znakÃ³w.)
int: dziesiÄ™tna notacja, opcjonalny + lub -, bez kropek czy sufiksÃ³w (np. 0, -42, 42).
float: ma mieÄ‡ kropkÄ™ i koÅ„czyÄ‡ siÄ™ f (np. 4.2f, -0.0f), oraz pseudoliteraly: nanf, +inff, -inff.
double: ma kropkÄ™, nie koÅ„czy siÄ™ f (np. 4.2, 0.0), oraz pseudoliteraly: nan, +inf, -inf.
Uwaga: wejÅ›cia typu 42.0 â†’ double; 42.0f â†’ float. 42 â†’ int. 'a' â†’ char.

3) Co wyÅ›wietlasz w kaÅ¼dej konwersji

Dla kaÅ¼dego z czterech typÃ³w musisz wypisaÄ‡ jednÄ… z moÅ¼liwoÅ›ci:
poprawna wartoÅ›Ä‡ (np. int: 42, float: 42.0f, double: 42.0, char: 'A'),
impossible â€” gdy konwersja logicznie nie ma sensu (np. nan â†’ int),
Non displayable â€” gdy wartoÅ›Ä‡ istnieje, ale char nie jest drukowalny (np. wynik to ASCII 10),
odpowiedni format pseudoliterali (nanf, nan, +inff, +inf, itd.).


Typowy algorytm dziaÅ‚ania funkcji convert
Trim wejÅ›cia (usuÅ„ biaÅ‚e znaki) â€” najlepiej wymagaÄ‡ braku spacji, ale dobry parser moÅ¼e tolerowaÄ‡.
SprawdÅº pseudoliteraly najpierw (porÃ³wnanie stringÃ³w do nan, nanf, +inf, -inff itd.). JeÅ›li trafione â€” obsÅ‚uÅ¼ jako osobny przypadek.
SprawdÅº char: czy string ma format 'x'. JeÅ›li tak â€” baza = char.
SprawdÅº int: czy caÅ‚y string pasuje do wzoru ^[+-]?\d+$ â†’ baza = int.
SprawdÅº float: czy koÅ„czy siÄ™ f i przed f jest poprawna notacja liczby z kropkÄ… lub bez (np. 42f to ambiwalentne â€” zadanie jednak zakÅ‚ada kropkÄ™; trzymaj siÄ™ reguÅ‚y: float ma kropkÄ™). MoÅ¼esz rozrÃ³Å¼niaÄ‡: jeÅ¼eli koÅ„czy f â†’ sprÃ³buj std::stof.
SprawdÅº double: w przeciwnym wypadku, jeÅ›li string zawiera kropkÄ™ â†’ sprÃ³buj std::stod.
JeÅ›li nic nie pasuje â†’ wypisz komunikat o bÅ‚Ä™dzie (np. unknown literal albo impossible).


7) Formatowanie wyniku (zalecenia)

Dla float zawsze dodaj sufiks f (np. 0.0f, 42.0f).
Zachowaj jednÄ… cyfrÄ™ po przecinku, gdy to potrzeba (np. 42.0 zamiast 42) â€” zadanie w przykÅ‚adach pokazuje .0 gdy to liczba caÅ‚kowita w formacie float/double. MoÅ¼esz to osiÄ…gnÄ…Ä‡ uÅ¼ywajÄ…c std::fixed + ustawienie precyzji (np. std::setprecision(1)), ale pamiÄ™taj, Å¼eby dla wartoÅ›ci typu nan/inf nie uÅ¼ywaÄ‡ fixed/precyzji â€” wypisz tekstowe reprezentacje.
Dla char wypisz 'c' (z apostrofami) gdy jest drukowalny.

ğŸ”¥ CO ZNACZY â€KLSA NIE POWINNA BYÄ† INSTANCJOWALNAâ€?
To znaczy:
UÅ¼ytkownik NIE moÅ¼e zrobiÄ‡ czegoÅ› takiego:
ScalarConverter s;    // âŒ niedozwolone
lub:
ScalarConverter *ptr = new ScalarConverter();   // âŒ niedozwolone
Czyli nie moÅ¼na tworzyÄ‡ obiektÃ³w tej klasy.

ğŸ”¥ CO MASZ ZROBIÄ†, Å»EBY TAK BYÅO?
1) ZrobiÄ‡ wszystkie metody statyczne

NajwaÅ¼niejsza jest jedna metoda:
static void convert(std::string const & literal);
Statyczna = woÅ‚asz jÄ… tak:
ScalarConverter::convert("42.0f");
Bez tworzenia obiektu.

2) ZABLOKOWAÄ† KONSTRUKTOR

To kluczowy element:
musisz sprawiÄ‡, Å¼e konstruktora nie da siÄ™ uÅ¼yÄ‡.
Robi siÄ™ to tak:
deklarujesz konstruktor jako private
deklarujesz destruktor jako private
deklarujesz copy constructor i operator= jako private
nie piszesz implementacji
(Å¼eby kompilator nie pozwoliÅ‚ ich uÅ¼yÄ‡)

Efekt:
kaÅ¼dy, kto sprÃ³buje utworzyÄ‡ obiekt â†’ dostanie bÅ‚Ä…d kompilacji.

ğŸ”¥ Dlaczego konstruktor jest â€œpustyâ€?
JeÅ›li metoda jest tylko zadeklarowana:
ScalarConverter();
â€¦to oznacza:
kompilator wie, Å¼e konstruktor istnieje
ale nikt spoza klasy nie ma do niego dostÄ™pu (bo jest private)
a Ty nie implementujesz go, bo nigdy nie bÄ™dzie uÅ¼yty
To jest w peÅ‚ni poprawne.

ğŸ”¥ Dlaczego NIE piszemy implementacji w .cpp?

Bo:
Te metody i tak nigdy nie bÄ™dÄ… wywoÅ‚ane.
Ich jedyny sens to zakazaÄ‡ instancjowania.
JeÅ›li ktoÅ› SPRÃ“BUJE ich uÅ¼yÄ‡ (np. przez pomyÅ‚kÄ™), to i tak:
dostanie bÅ‚Ä…d kompilacji (bo sÄ… private)
a gdyby udaÅ‚o siÄ™ jakoÅ› obejÅ›Ä‡ (co jest prawie niemoÅ¼liwe), brak implementacji wywoÅ‚a bÅ‚Ä…d linkera â†’ i to dobrze, bo klasa ma byÄ‡ nieuÅ¼ywalna jako obiekt.

W tym zadaniu liczy siÄ™ tylko convert(), a nie cykl Å¼ycia obiektu.
Dlatego puste deklaracje wystarczÄ… i sÄ… normalnÄ… praktykÄ… w C++.

ğŸ”¥ Czy to jest â€œdziwneâ€?
Nie â€” to standardowy sposÃ³b w C++ na blokowanie tworzenia obiektÃ³w.

Tak robi siÄ™ w:
klasach narzÄ™dziowych (utility classes)
klasach singletonowych (stare podejÅ›cie)
klasach statycznych (np. konwertery, loggery)
bibliotekach STL (np. niektÃ³re klasy pomocnicze)
systemie plikÃ³w <filesystem>
To jest uznany, profesjonalny wzorzec.
Konstruktory sÄ… puste, bo majÄ… istnieÄ‡ tylko po to, Å¼eby zablokowaÄ‡ tworzenie obiektÃ³w â€” a skoro NIKT nigdy ich nie wywoÅ‚a, nie potrzebujÄ… Å¼adnej implementacji.


ğŸ”¥ NA CO PARSER MA POZWALAÄ†, A NA CO MA REAGOWAÄ† BÅÄ˜DEM?

PoniÅ¼ej masz kompletnÄ… listÄ™ przypadkÃ³w, ktÃ³re musisz obsÅ‚uÅ¼yÄ‡.
Po przeczytaniu tego wiesz dokÅ‚adnie co robiÄ‡.

1) CHAR
Format:
'a', 'b', '@', '#'

Warunki:
dÅ‚ugoÅ›Ä‡ = 3
pierwszy znak '
ostatni znak '
Å›rodkowy znak to 1 znak ASCII
Akceptujesz:
'a', 'Z', '+', ' '

Odrzucasz:
'ab'
a
"a"
' 'a'
'
2) INT

Format:
0, -42, +42, 123456

Warunki:
opcjonalnie + lub - na poczÄ…tku
reszta MUSI byÄ‡ cyframi
NIE moÅ¼e byÄ‡:

kropki
litery
sufiksu f
spacji
innych znakÃ³w

Akceptujesz:
0, -42, 42, +1234

Odrzucasz:
42.0 (to double)
42f (niepoprawne)
4a
123 4
--42

3) FLOAT (NORMALNE)
Format:
4.2f, 0.0f, -1.25f

Warunki:
musi zawieraÄ‡ kropkÄ™
musi koÅ„czyÄ‡ siÄ™ f
przed f musi byÄ‡ poprawna liczba
znak + lub - na poczÄ…tku dozwolony

Akceptujesz:
4.2f, 0.0f, -4.0f, +3.5f

Odrzucasz:
4f (brak kropki â†’ niezalecane)
4.f (rÃ³Å¼ne implementacje: Ty moÅ¼esz przyjÄ…Ä‡ Å¼e musi byÄ‡ cyfra przed i po)
4.2ff
4.2 (to double)
.5f (w module 06 niezalecane)

4) FLOAT (PSEUDOLITERALS)

Tylko te 3:
nanf
+inff
-inff

Akceptujesz 100% zawsze
Bo one oznaczajÄ… specjalne wartoÅ›ci IEEE.

Nie prÃ³bujesz ich parsowaÄ‡ jako liczby.
Od razu uznajesz: â€to float pseudoâ€.

5) DOUBLE (NORMALNE)

Format:
4.2, 0.0, -1.25

Warunki:
musi mieÄ‡ kropkÄ™
NIE moÅ¼e mieÄ‡ f na koÅ„cu
musi to byÄ‡ poprawna notacja liczby dziesiÄ™tnej

Akceptujesz:
4.2, 0.0, -1.25

Odrzucasz:
4.
.4
4.2f
4,2 (przecinek = bÅ‚Ä…d)
4.2.1

6) DOUBLE (PSEUDOLITERALS)

Tylko te 3:
nan
+inf
-inf
To sÄ… dokÅ‚adnie odpowiedniki double bez sufiksu f.

7) CO, JEÅšLI KTOÅš WPISZE STRING TYPU:
hello
a12
f
something
abc123
"tekst"

ğŸ‘‰ Masz zwrÃ³ciÄ‡: "impossible" dla wszystkich konwersji
Albo wypisaÄ‡ informacyjnie, Å¼e literaÅ‚ jest bÅ‚Ä™dny.
To nie jest poprawny literaÅ‚ C++, wiÄ™c parser ma go odrzuciÄ‡.
PrzykÅ‚ad:
./convert hello
char: impossible
int: impossible
float: impossible
double: impossible

ğŸ”¥ PODSUMOWANIE â€“ PARSER MA OBSÅUÅ»YÄ† TYLKO TE KATEGORIE:

'c' â†’ char
[+-]?\d+ â†’ int
[+-]?\d+\.\d+f â†’ float
[+-]?\d+\.\d+ â†’ double

nanf, +inff, -inff â†’ float pseudo
nan, +inf, -inf â†’ double pseudo
wszystko inne â†’ zÅ‚e dane

