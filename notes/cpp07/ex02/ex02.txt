Co ma robiÄ‡ ten program?

Tworzysz klasÄ™ szablonowÄ… Array<T>, ktÃ³ra dziaÅ‚a jak tablica, ale na wÅ‚asnych zasadach.
Tablica ma dynamiczny rozmiar â€“ moÅ¼esz okreÅ›liÄ‡ liczbÄ™ elementÃ³w lub stworzyÄ‡ pustÄ… tablicÄ™.

MoÅ¼esz:
dodawaÄ‡ elementy przez arr[i],
kopiowaÄ‡ tablicÄ™ (konstruktor kopiujÄ…cy i operator przypisania),
sprawdzaÄ‡ liczbÄ™ elementÃ³w przez size().
JeÅ›li sprÃ³bujesz odwoÅ‚aÄ‡ siÄ™ do elementu poza zakresem â†’ program rzuca wyjÄ…tek.
Czyli program ma byÄ‡ â€œbezpiecznÄ… tablicÄ…â€, ktÃ³rej uÅ¼ycie nie powoduje bÅ‚Ä™dÃ³w typu out-of-bounds i dziaÅ‚a dla dowolnego typu danych

Dlaczego sÄ… rÃ³Å¼ne pliki?
Array.hpp / Array.h â†’ deklarujesz klasÄ™ i jej funkcje.
Array.tpp (opcjonalny) â†’ moÅ¼esz tam przenieÅ›Ä‡ implementacjÄ™ funkcji szablonu, Å¼eby plik .hpp byÅ‚ czytelniejszy.

RÃ³Å¼nica z .tpp lub bez niego:
Bez .tpp â†’ caÅ‚a klasa wraz z kodem funkcji jest w Array.hpp.
Z .tpp â†’ w .hpp tylko deklaracje, a w .tpp implementacja. W .hpp robisz:
#include "Array.tpp" // na koÅ„cu pliku
Dlaczego to opcjonalne:
Szablony w C++ muszÄ… mieÄ‡ kod dostÄ™pny w momencie kompilacji,
wiÄ™c nie moÅ¼esz po prostu wrzuciÄ‡ implementacji do .cpp. .tpp to tylko sposÃ³b na porzÄ…dek 
â€“ nie zmienia dziaÅ‚ania programu.
Czyli w skrÃ³cie: tworzysz wÅ‚asnÄ… bezpiecznÄ… tablicÄ™, ktÃ³ra dziaÅ‚a dla dowolnego typu i jest w peÅ‚ni dynamiczna.

Array<T> object:
+---------------------+
| T* ptr â†’ dynamiczna tablica w pamiÄ™ci |
| unsigned int size   |
+---------------------+

Operacje:
- Konstruktor: alokuje pamiÄ™Ä‡ i ustawia size
- Konstruktor kopiujÄ…cy: tworzy nowy blok, kopiuje wartoÅ›ci
- Operator=: zwalnia starÄ… pamiÄ™Ä‡, alokuje nowÄ…, kopiuje wartoÅ›ci
- operator[]: dostÄ™p z kontrolÄ… zakresu
- size(): zwraca size


Deklaracja klasy szablonowej

UtwÃ³rz szablon klasy Array<T>.
Zdefiniuj pola prywatne: wskaÅºnik na tablicÄ™ i licznik elementÃ³w.
Konstruktor bez parametrÃ³w
Tworzy pustÄ… tablicÄ™.
Ustaw licznik elementÃ³w na 0.
WskaÅºnik tablicy powinien byÄ‡ pusty (nullptr).

Konstruktor z rozmiarem
Przyjmuje liczbÄ™ elementÃ³w.
Tworzy dynamicznÄ… tablicÄ™ o zadanym rozmiarze.
Inicjalizuje wszystkie elementy domyÅ›lnie.
Ustaw licznik elementÃ³w.

Konstruktor kopiujÄ…cy
Tworzy nowÄ… tablicÄ™ kopiujÄ…c wszystkie elementy z innej tablicy.
Modyfikacja kopii nie zmienia oryginaÅ‚u (deep copy).

Operator przypisania
Sprawdza, czy nie przypisujesz tablicy do samej siebie.
Zwalnia starÄ… pamiÄ™Ä‡.
Tworzy nowÄ… tablicÄ™ i kopiuje elementy.

Destruktor
Zwalnia dynamicznie przydzielonÄ… pamiÄ™Ä‡.

Operator indeksowania [ ]
Pozwala odczytaÄ‡ lub zmieniÄ‡ element pod danym indeksem.
JeÅ›li indeks jest poza zakresem â†’ rzuca wyjÄ…tek.

Funkcja size()
Zwraca liczbÄ™ elementÃ³w w tablicy.
Nie zmienia tablicy.

Tworzenie plikÃ³w
Array.hpp â†’ deklaracja klasy i opcjonalnie implementacja.
Array.tpp (opcjonalny) â†’ implementacja funkcji szablonu.

main.cpp â†’ testowanie dziaÅ‚ania tablicy:
Tworzenie tablic.
Wstawianie i odczytywanie elementÃ³w.
Kopiowanie i przypisywanie tablic.
Sprawdzenie rzucania wyjÄ…tkÃ³w.
WyÅ›wietlanie rozmiaru tablicy.


W skrÃ³cie:

StworzyÄ‡ klasÄ™ szablonowÄ… Array<T>.

ZaimplementowaÄ‡ jÄ… w orthodox canonical form:
Konstruktor domyÅ›lny
Konstruktor z rozmiarem
Konstruktor kopiujÄ…cy
Operator przypisania
Destruktor

ZapewniÄ‡:
DynamicznÄ… alokacjÄ™ pamiÄ™ci dla elementÃ³w (new[]).
DostÄ™p przez [ ] z kontrolÄ… zakresu (rzucanie wyjÄ…tku przy out-of-bounds).
FunkcjÄ™ size() zwracajÄ…cÄ… liczbÄ™ elementÃ³w.
TestowaÄ‡ w main.cpp: tworzenie tablic, kopiowanie, przypisywanie, dostÄ™p do elementÃ³w, rzucanie wyjÄ…tkÃ³w.

PodsumowujÄ…c jednym zdaniem:
Tworzysz bezpiecznÄ…, dynamicznÄ… tablicÄ™ szablonowÄ…, 
ktÃ³ra dziaÅ‚a poprawnie w kaÅ¼dej sytuacji (kopiowanie, 
przypisanie, dostÄ™p do elementÃ³w) i informuje o rozmiarze oraz bÅ‚Ä™dach
 przy nieprawidÅ‚owym indeksie.


 CaÅ‚a klasa jest szablonem:

template <typename T>
class Array { ... };

T to typ przechowywanych elementÃ³w (int, double, std::string, cokolwiek).
Wszystkie funkcje, ktÃ³re dziaÅ‚ajÄ… na tej klasie, teÅ¼ sÄ… funkcjami szablonowymi, np.:

Konstruktor domyÅ›lny
Konstruktor z rozmiarem
Konstruktor kopiujÄ…cy
Operator przypisania
Operator [ ]
Funkcja size()

Dlaczego szablony:

Bo chcesz, Å¼eby ta sama klasa dziaÅ‚aÅ‚a dla dowolnego typu, nie tylko dla int.
Gdy napiszesz Array<int>, kompilator wstawi typ int w miejsce T.
Gdy napiszesz Array<std::string>, kompilator wstawi std::string w miejsce T.

ğŸ’¡ PodsumowujÄ…c
.tpp = plik z implementacjÄ… funkcji szablonu, doÅ‚Ä…czany w .hpp.
Szablon = template <typename T> w caÅ‚ej klasie i jej funkcjach.
DziÄ™ki temu Twoja tablica dziaÅ‚a dla dowolnego typu danych, a nie tylko np. int.