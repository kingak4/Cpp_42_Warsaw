1ï¸âƒ£ Deklaracja funkcji szablonowej
template <typename T>
typename T::iterator easyfind(T &container, int value)

template <typename T> â†’ to szablon: funkcja dziaÅ‚a dla kaÅ¼dego typu kontenera T (np. vector<int>, list<int>).
T &container â†’ funkcja przyjmuje kontener przez referencjÄ™, czyli dziaÅ‚a bez kopiowania caÅ‚ego kontenera.
int value â†’ liczba, ktÃ³rÄ… chcemy znaleÅºÄ‡.
typename T::iterator â†’ funkcja zwraca iterator do elementu w kontenerze (iterator to coÅ› jak wskaÅºnik do miejsca w kontenerze).

2ï¸âƒ£ Szukanie elementu
typename T::iterator it = std::find(container.begin(), container.end(), value);
std::find przeszukuje kontener od poczÄ…tku (container.begin()) do koÅ„ca (container.end()) w poszukiwaniu wartoÅ›ci value.

Zwraca iterator:
jeÅ›li element istnieje â†’ iterator wskazuje na niego
jeÅ›li elementu nie ma â†’ iterator jest rÃ³wny container.end()

3ï¸âƒ£ Sprawdzenie, czy element zostaÅ‚ znaleziony
if (it == container.end())
    throw std::runtime_error("Value not found");
PorÃ³wnujemy iterator it z container.end().
JeÅ›li sÄ… rÃ³wne â†’ elementu nie ma w kontenerze
Wtedy rzucamy wyjÄ…tek std::runtime_error, ktÃ³ry moÅ¼na potem zÅ‚apaÄ‡ w try/catch.

4ï¸âƒ£ ZwrÃ³cenie iteratora
return it;
JeÅ›li element zostaÅ‚ znaleziony, zwracamy iterator wskazujÄ…cy na ten element.
MoÅ¼esz potem w main.cpp zrobiÄ‡ np. *it, Å¼eby dostaÄ‡ wartoÅ›Ä‡ elementu.

âœ… Podsumowanie prostymi sÅ‚owami

Ta funkcja:
Szuka podanej liczby w kontenerze.
JeÅ›li znajdzie â†’ zwraca wskaÅºnik (iterator) do tej liczby.
JeÅ›li nie znajdzie â†’ zgÅ‚asza bÅ‚Ä…d (wyjÄ…tek).

1ï¸âƒ£ Co to jest kontener w C++
Kontener to specjalny rodzaj â€œpojemnikaâ€, ktÃ³ry przechowuje wiele elementÃ³w w uporzÄ…dkowany sposÃ³b.

PrzykÅ‚ady:
std::vector<int> â€“ dynamiczna tablica, moÅ¼esz dodawaÄ‡ elementy na koÅ„cu, szybko je odczytaÄ‡ po indeksie.
std::list<int> â€“ lista dwukierunkowa, szybkie wstawianie/usuwanie w Å›rodku, ale wolniejsze indeksowanie.
std::deque<int> â€“ coÅ› jak wektor, ale moÅ¼na szybko dodawaÄ‡ i usuwaÄ‡ elementy na poczÄ…tku i koÅ„cu.
W skrÃ³cie: kontener to jak pudeÅ‚ko na wartoÅ›ci, ktÃ³re daje Ci rÃ³Å¼ne sposoby pracy z tymi wartoÅ›ciami.

2ï¸âƒ£ Jak dziaÅ‚a kontener

KaÅ¼dy kontener pozwala na:
Dodawanie elementÃ³w

std::vector<int> v;
v.push_back(5); // dodaje 5 na koÅ„cu

DostÄ™p do elementÃ³w
Po indeksie (np. vector)
Przez iteratory (wskaÅºniki) â€“ dziaÅ‚a w kaÅ¼dym kontenerze

Iterowanie po elementach
Kontenery majÄ… iteratory, czyli specjalne wskaÅºniki, ktÃ³re pozwalajÄ… przechodziÄ‡ po kaÅ¼dym elemencie w pÄ™tli.
PrzykÅ‚ad: begin() zwraca iterator na pierwszy element, end() na â€œpozycjÄ™ za ostatnim elementemâ€.

3ï¸âƒ£ Iteratory w skrÃ³cie
Iteratory to wskaÅºniki do elementÃ³w kontenera, ktÃ³re pozwalajÄ…:
czytaÄ‡ element â†’ *it
przechodziÄ‡ do nastÄ™pnego â†’ ++it
porÃ³wnywaÄ‡ â†’ it == container.end()
DziÄ™ki iteratorom moÅ¼esz pisaÄ‡ funkcje szablonowe, ktÃ³re dziaÅ‚ajÄ… z rÃ³Å¼nymi typami kontenerÃ³w, np. vector, list, deque.

4ï¸âƒ£ Jak kontener jest uÅ¼yty w easyfind
Funkcja easyfind dostaje kontener jako argument:
easyfind(vector<int>, 3);

NastÄ™pnie uÅ¼ywa iteratorÃ³w begin() i end(), Å¼eby przeszukaÄ‡ wszystkie elementy w kontenerze.
JeÅ›li znajdzie szukanÄ… wartoÅ›Ä‡ â†’ zwraca iterator, czyli â€œwskaÅºnikâ€ do tego elementu w kontenerze.

ğŸ’¡ Prosta analogia:
Kontener = pudeÅ‚ko z piÅ‚eczkami (liczbami).
Iterator = palec, ktÃ³ry wskazuje na konkretnÄ… piÅ‚eczkÄ™.
easyfind = rÄ…czka, ktÃ³ra przesuwa palec po pudeÅ‚ku, aÅ¼ znajdzie wÅ‚aÅ›ciwÄ… piÅ‚eczkÄ™, albo krzyczy, Å¼e jej nie ma.

Podstawowa rÃ³Å¼nica: kontener vs tablica

| Cecha                        | Tablica (array)                                                 | Kontener (np. vector, list)                                                      |
| ---------------------------- | --------------------------------------------------------------- | -------------------------------------------------------------------------------- |
| **Rozmiar**                  | StaÅ‚y (np. `int a[10]`) lub dynamiczny z `new`                  | Zazwyczaj dynamiczny, moÅ¼na dodawaÄ‡/usuwaÄ‡ elementy w trakcie dziaÅ‚ania programu |
| **Przechowywanie**           | Proste miejsce w pamiÄ™ci, elementy sÄ… obok siebie (ciÄ…gÅ‚y blok) | MoÅ¼e mieÄ‡ rÃ³Å¼ne struktury: ciÄ…gÅ‚a pamiÄ™Ä‡ (`vector`), lista Å‚Ä…czona (`list`)      |
| **Funkcje gotowe do uÅ¼ycia** | Prawie brak, trzeba pisaÄ‡ wÅ‚asne                                | Bogactwo metod: dodawanie, usuwanie, sortowanie, szukanie itp.                   |
| **BezpieczeÅ„stwo**           | Brak kontroli zakresu (Å‚atwo wyjÅ›Ä‡ poza tablicÄ™)                | Bezpieczniejsze: np. `vector::at(i)` sprawdza indeks                             |
| **Iteratory**                | Nie ma, uÅ¼ywa siÄ™ wskaÅºnikÃ³w (`int*`)                           | Tak, pozwalajÄ… przechodziÄ‡ po elementach w sposÃ³b uniwersalny                    |


3ï¸âƒ£ Zalety kontenerÃ³w nad zwykÅ‚ymi tablicami
ÅatwoÅ›Ä‡ uÅ¼ycia â€“ nie trzeba pamiÄ™taÄ‡ o alokacji i zwalnianiu pamiÄ™ci (w przypadku vector).
BezpieczeÅ„stwo â€“ metody takie jak .at() chroniÄ… przed dostÄ™pem poza zakres.
Wbudowane operacje â€“ sortowanie, wyszukiwanie, usuwanie elementÃ³w.
ElastycznoÅ›Ä‡ â€“ rÃ³Å¼ne rodzaje kontenerÃ³w dopasowane do potrzeb (szybki dostÄ™p vs szybkie wstawianie).
Iteratory â€“ uniwersalny sposÃ³b na przeglÄ…danie danych, dziaÅ‚a dla wszystkich kontenerÃ³w.

4ï¸âƒ£ Wady kontenerÃ³w
WiÄ™kszy narzut pamiÄ™ci i mniejsza wydajnoÅ›Ä‡ niÅ¼ prosta tablica w niektÃ³rych przypadkach, np. list wymaga dodatkowych wskaÅºnikÃ³w.
Mniej kontrolowane zachowanie pamiÄ™ci â€“ programista nie zawsze wie dokÅ‚adnie, ile pamiÄ™ci zajmie kontener.
Nieco wolniejsze operacje w niektÃ³rych kontenerach w porÃ³wnaniu z tablicÄ…, np. wstawianie w vector w Å›rodku wymaga przesuniÄ™cia elementÃ³w.

5ï¸âƒ£ Proste podsumowanie
Tablica = prosta, szybka, staÅ‚a struktura pamiÄ™ci, minimalny narzut.
Kontener = bardziej elastyczny, bezpieczny i bogaty w funkcje, uÅ¼ywany praktycznie zawsze w nowoczesnym C++ do przechowywania i manipulowania danymi.
ğŸ’¡ Z perspektywy programisty: uÅ¼ywasz kontenerÃ³w, gdy chcesz wygody, bezpieczeÅ„stwa i uniwersalnoÅ›ci. 
Tablice uÅ¼ywasz tylko wtedy, gdy waÅ¼na jest maksymalna wydajnoÅ›Ä‡ i minimalny narzut pamiÄ™ci.

RÃ³Å¼nica: int[] vs vector<int>
| Cecha          | `int[]` | `vector<int>` |
| -------------- | ------- | ------------- |
| Rozmiar        | staÅ‚y   | dynamiczny    |
| BezpieczeÅ„stwo | niskie  | wyÅ¼sze        |
| Wygoda         | niska   | wysoka        |
| Iteratory      | nie     | tak           |
| STL            | nie     | tak           |


vector<int> to dynamiczny kontener STL, ktÃ³ry przechowuje liczby typu int i udostÄ™pnia iteratory,
dziÄ™ki czemu moÅ¼na uÅ¼ywaÄ‡ algorytmÃ³w takich jak std::find.

| Potrzeba                 | Kontener        | Funkcja      |
| ------------------------ | --------------- | ------------ |
| Dodawanie na koniec      | `vector`        | `push_back`  |
| Dodawanie na poczÄ…tek    | `list`, `deque` | `push_front` |
| DuÅ¼o losowego dostÄ™pu    | `vector`        | indeks       |
| DuÅ¼o wstawiania/usuwania | `list`          | front/back   |

Iterator musi byÄ‡ tego samego typu co kontener,
po ktÃ³rym siÄ™ porusza, i musi byÄ‡ poprawnie zainicjalizowany.