1. Cel projektu

StworzyÄ‡ klasÄ™ Span, ktÃ³ra:
przechowuje maksymalnie N liczb caÅ‚kowitych
potrafi policzyÄ‡ najmniejszÄ… i najwiÄ™kszÄ… rÃ³Å¼nicÄ™ miÄ™dzy liczbami

2. Konstruktor

Przyjmuje jednÄ… wartoÅ›Ä‡: N (unsigned int)
N = maksymalna liczba elementÃ³w w obiekcie
Po utworzeniu obiekt jest pusty

3. Przechowywanie danych

Musisz mieÄ‡ kontener na liczby (np. wektor)
Kontener nie moÅ¼e przekroczyÄ‡ rozmiaru N

4. addNumber()

Dodaje jednÄ… liczbÄ™
JeÅ›li liczba elementÃ³w == N â†’ rzucasz wyjÄ…tek
KaÅ¼de poprawne dodanie zwiÄ™ksza licznik elementÃ³w

5. Dodawanie wielu liczb naraz

Dodatkowa funkcja:
przyjmuje zakres iteratorÃ³w (poczÄ…tekâ€“koniec)
Dodaje wiele liczb jednym wywoÅ‚aniem
JeÅ›li zakres jest za duÅ¼y i przekroczy N:
rzucasz wyjÄ…tek
nie wolno przepeÅ‚niÄ‡ kontenera

6. shortestSpan()

Liczy najmniejszÄ… rÃ³Å¼nicÄ™ miÄ™dzy dowolnymi dwiema liczbami
Warunek:
jeÅ›li masz mniej niÅ¼ 2 liczby â†’ wyjÄ…tek

Logika:
sortujesz liczby
sprawdzasz rÃ³Å¼nice tylko miÄ™dzy sÄ…siadami
wybierasz najmniejszÄ…

7. longestSpan()

Liczy najwiÄ™kszÄ… rÃ³Å¼nicÄ™

Warunek:
mniej niÅ¼ 2 liczby â†’ wyjÄ…tek

Logika:
znajdujesz min i max
wynik = max - min

8. WyjÄ…tki (obowiÄ…zkowe)

Musisz obsÅ‚uÅ¼yÄ‡:
dodanie elementu ponad N
wywoÅ‚anie shortestSpan() lub longestSpan() przy:
0 elementach
1 elemencie

9. Testy (bardzo waÅ¼ne w 42)

Musisz przetestowaÄ‡:
normalne dane (jak w przykÅ‚adzie)
10 000+ liczb
dodawanie zakresu iteratorÃ³w
przypadki bÅ‚Ä™dne (czy wyjÄ…tki siÄ™ rzucajÄ…)

Do zapamiÄ™tania (waÅ¼ne w C++)
âŒ pole = wartoÅ›Ä‡ â†’ NIE w initializer list
âœ” pole(wartoÅ›Ä‡) â†’ TAK
âŒ nie inicjalizujesz parametrÃ³w
âœ” inicjalizujesz TYLKO pola klasy

1ï¸âƒ£ PorÃ³wnanie wektora z liczbÄ…
nb to wektor (std::vector<int>), a nie liczba
nie moÅ¼na porÃ³wnywaÄ‡ wektora z intem
Musisz porÃ³wnaÄ‡ liczbÄ™ elementÃ³w w wektorze: np. nb.size() vs max_i

2ï¸âƒ£ Dodawanie liczby do wektora
std::vector<int> nie obsÅ‚uguje operatora += z intem
Aby dodaÄ‡ liczbÄ™, trzeba uÅ¼yÄ‡ funkcji push_back(num) lub emplace_back(num)

Funkcja addNumbers(std::vector<int>::iterator from, std::vector<int>::iterator to) â€“ Notatki
Cel funkcji

DodaÄ‡ wiele liczb do obiektu Span naraz, w jednym wywoÅ‚aniu.
ObsÅ‚uÅ¼yÄ‡ limit pojemnoÅ›ci (max_i).
Zakres liczb okreÅ›lany jest przez iteratory [from, to].

Logika dziaÅ‚ania funkcji (krok po kroku)
Policzenie liczby elementÃ³w w zakresie
Tworzymy kopiÄ™ iteratora: tmp = from
Przechodzimy po wszystkich elementach kopii:
while(tmp != to) { i++; tmp++; }
Po pÄ™tli i = liczba elementÃ³w do dodania

Dlaczego kopia? Bo nie chcemy ruszaÄ‡ iteratora from, ktÃ³ry bÄ™dzie uÅ¼yty pÃ³Åºniej do dodawania elementÃ³w.
Sprawdzenie pojemnoÅ›ci
Sprawdzamy: if(nb.size() + i > max_i)
JeÅ›li dodanie wszystkich nowych elementÃ³w przekroczy limit â†’ rzucamy wyjÄ…tek std::runtime_error("Already full!").

Dodanie elementÃ³w do wektora nb
UÅ¼ywamy oryginalnego iteratora from:
while(from != to) { nb.push_back(*from); from++; }
*from = wartoÅ›Ä‡ elementu wskazywanego przez iterator
from++ = przesuniÄ™cie iteratora do kolejnego elementu
Po zakoÅ„czeniu pÄ™tli wszystkie elementy z zakresu [from, to] sÄ… dodane do wektora nb.

Dlaczego iteratory dziaÅ‚ajÄ… inaczej niÅ¼ zwykÅ‚e zmienne typu int
| Cecha                  | Iterator                                                                           | int                               |
| ---------------------- | ---------------------------------------------------------------------------------- | --------------------------------- |
| Co przechowuje         | WskaÅºnik / pozycjÄ™ w kontenerze                                                    | LiczbÄ™ caÅ‚kowitÄ…                  |
| Nie moÅ¼na ustawiÄ‡ na 0 | `from = 0` nie dziaÅ‚a, bo iterator nie jest liczbÄ…, tylko wskaÅºnikiem do kontenera | int moÅ¼na ustawiÄ‡ na 0            |
| Jak odczytaÄ‡ wartoÅ›Ä‡   | `*iterator` = element w kontenerze                                                 | `int` to od razu wartoÅ›Ä‡          |
| Jak przesuwaÄ‡          | `iterator++` = idziemy do nastÄ™pnego elementu w kontenerze                         | int++ = zwiÄ™kszamy wartoÅ›Ä‡ liczby |
| SpecjalnoÅ›Ä‡            | Iterator przechowuje **pozycjÄ™ w kontenerze**, a nie wartoÅ›Ä‡                       | int to po prostu liczba           |


Wniosek:
Iteratory to pozycje w kontenerze, nie liczby.
Nie moÅ¼na ich â€ustawiÄ‡ na 0â€, trzeba je inicjalizowaÄ‡ na poczÄ…tek kontenera lub na innÄ… istniejÄ…cÄ… pozycjÄ™.
Aby pobraÄ‡ wartoÅ›Ä‡ elementu, uÅ¼ywamy *iterator.
Aby przejÅ›Ä‡ dalej, uÅ¼ywamy iterator++.

Schemat dziaÅ‚ania funkcji w skrÃ³cie
1. Liczymy elementy w zakresie (kopiÄ… iteratora)
2. Sprawdzamy, czy zmieszczÄ… siÄ™ w Span
3. Rzucamy wyjÄ…tek jeÅ›li za duÅ¼o
4. Iterujemy po zakresie i dodajemy elementy do nb

ğŸ’¡ Dlaczego nie sortujemy nb bezpoÅ›rednio?
JeÅ›li sortujesz nb, tracisz pierwotnÄ… kolejnoÅ›Ä‡ liczb, ktÃ³re dodawaÅ‚aÅ›
Przy dalszym uÅ¼yciu np. addNumbers() lub w innych obliczeniach moÅ¼e to powodowaÄ‡ bÅ‚Ä™dy
Kopia pozwala Ci pracowaÄ‡ bezpiecznie

1ï¸âƒ£ Funkcja sort()
Pochodzi z biblioteki <algorithm>
SÅ‚uÅ¼y do sortowania elementÃ³w w kontenerze (np. wektorze) rosnÄ…co domyÅ›lnie
Przyjmuje dwa iteratory: poczÄ…tek i koniec zakresu do posortowania

2ï¸âƒ£ Jak dziaÅ‚a na kopii wektora
ZaÅ‚Ã³Å¼my, Å¼e masz kopiÄ™ wektora copy, ktÃ³ra zawiera liczby:
copy.begin() â†’ iterator wskazujÄ…cy pierwszy element wektora
copy.end() â†’ iterator wskazujÄ…cy pierwszy element za ostatnim

sort(copy.begin(), copy.end())
Sortuje wszystkie elementy od poczÄ…tku do koÅ„ca
Nie modyfikuje oryginalnego nb â†’ bezpieczne
Po sortowaniu w copy liczby bÄ™dÄ… uÅ‚oÅ¼one rosnÄ…co

3ï¸âƒ£ Dlaczego musimy uÅ¼yÄ‡ iteratorÃ³w
Funkcja sort() nie dziaÅ‚a na samym wektorze, tylko na zakresie elementÃ³w
Iteratory begin() i end() definiujÄ… dokÅ‚adnie ten zakres

4ï¸âƒ£ Podsumowanie
Kopia wektora = bezpieczna do manipulacji
sort(copy.begin(), copy.end()) â†’ posortuje kopiÄ™


Funkcja shortestSpan() â€“ Notatki
Cel funkcji
ZnaleÅºÄ‡ najkrÃ³tszÄ… rÃ³Å¼nicÄ™ (span) miÄ™dzy wszystkimi liczbami przechowywanymi w wektorze nb w obiekcie Span.

Logika dziaÅ‚ania krok po kroku

Kopiowanie wektora
Tworzymy kopiÄ™: copy = nb
Po co? Å»eby nie zmieniaÄ‡ oryginalnego wektora, bo sortowanie zmieniÅ‚oby kolejnoÅ›Ä‡ liczb w nb
Kopia pozwala manipulowaÄ‡ danymi (sortowaÄ‡) bez ryzyka dla oryginaÅ‚u

Sprawdzenie liczby elementÃ³w
JeÅ›li w wektorze jest mniej niÅ¼ 2 liczby â†’ nie da siÄ™ policzyÄ‡ spanu
Rzucamy wyjÄ…tek: throw std::runtime_error("Need more numbers")

Sortowanie kopii
Funkcja sort(copy.begin(), copy.end()) ukÅ‚ada liczby rosnÄ…co
DziÄ™ki temu najmniejsza rÃ³Å¼nica miÄ™dzy liczbami bÄ™dzie zawsze miÄ™dzy kolejnymi elementami

Deklaracja iteratora / indeksu
UÅ¼ywamy zwykÅ‚ego int i do iterowania po elementach kopii

Dlaczego moÅ¼na uÅ¼yÄ‡ int?
Bo i jest indeksem (pozycjÄ… w wektorze), nie wskaÅºnikiem
Wektor moÅ¼na indeksowaÄ‡ za pomocÄ… copy[i] â†’ Å‚atwe i szybkie
Nie musimy uÅ¼ywaÄ‡ iteratora (std::vector<int>::iterator)
Bo prosta pÄ™tla po indeksach dziaÅ‚a rÃ³wnie dobrze
Iterator przydaje siÄ™ gÅ‚Ã³wnie wtedy, gdy chcemy byÄ‡ uniwersalni dla rÃ³Å¼nych kontenerÃ³w

Inicjalizacja miniSpan
Zmienna miniSpan = duÅ¼a liczba (np. 2147483647)
Po co?
KaÅ¼da pierwsza rÃ³Å¼nica bÄ™dzie mniejsza â†’ zastÄ…pi miniSpan
Pozwala nam znaleÅºÄ‡ najmniejszÄ… rÃ³Å¼nicÄ™ miÄ™dzy sÄ…siednimi elementami

Iteracja i liczenie rÃ³Å¼nic
PÄ™tla: i od 0 do copy.size() - 2 (przedostatni element)
Dla kaÅ¼dej pary sÄ…siednich liczb:
r = copy[i+1] - copy[i] â†’ rÃ³Å¼nica miÄ™dzy kolejnymi elementami
JeÅ›li r < miniSpan â†’ przypisz r do miniSpan
Dlaczego tylko do przedostatniego elementu?
Bo ostatni element nie ma â€nastÄ™pnegoâ€, Å¼eby policzyÄ‡ rÃ³Å¼nicÄ™

ZwrÃ³cenie wyniku
Po zakoÅ„czeniu pÄ™tli miniSpan zawiera najkrÃ³tszÄ… rÃ³Å¼nicÄ™
Zwracamy miniSpan
 
Podsumowanie w punktach 
Tworzymy kopiÄ™ wektora â†’ sortujemy jÄ…
Sprawdzamy, czy sÄ… co najmniej 2 liczby
UÅ¼ywamy indeksu i do iteracji po sÄ…siednich parach elementÃ³w
Liczymy rÃ³Å¼nicÄ™ miÄ™dzy kolejnymi elementami
Przechowujemy najmniejszÄ… rÃ³Å¼nicÄ™ w miniSpan
Zwracamy miniSpan

Dlaczego moÅ¼emy uÅ¼ywaÄ‡ int i zamiast iteratora?
Wektor w C++ obsÅ‚uguje indeksy (copy[i])
int i = pozycja w wektorze, proste i czytelne
Iterator jest alternatywÄ…, potrzebnÄ… np. gdy uÅ¼ywasz kontenerÃ³w, ktÃ³re nie obsÅ‚ugujÄ… indeksÃ³w (np. list)


Funkcja longestSpan() â€“ Notatki
Cel funkcji
ObliczyÄ‡ najdÅ‚uÅ¼szy span (najwiÄ™kszÄ… rÃ³Å¼nicÄ™) miÄ™dzy wszystkimi liczbami przechowywanymi w wektorze nb.
JeÅ›li jest mniej niÅ¼ 2 liczby â†’ rzucamy wyjÄ…tek.

Logika dziaÅ‚ania krok po kroku

Sprawdzenie liczby elementÃ³w
JeÅ›li nb.size() < 2 â†’ nie da siÄ™ policzyÄ‡ spanu
Rzucamy wyjÄ…tek: throw std::runtime_error("Need more numbers")

Ustawienie poczÄ…tkowych wartoÅ›ci
min = nb[0] â†’ zakÅ‚adamy, Å¼e pierwsza liczba jest najmniejsza
max = nb[0] â†’ zakÅ‚adamy, Å¼e pierwsza liczba jest najwiÄ™ksza
DziÄ™ki temu mamy punkt wyjÅ›cia do porÃ³wnaÅ„

Iteracja po wektorze
Przechodzimy po wszystkich elementach nb
Dla kaÅ¼dego elementu:
jeÅ›li element < min â†’ przypisz go do min
jeÅ›li element > max â†’ przypisz go do max
Po zakoÅ„czeniu pÄ™tli min i max sÄ… odpowiednio najmniejszÄ… i najwiÄ™kszÄ… liczbÄ… w wektorze

Obliczenie longest span
r = max - min
To jest najdÅ‚uÅ¼sza rÃ³Å¼nica miÄ™dzy liczbami â†’ najdÅ‚uÅ¼szy span
ZwrÃ³cenie wyniku
Funkcja zwraca r jako wynik typu unsigned int

Dlaczego dziaÅ‚a
NajwiÄ™ksza rÃ³Å¼nica zawsze bÄ™dzie miÄ™dzy najmniejszym a najwiÄ™kszym elementem
Nie trzeba sortowaÄ‡ ani porÃ³wnywaÄ‡ wszystkich par liczb
Funkcja jest szybka i efektywna: iteracja po wektorze tylko raz

Dlaczego uÅ¼ywamy int i
i = indeks pozycji w wektorze
Wektor obsÅ‚uguje indeksowanie nb[i] â†’ Å‚atwe i szybkie
Nie potrzebujemy iteratora, bo vector pozwala na bezpoÅ›redni dostÄ™p przez indeksy

Podsumowanie
Funkcja jest prosta: znajdÅº min i max â†’ odejmij â†’ wynik = longest span
Bez sortowania, bez kopii wektora
ObsÅ‚uguje liczby ujemne i dodatnie

| Bez `try-catch`        | Z `try-catch`                        |
| ---------------------- | ------------------------------------ |
| Program crashuje       | Program kontroluje wyjÄ…tek           |
| Komunikat: core dumped | Komunikat czytelny dla uÅ¼ytkownika   |
| Nie moÅ¼na kontynuowaÄ‡  | MoÅ¼na kontynuowaÄ‡ dziaÅ‚anie programu |
Wniosek:
W C++ wszystkie wyjÄ…tki powinny byÄ‡ Å‚apane, jeÅ›li chcemy kontrolowaÄ‡ program i uniknÄ…Ä‡ crashy.
try-catch pozwala testowaÄ‡ funkcje, ktÃ³re majÄ… rzucaÄ‡ wyjÄ…tki, bez ryzyka â€wywalania programuâ€.