Wymagania programu:

Program musi przyjmowaÄ‡ jako argument wyraÅ¼enie matematyczne w odwrÃ³conej notacji polskiej (RPN).
Liczby w tym wyraÅ¼eniu (i przekazywane w argumentach) zawsze bÄ™dÄ… mniejsze niÅ¼ 10. Wynik obliczeÅ„ nie musi byÄ‡ ograniczony tymi reguÅ‚ami.
Program musi przetworzyÄ‡ to wyraÅ¼enie i wypisaÄ‡ poprawny wynik na standardowe wyjÅ›cie (terminal).
JeÅ›li podczas dziaÅ‚ania programu pojawi siÄ™ bÅ‚Ä…d, wyÅ›wietl komunikat "Error" na standardowym wyjÅ›ciu bÅ‚Ä™dÃ³w.
Program musi obsÅ‚ugiwaÄ‡ operatory: +, -, *, /.
W kodzie musisz uÅ¼yÄ‡ co najmniej jednego kontenera (np. std::stack, std::vector itp.).
Nie musisz obsÅ‚ugiwaÄ‡ nawiasÃ³w ani liczb dziesiÄ™tnych.


Co to jest RPN?
RPN (Reverse Polish Notation, czyli odwrÃ³cona notacja polska) to sposÃ³b zapisywania wyraÅ¼eÅ„ matematycznych, w ktÃ³rym operator wystÄ™puje po operandach.
Standardowo zapisujemy: 3 + 4
W RPN zapisujemy: 3 4 +
Nie potrzebujemy nawiasÃ³w, bo kolejnoÅ›Ä‡ operacji jest jednoznaczna.


Jak dziaÅ‚a RPN?
RPN uÅ¼ywa stosÃ³w do obliczeÅ„.
OgÃ³lna zasada:
Przechodzimy przez kolejne elementy wyraÅ¼enia od lewej do prawej.

JeÅ›li element to liczba, wkÅ‚adamy jÄ… na stos.
JeÅ›li element to operator (np. +, -, *, /):
Zdejmujemy ze stosu ostatnie dwie liczby
Wykonujemy dziaÅ‚anie: a operator b
Wynik wkÅ‚adamy z powrotem na stos
Po przejÅ›ciu caÅ‚ego wyraÅ¼enia na stosie zostaje wynik koÅ„cowy.

PrzykÅ‚ad
WyraÅ¼enie: 5 1 2 + 4 * + 3 -

Kroki:
5 â†’ wrzucamy na stos â†’ [5]
1 â†’ wrzucamy â†’ [5, 1]
2 â†’ wrzucamy â†’ [5, 1, 2]
+ â†’ zdejmujemy 1 i 2, dodajemy â†’ 3, wkÅ‚adamy â†’ [5, 3]
4 â†’ wrzucamy â†’ [5, 3, 4]
* â†’ zdejmujemy 3 i 4, mnoÅ¼ymy â†’ 12, wkÅ‚adamy â†’ [5, 12]
+ â†’ zdejmujemy 5 i 12, dodajemy â†’ 17, wkÅ‚adamy â†’ [17]
3 â†’ wrzucamy â†’ [17, 3]
- â†’ zdejmujemy 17 i 3, odejmujemy â†’ 14
Wynik: 14

Do czego siÄ™ uÅ¼ywa RPN?
W kalkulatorach naukowych (np. HP) â€“ Å‚atwiej przetwarzaÄ‡ wyraÅ¼enia bez nawiasÃ³w.
W kompilatorach i interpreterach do przetwarzania wyraÅ¼eÅ„ matematycznych.
W programowaniu do szybkich obliczeÅ„ w stosie, np. w zadaniu z C++ o RPN, ktÃ³re robisz.

Plan funkcji â€“ RPN (ze std::stack)

1. isNumber(token)

Cel: sprawdziÄ‡, czy token jest poprawnÄ… liczbÄ…
Krok po kroku:
Sprawdza dÅ‚ugoÅ›Ä‡ tokenu
musi byÄ‡ dokÅ‚adnie 1 znak
Sprawdza, czy znak jest cyfrÄ… 0â€“9
JeÅ›li tak â†’ token jest liczbÄ…
JeÅ›li nie â†’ nie jest liczbÄ…

Nie wrzuca nic na stack.
Nie konwertuje do int.
Tylko sprawdza.

uÅ¼ywana w:
validateToken(token)
processToken(token)
To jest funkcja pomocnicza, prywatna.

2. isOperator(token)

Cel: sprawdziÄ‡, czy token jest poprawnym operatorem
Krok po kroku:

Sprawdza dÅ‚ugoÅ›Ä‡ tokenu
musi byÄ‡ dokÅ‚adnie 1 znak
Sprawdza, czy znak to jeden z: + - * /
JeÅ›li tak â†’ operator poprawny
JeÅ›li nie â†’ nie jest operatorem

3. validateToken(token)

Cel: walidacja pojedynczego tokenu
Krok po kroku:
Sprawdza, czy token jest liczbÄ…
JeÅ›li nie â†’ sprawdza, czy jest operatorem
JeÅ›li ani jedno, ani drugie â†’ bÅ‚Ä…d
Nie wykonuje Å¼adnych obliczeÅ„
Nie dotyka stacka
To jest bramka bezpieczeÅ„stwa przed logikÄ… RPN.

4. applyOperator(operator)

Cel: wykonaÄ‡ operacjÄ™ na dwÃ³ch elementach stacka
Krok po kroku:
Sprawdza, czy stack ma co najmniej 2 elementy
jeÅ›li nie â†’ bÅ‚Ä…d
Zdejmuje drugi operand ze stacka
Zdejmuje pierwszy operand ze stacka
Sprawdza, jaki to operator
JeÅ›li operator to /
sprawdza, czy drugi operand â‰  0
jeÅ›li 0 â†’ bÅ‚Ä…d
Wykonuje odpowiednie dziaÅ‚anie
Wynik wrzuca z powrotem na stack

Nie iteruje po stringu.
Nie sprawdza tokenÃ³w.
Robi tylko matematykÄ™.

logika gÅ‚Ã³wna
5. processToken(token)

Cel: obsÅ‚uÅ¼yÄ‡ pojedynczy token
Krok po kroku:
WywoÅ‚uje validateToken(token)
JeÅ›li token jest liczbÄ…:
konwertuje znak na int
wrzuca wartoÅ›Ä‡ na stack
JeÅ›li token jest operatorem:
wywoÅ‚uje applyOperator(token)
Nic nie wypisuje
Nie Å‚apie bÅ‚Ä™dÃ³w
To jest poÅ‚Ä…czenie walidacji + dziaÅ‚ania.

6. execute(expression)

Cel: wykonaÄ‡ caÅ‚e wyraÅ¼enie RPN
Krok po kroku:
Dzieli string wejÅ›ciowy na tokeny po spacjach
Iteruje po tokenach od lewej do prawej
Dla kaÅ¼dego tokenu:
wywoÅ‚uje processToken(token)
Po przetworzeniu wszystkich tokenÃ³w:
sprawdza, czy stack ma dokÅ‚adnie 1 element
jeÅ›li nie â†’ bÅ‚Ä…d
Zdejmuje wynik ze stacka
Zwraca wynik

isdigit zawsze wywoÅ‚ujesz jako funkcjÄ™ i zawsze przekazujesz jej znak, a nie string.
âœ… PrawidÅ‚owo: isdigit(token[0])
âŒ NieprawidÅ‚owo: token[0].isdigit()
âŒ NieprawidÅ‚owo: isdigit.token[0]

4ï¸âƒ£ Jak zapamiÄ™taÄ‡
isdigit = funkcja, nie obiekt
Argument = pojedynczy znak
Nie uÅ¼ywamy kropki (.) ani pÄ™tli
JeÅ›li string ma dÅ‚ugoÅ›Ä‡ 1 â†’ token[0] wystarczy


Tworzymy strumieÅ„ z caÅ‚ego stringa
std::istringstream iss(expression);

expression to np. "3 4 + 2 *"
Teraz iss zachowuje siÄ™ jak plik lub cin â€“ moÅ¼emy czytaÄ‡ tokeny po kolei.

Tworzymy zmiennÄ… na token
std::string currentToken;
BÄ™dzie przechowywaÄ‡ kolejne sÅ‚owo / token z wyraÅ¼enia.

PÄ™tla czytajÄ…ca tokeny
while (iss >> currentToken)
Operator >> czyta kolejny ciÄ…g znakÃ³w oddzielony spacjÄ….
Dla "3 4 + 2 *" kolejno currentToken przyjmie: "3", "4", "+", "2", "*".
WywoÅ‚anie funkcji dla tokenu
processToken(currentToken);
KaÅ¼dy token jest przetwarzany osobno (liczba â†’ push na stack, operator â†’ wykonanie dziaÅ‚ania).

1ï¸âƒ£ Sprawdzenie rozmiaru stacka
if(stack.size() != 1)
    throw std::runtime_error("Error");
Dlaczego to robimy?
W poprawnym wyraÅ¼eniu RPN po przetworzeniu wszystkich tokenÃ³w na stacku powinna zostaÄ‡ dokÅ‚adnie jedna liczba â€“ to jest wynik caÅ‚ego wyraÅ¼enia.
JeÅ›li jest mniej niÅ¼ 1 â†’ coÅ› poszÅ‚o nie tak (np. brak operandÃ³w).
JeÅ›li jest wiÄ™cej niÅ¼ 1 â†’ teÅ¼ coÅ› poszÅ‚o nie tak (np. za maÅ‚o operatorÃ³w).
Efekt: jeÅ›li warunek nie jest speÅ‚niony â†’ rzucamy wyjÄ…tek (throw) i program informuje o bÅ‚Ä™dzie.

2ï¸âƒ£ Pobranie wyniku ze stacka
int rest = stack.top();
stack.pop();
stack.top() â†’ bierze wartoÅ›Ä‡ z wierzchu stacka, czyli wynik RPN.
stack.pop() â†’ usuwa tÄ™ wartoÅ›Ä‡ ze stacka, Å¼eby stack byÅ‚ czysty po zakoÅ„czeniu.
Teraz rest zawiera wynik caÅ‚ego wyraÅ¼enia.

3ï¸âƒ£ ZwrÃ³cenie wyniku
return rest;
Funkcja execute zwraca wynik caÅ‚ego wyraÅ¼enia jako int.
To jest ostatni krok â€“ po tym masz gotowÄ… liczbÄ™, ktÃ³rÄ… moÅ¼esz np. wypisaÄ‡ na ekranie.

ğŸ”¹ Podsumowanie mentalne
Sprawdzamy: stack musi mieÄ‡ dokÅ‚adnie 1 element â€“ inaczej bÅ‚Ä…d.
Pobieramy ten element ze stacka â†’ to jest wynik RPN.
Usuwamy element ze stacka â†’ zachowujemy porzÄ…dek.
Zwracamy wynik do programu / uÅ¼ytkownika.