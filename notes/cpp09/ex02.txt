Program: PmergeMe, przyjmuje argumenty dodatnie liczby caÅ‚kowite.
Sortowanie: merge-insert (Ford-Johnson).
BÅ‚Ä™dy: wyÅ›wietla komunikat przy zÅ‚ych danych (np. liczby ujemne, litery).
Kontenery: uÅ¼yj dwÃ³ch rÃ³Å¼nych STL (np. vector i deque).
Liczby: obsÅ‚uguje â‰¥3000 elementÃ³w.
WyÅ›wietlanie:
Before: â†’ liczby nieposortowane
After: â†’ liczby posortowane
Czas sortowania â†’ osobno dla kaÅ¼dego kontenera
Duplikaty: decyzja naleÅ¼y do Ciebie.
Format wyjÅ›cia musi byÄ‡ czytelny.
Wskazane jest, aby implementowaÄ‡ algorytm osobno dla kaÅ¼dego kontenera, zamiast jednej ogÃ³lnej funkcji.

$> ./PmergeMe 3 5 9 7 4
Before: 3 5 9 7 4
After: 3 4 5 7 9
Time to process a range of 5 elements with std::vector : 0.00031 us
Time to process a range of 5 elements with std::deque : 0.00014 us

$> ./PmergeMe "-1" "2"
Error

Co trzeba zrobiÄ‡:
Parsowanie argumentÃ³w programu
Pobranie wszystkich liczb z argv[]
Sprawdzenie poprawnoÅ›ci (czy sÄ… dodatnie i czy w ogÃ³le liczby)
ObsÅ‚uga bÅ‚Ä™dÃ³w (wyÅ›wietlenie Error)

Implementacja merge-insert (Ford-Johnson)
Musisz dokÅ‚adnie odwzorowaÄ‡ algorytm merge-insert
ZastosowaÄ‡ go osobno dla dwÃ³ch rÃ³Å¼nych kontenerÃ³w STL
np. std::vector<int> i std::deque<int>
TestowaÄ‡ na rÃ³Å¼nych iloÅ›ciach danych, od kilku do 3000 elementÃ³w

WyÅ›wietlanie wynikÃ³w i pomiar czasu
Before: â†’ liczby nieposortowane
After: â†’ liczby posortowane
Pomiar czasu sortowania dla kaÅ¼dego kontenera (np. std::chrono)

Testowanie i debugowanie
Sprawdzenie na maÅ‚ych danych (Å‚atwo zobaczyÄ‡ efekt sortowania)
Sprawdzenie na duÅ¼ych danych (3000 liczb losowych)

KolejnoÅ›Ä‡ dziaÅ‚ania
Parsowanie i walidacja argumentÃ³w âœ…
WyÅ›wietlanie danych nieposortowanych (Before:) âœ…
Implementacja merge-insert dla vector
Implementacja merge-insert dla deque
WyÅ›wietlanie danych posortowanych (After:) âœ…
Pomiar czasu dla kaÅ¼dego kontenera
Testy i debugowanie
ObsÅ‚uga bÅ‚Ä™dÃ³w i edge-caseâ€™Ã³w

Po co uÅ¼ywamy tego algorytmu?
To sortowanie porÃ³wnawcze, ktÃ³re minimalizuje liczbÄ™ porÃ³wnaÅ„ w najgorszym przypadku.
Nie jest to praktyczne w codziennym kodzie produkcyjnym (np. std::sort jest szybszy)

Gdzie siÄ™ tego uÅ¼ywa?
W zadaniach uczelnianych i algorytmicznych, gdzie porÃ³wnania sÄ… drogie lub chcemy badaÄ‡ ich liczbÄ™.
W dowodach i analizach teoretycznych nad granicami sortowania.

ZaÅ‚oÅ¼enie algorytmu 
Najpierw sortujesz tylko â€wiÄ™kszeâ€ elementy z par, a potem bardzo sprytnie wstawiasz mniejsze elementy w odpowiednie miejsca.
CaÅ‚y trik polega na tym, w jakiej kolejnoÅ›ci je wstawiasz, Å¼eby zrobiÄ‡ jak najmniej porÃ³wnaÅ„.

KROK 1 â€” robisz PARy i sortujesz KAÅ»DÄ„ PARÄ˜

ÅÄ…czysz elementy po dwa:
(8, 3) (7, 4) (9, 2) (6)

KaÅ¼dÄ… parÄ™ sortujesz wewnÄ™trznie (wiÄ™kszy po prawej):
(3, 8) (4, 7) (2, 9) (6)

â¡ï¸ Widzisz tu dwie grupy:
mniejsze elementy: 3, 4, 2
wiÄ™ksze elementy: 8, 7, 9
6 zostaÅ‚ bez pary (tzw. straggler)


KROK 2 â€” sortujesz TYLKO WIÄ˜KSZE elementy
Bierzemy:
[ 8, 7, 9 ]
Sortujemy je rekurencyjnie tym samym algorytmem (albo zwykÅ‚ym sortem, bo to maÅ‚e dane):
[ 7, 8, 9 ]
â¡ï¸ To jest krÄ™gosÅ‚up caÅ‚ego sortowania.

KROK 3 â€” budujesz wynik startowy
Zaczynasz wynik od najmniejszego z duÅ¼ych + jego pary:
Najmniejszy duÅ¼y to 7, jego para to 4
result = [ 4, 7 ]

Reszta duÅ¼ych:

8, 9
Dodajesz je NA RAZIE bez ich par:
result = [ 4, 7, 8, 9 ]

KROK 4 â€” wstawiasz MAÅE elementy (SEDNO ALGORYTMU)
PozostaÅ‚e maÅ‚e elementy:
3 (para 8)
2 (para 9)
Teraz nie wstawiasz ich losowo.
Dlaczego?
Bo jeÅ›li wstawiasz w zÅ‚ej kolejnoÅ›ci, robisz za duÅ¼o porÃ³wnaÅ„.

Ford-Johnson mÃ³wi:
wstawiaj w kolejnoÅ›ci opartej o liczby Jacobsthala
Dla maÅ‚ych danych kolejnoÅ›Ä‡ jest po prostu:
pierwszy â†’ drugi â†’ reszta

Wstawianie 3
Szukasz miejsca binary searchem w:
[ 4, 7, 8, 9 ]
3 < 4 â†’ idzie na poczÄ…tek
[ 3, 4, 7, 8, 9 ]

Wstawianie 2
Binary search:
2 < 3
[ 2, 3, 4, 7, 8, 9 ]

KROK 5 â€” wstawiasz STRAGGLERA (jeÅ›li byÅ‚)
MieliÅ›my samotne 6.

Binary search w:
[ 2, 3, 4, 7, 8, 9 ]
6 wpada miÄ™dzy 4 a 7
[ 2, 3, 4, 6, 7, 8, 9 ]

CO TU SIÄ˜ WÅAÅšCIWIE STAÅO 
PorÃ³wnujesz elementy parami â†’ maÅ‚o porÃ³wnaÅ„
Sortujesz tylko poÅ‚owÄ™ danych (wiÄ™ksze z par)
ResztÄ™ wstawiasz binarnie, czyli bardzo tanio
KolejnoÅ›Ä‡ wstawiania jest sprytna â†’ minimalna liczba porÃ³wnaÅ„

CO MUSISZ ZROBIÄ† W PROJEKCIE 
W skrÃ³cie:
sparowaÄ‡ liczby
posortowaÄ‡ pary
wyciÄ…gnÄ…Ä‡ wiÄ™ksze elementy
posortowaÄ‡ je rekurencyjnie
wstawiÄ‡ mniejsze elementy binary searchem
zrobiÄ‡ to osobno dla:
std::vector
std::deque
zmierzyÄ‡ czas

JEDNO ZDANIE DO ZAPAMIÄ˜TANIA
Najpierw sortujÄ™ tylko wiÄ™ksze elementy z par,
a potem wstawiam resztÄ™ JEDEN PO DRUGIM do juÅ¼ uporzÄ…dkowanej listy.

Kontener set<int> w C++
1. Co to jest set<int>
set<int> to specjalny kontener w C++ (z biblioteki STL).
Przechowuje unikalne elementy â€“ czyli nie pozwala na duplikaty.
Elementy w set sÄ… posortowane rosnÄ…co automatycznie (ale w tym przypadku sortowanie nie jest najwaÅ¼niejsze, tylko unikalnoÅ›Ä‡).
DostÄ™p do elementu jest bardzo szybki â€“ wyszukiwanie elementu w set ma zÅ‚oÅ¼onoÅ›Ä‡ O(log n).

seenNumbers.insert(number) â†’ prÃ³buje dodaÄ‡ number do setu
.second â†’ sprawdza bool: true jeÅ›li dodano, false jeÅ›li byÅ‚ duplikat
! â†’ odwraca wartoÅ›Ä‡:
jeÅ›li false (czyli duplikat), to !false = true â†’ wyrzucamy "Error"
jeÅ›li true (nowa liczba), to !true = false â†’ wszystko OK

Masz pusty zbiÃ³r: {}
Dodajesz 5 â†’ zbiÃ³r: {5}, .second = true â†’ OK
Dodajesz 7 â†’ zbiÃ³r: {5, 7}, .second = true â†’ OK
Dodajesz 5 â†’ zbiÃ³r: {5, 7}, .second = false â†’ throw Error

1ï¸âƒ£ strtol â€“ co robi
Funkcja z C/C++:
long strtol(const char *nptr, char **endptr, int base);
nptr â†’ wskaÅºnik na string, ktÃ³ry chcesz zamieniÄ‡ na liczbÄ™.
endptr â†’ wskaÅºnik do wskaÅºnika, ktÃ³ry po konwersji wskaÅ¼e miejsce w stringu, gdzie konwersja siÄ™ zakoÅ„czyÅ‚a.
base â†’ podstawa systemu, np. 10 dla dziesiÄ™tne

strtol konwertuje string na long i podaje wskaÅºnik na znak,
ktÃ³ry zakoÅ„czyÅ‚ konwersjÄ™. JeÅ›li *endptr != '\0', to znaczy,
Å¼e po liczbie w stringu sÄ… jeszcze inne znaki â†’ bÅ‚Ä…d.


1ï¸âƒ£ Funkcje potrzebne dla wektora (logika Ford-Johnson / merge-insert)
Funkcja gÅ‚Ã³wna
Cel: WywoÅ‚uje caÅ‚y algorytm sortowania wektora.

OdpowiedzialnoÅ›Ä‡:
Sprawdza, czy wektor jest pusty lub ma 1 element â€“ wtedy nic nie robi.
WywoÅ‚uje funkcjÄ™ rekurencyjnÄ…, ktÃ³ra implementuje merge-insert.
Nazwa w Twojej klasie: np. sortVector()

Funkcja rekurencyjna merge-insert
Cel: Dzieli tablicÄ™ na mniejsze fragmenty i sortuje je.
OdpowiedzialnoÅ›Ä‡:
JeÅ›li rozmiar fragmentu jest maÅ‚y (np. < 10), wywoÅ‚uje insertion sort.
Dzieli tablicÄ™ na dwie czÄ™Å›ci: lewÄ… i prawÄ…
WywoÅ‚uje siebie rekurencyjnie dla lewej i prawej czÄ™Å›ci.
Po posortowaniu fragmentÃ³w, wywoÅ‚uje funkcjÄ™ scalajÄ…cÄ….
Nazwa: np. mergeInsertSortVector(int left, int right)

Funkcja insertion sort
Cel: Sortuje fragment wektora przy pomocy prostego algorytmu wstawiania.
OdpowiedzialnoÅ›Ä‡:
Bierze fragment wektora od left do right.
Dla kaÅ¼dego elementu od left+1 do right przesuwa go w odpowiednie miejsce.
Nazwa: np. insertionSortVector(int left, int right)

Funkcja merge (scalanie)
Cel: ÅÄ…czy dwa juÅ¼ posortowane fragmenty wektora w jeden posortowany fragment.
OdpowiedzialnoÅ›Ä‡:
Bierze fragment wektora od left do mid oraz od mid+1 do right.
Tworzy tymczasowe wektory dla lewej i prawej strony.
PorÃ³wnuje elementy obu fragmentÃ³w i wstawia je w kolejnoÅ›ci rosnÄ…cej do gÅ‚Ã³wnego wektora.
Nazwa: np. mergeVector(int left, int mid, int right)

2ï¸âƒ£ KolejnoÅ›Ä‡ implementacji funkcji

Insertion sort â€“ najprostsza funkcja, moÅ¼esz od razu jÄ… przetestowaÄ‡ na fragmencie wektora.
Merge â€“ funkcja scalajÄ…ca dwa fragmenty; moÅ¼esz testowaÄ‡ jÄ… z rÄ™cznie posortowanymi fragmentami.
Merge-insert rekurencyjny â€“ uÅ¼ywa powyÅ¼szych dwÃ³ch funkcji, dzieli wektor na fragmenty.
sortVector() â€“ funkcja "publiczna", ktÃ³ra wywoÅ‚uje rekurencyjny merge-insert na caÅ‚ym wektorze.


Insertion Sort
1ï¸âƒ£ Co to sÄ… left i right?

left = indeks poczÄ…tku fragmentu wektora, ktÃ³ry chcesz posortowaÄ‡.
right = indeks koÅ„ca fragmentu wektora, ktÃ³ry chcesz posortowaÄ‡.

PrzykÅ‚ad:
vec = [5, 2, 4, 6, 1, 3]
JeÅ›li chcesz posortowaÄ‡ caÅ‚y wektor: left = 0, right = 5
JeÅ›li chcesz posortowaÄ‡ tylko [4, 6, 1] â†’ left = 2, right = 4
Dlaczego uÅ¼ywamy left i right?
Funkcja merge-insert dzieli wektor na mniejsze fragmenty, wiÄ™c chcemy mÃ³c sortowaÄ‡ tylko czÄ™Å›Ä‡ wektora, a nie caÅ‚y wektor.

2ï¸âƒ£ Co to jest key?
key = element, ktÃ³ry aktualnie prÃ³bujemy wstawiÄ‡ w posortowanÄ… czÄ™Å›Ä‡ wektora.
WyciÄ…gamy go z wektora: key = vec[i]
PrzykÅ‚ad:

vec = [5, 2, 4, 6, 1, 3], i = 1
key = vec[1] = 2
Teraz "trzymamy" 2 w rÄ™ku i przesuwamy wiÄ™ksze elementy w prawo, Å¼eby zrobiÄ‡ miejsce dla key.

3ï¸âƒ£ Co to jest i i j?

i = indeks elementu, ktÃ³ry obecnie prÃ³bujemy wstawiÄ‡ (nasz key)
j = indeks elementu w posortowanej czÄ™Å›ci po lewej, ktÃ³rego porÃ³wnujemy z key

WyjaÅ›nienie linijka po linijce z przykÅ‚adem [5, 2, 4]:

int key = 0; â€“ Tworzysz zmiennÄ… key, w ktÃ³rej bÄ™dziesz trzymaÄ‡ aktualnie wstawiany element.
int i = left + 1; â€“ ustawiasz indeks i na drugi element fragmentu wektora, bo pierwszy element traktujesz jako juÅ¼ posortowany.
while(i <= right) â€“ pÄ™tla przechodzi przez wszystkie elementy fragmentu wektora od left+1 do right.
PrzykÅ‚ad: [5, 2, 4], left = 0, right = 2 â†’ i kolejno: 1, 2.
key = this->vec[i]; â€“ zapisujesz bieÅ¼Ä…cy element w key.

Krok 1: i = 1 â†’ key = 2
int j = i - 1; â€“ ustawiasz j na indeks ostatniego elementu posortowanej czÄ™Å›ci po lewej stronie.
Krok 1: j = 0, vec[j] = 5
while(j >= left && vec[j] > key) â€“ dopÃ³ki element po lewej jest wiÄ™kszy od key, przesuwasz go w prawo.

Krok 1: vec[0] = 5 > 2 â†’ przesuwamy 5: [5, 5, 4]
Zmniejszamy j-- â†’ j = -1 â†’ warunek j >= left przestaje byÄ‡ prawdziwy
vec[j+1] = key; â€“ wstawiasz key w odpowiednie miejsce.

Krok 1: j+1 = 0 â†’ [2, 5, 4]
i++; â€“ przechodzisz do nastÄ™pnego elementu wektora.

Krok 2: i = 2 â†’ key = 4, j = 1, vec[j] = 5 > 4 â†’ przesuwamy 5: [2, 5, 5]
j = 0, vec[j] = 2 < 4 â†’ koÅ„czymy while, wstawiamy key: [2, 4, 5]

âœ… Po wykonaniu wszystkich krokÃ³w wektor [5, 2, 4] zostaje posortowany: [2, 4, 5].

PrzykÅ‚ad krok po kroku:

vec = [5, 2, 4, 6, 1, 3]
left = 0
i = 1 â†’ key = 2
j = i-1 = 0 â†’ porÃ³wnujemy key z vec[0] = 5
PoniewaÅ¼ 2 < 5, przesuwamy 5 w prawo: [5, 5, 4, 6, 1, 3]
Teraz zmniejszamy j-- â†’ j = -1 (juÅ¼ nie mamy po lewej)
Wstawiamy key na miejsce j+1 = 0: [2, 5, 4, 6, 1, 3]


Start: [5, 2, 4]
i = 1, key = 2, j = 0
vec[j] = 5 > 2 â†’ przesuwamy 5 â†’ [5, 5, 4]
j-- â†’ -1

Wstawiamy key: [2, 5, 4]
i = 2, key = 4, j = 1
vec[j] = 5 > 4 â†’ przesuwamy 5 â†’ [2, 5, 5]
j = 0, vec[j] = 2 < 4 â†’ koniec while
Wstawiamy key: [2, 4, 5] âœ…

Przed krokiem 1: [5][2][4]
key = 2 (trzymamy w rÄ™ku)
[5]   [  ]  [4]  <- przesuwamy 5 w prawo
[  ]  [5]   [4]  <- wstawiamy 2
Wektor: [2][5][4]

Krok 2: key = 4
[2][5][4]
key = 4 (trzymamy w rÄ™ku)
[2][5][ ]  <- przesuwamy 5 w prawo
[2][  ][5]  <- wstawiamy 4
Wektor: [2][4][5]

mergeVector

Funkcja merge bierze dwa posortowane fragmenty i Å‚Ä…czy je w jeden posortowany fragment w vec.
KaÅ¼dy element trafia na swoje miejsce, zaczynajÄ…c od najmniejszego.

przykÅ‚ad: [2, 5, 4]
left = 0, mid = 1, right = 2
Lewy fragment l = [2, 5]
Prawy fragment r = [4]
GÅ‚Ã³wny wektor vec = [2, 5, 4]

1ï¸âƒ£ PorÃ³wnujemy pierwsze elementy lewego i prawego fragmentu
l[0] = 2, r[0] = 4
2 <= 4 â†’ wstawiamy 2 do vec[0]
Teraz i=1, j=0, k=1
vec = [2, 5, 4]

2ï¸âƒ£ Kolejne porÃ³wnanie
l[1] = 5, r[0] = 4
5 > 4 â†’ wstawiamy 4 do vec[1]
Teraz i=1, j=1, k=2
vec = [2, 4, 4]

3ï¸âƒ£ Lewy fragment ma jeszcze element 5
Wstawiamy 5 do vec[2]
Teraz i=2, k=3
vec = [2, 4, 5] âœ…

4ï¸âƒ£ Prawy fragment juÅ¼ pusty â†’ nic nie robimy

Funkcja mergeInsertSortVector

Co robi:
Sprawdza rozmiar fragmentu:
JeÅ›li fragment jest maÅ‚y (np. < 10 elementÃ³w), uÅ¼ywa insertion sort, bo dla maÅ‚ych fragmentÃ³w jest szybszy.
JeÅ›li fragment jest wiÄ™kszy, dzieli go dalej.

Dzieli fragment na dwie czÄ™Å›ci:
Lewa czÄ™Å›Ä‡: left .. mid
Prawa czÄ™Å›Ä‡: mid+1 .. right
mid = (left + right) / 2
WywoÅ‚uje siebie rekurencyjnie dla lewej i prawej czÄ™Å›ci, aby je posortowaÄ‡.

Scalanie fragmentÃ³w:
Po posortowaniu obu czÄ™Å›ci, wywoÅ‚uje funkcjÄ™ mergeVector(left, mid, right), aby poÅ‚Ä…czyÄ‡ je w jeden fragment w vec.

Intuicja:
MyÅ›lisz o wektorze jak o ksiÄ…Å¼ce, ktÃ³rÄ… dzielisz na dwie czÄ™Å›ci.
Sortujesz kaÅ¼dÄ… czÄ™Å›Ä‡ oddzielnie, a potem Å‚Ä…czysz je w caÅ‚oÅ›Ä‡.
Dla maÅ‚ych fragmentÃ³w uÅ¼ywasz insertion sort, bo jest szybki dla krÃ³tkich list.


mergeInsertSortVector
1ï¸âƒ£
if ((right - left + 1) < 10)
â¡ï¸ Sprawdzasz, ile elementÃ³w ma ten fragment.
right - left + 1 = liczba elementÃ³w.

PrzykÅ‚ad:
left = 2, right = 4
elementy: vec[2], vec[3], vec[4] â†’ 3 elementy

2ï¸âƒ£
insertionSortVector(left, right);
return;
â¡ï¸ JeÅ›li fragment jest maÅ‚y, to:
sortujesz go insertion sortem
koÅ„czysz funkcjÄ™ (return)
Nie dzielisz juÅ¼ dalej.
ğŸ“Œ Dlaczego?
Bo insertion sort jest szybki dla maÅ‚ych fragmentÃ³w.

3ï¸âƒ£
int mid = (left + right) / 2;
â¡ï¸ Dzielisz fragment na pÃ³Å‚.
PrzykÅ‚ad:
left = 0, right = 5
mid = 2
Masz:
lewa czÄ™Å›Ä‡: 0 â†’ 2
prawa czÄ™Å›Ä‡: 3 â†’ 5

4ï¸âƒ£
mergeInsertSortVector(left, mid);
â¡ï¸ Rekurencja
MÃ³wisz:
â€Najpierw posortuj lewÄ… poÅ‚owÄ™â€

5ï¸âƒ£
mergeInsertSortVector(mid + 1, right);
â¡ï¸ Potem:
â€Posortuj prawÄ… poÅ‚owÄ™â€
W tym momencie:
lewa czÄ™Å›Ä‡ jest posortowana
prawa czÄ™Å›Ä‡ jest posortowana

6ï¸âƒ£
mergeVector(left, mid, right);
â¡ï¸ Scalasz dwie posortowane czÄ™Å›ci w jednÄ….
Czyli:
bierzesz lewÄ… posortowanÄ…
bierzesz prawÄ… posortowanÄ…
Å‚Ä…czysz je w jeden posortowany fragment
CaÅ‚oÅ›Ä‡ na MAÅYM PRZYKÅADZIE

Wektor:
[5, 2, 4]
left=0, right=2
(2 - 0 + 1) = 3 < 10
âœ insertionSortVector(0,2)

Wektor staje siÄ™:
[2, 4, 5]
Funkcja koÅ„czy siÄ™ (return)

Na WIÄ˜KSZYM PRZYKÅADZIE (intuicja)
[8, 3, 7, 1, 5, 2]
Dzielisz na:
[8,3,7] | [1,5,2]
KaÅ¼dÄ… czÄ™Å›Ä‡ dzielisz dalej
MaÅ‚e fragmenty sortujesz insertion sortem
Na koÅ„cu scalasz wszystko merge